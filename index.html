<!DOCTYPE html>
<html> 






<head>
    <link rel="icon" type="image/png" href="https://yt3.googleusercontent.com/Ki7nPuE744r5TVkDdIeBHvMyN5gCnZwpoTnw6LWysB5hIS_nwfPCaVwxjFZglaqFHmwXhep2rw=s160-c-k-c0x00ffffff-no-rj">

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simbox</title>
    <style>
        canvas {
      
            border: 1px solid black;
            display: block;
            margin: 0;
              overflow: hidden;
            
        }
        
 
        body {
            text-align: center;
            background-color:  rgb(97, 97, 97);
            user-select: none;
            margin: 0;
              overflow: hidden;
            /* Prevent text selection */
        }

  .material-selector {
    position: fixed;
    top: 50%;
    left: 28px;
    transform: translateY(-50%) scale(0);
    transform-origin: left center;
    background-color: #444;
    padding: 10px;
    border-radius: 10px 10px 10px 10px;
    color: white;
    display: grid;
    width: 20vw; /* Set a fixed width for the selector */
    grid-template-rows: auto 1fr; /* Dynamic columns based on content */
    gap: 10px; /* Consistent space between items */
    height: 85vh;
    overflow-y: auto;
    z-index: 15;
    transition: transform 0.4s ease, opacity 0.4s ease;
    opacity: 0;
    pointer-events: none; /* Disable interaction when hidden */
    justify-items: stretch; /* Ensure the items fill their grid cells evenly */
}



.material-button {
  border: none;
  padding: 12px;
  border-radius: 6px;
  font-size: 1em;
  font-weight: bold;
  transition: transform 0.3s ease, box-shadow 0.3s ease, color 0.3s ease;
  cursor: pointer;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    width: 5vw;
    height: 5vw;
  display: flex;
  justify-content: center;  /* Centers horizontally */
  align-items: center;      /* Centers vertically */
  text-align: center;       /* Ensures text aligns center in case of multi-line */
  white-space: nowrap;
  overflow: hidden;
   transition: background-color 0.3s, transform 0.1s;
   transform:scale(1);
}

.material-button:hover {

  transform: scale(1.05);
}
.material-selector.expand {
    transform: translateY(-50%) scale(1);
    opacity: 1;
    pointer-events: auto; /* enable interaction when shown */
}

 
 
     
 
       
 
 
        .selected {
            border: 2px solid #e9f603;
            /* Optional: highlight border */
            
 
        }

        #pauseButton {
          background-color: rgb(139, 139, 139, 0);
            border: none; /* Remove border */
            color: white; /* Text color */
            font-size: 24px; /* Font size */
            padding: 10px; /* Padding */
            cursor: pointer; /* Cursor style */
            border-radius: 5px; /* Rounded corners */
            position: relative; /* Position for pseudo-elements */
            width: 50px; /* Width of the button */
            height: 50px; /* Height of the button */
        }
 
        #pauseButton::before,
        #pauseButton::after {
            content: ""; /* Required for pseudo-elements */
            position: absolute; /* Positioning */
            width: 10px; /* Width of the bars */
            height: 30px; /* Height of the bars */
            background-color: white; /* Color of the bars */
            top: 10px; /* Position from the top */
        }
 
        #pauseButton::before {
            left: 10px; /* Position for the left bar */
        }
 
        #pauseButton::after {
            right: 10px; /* Position for the right bar */
        }
        #brushSize {
     width: 35px; /* Adjust width as needed */
     font-size: 14px; /* Adjust font size if necessary */
    
   }
        footer {
     position: absolute; /* or 'fixed' */
     bottom: 20px;    /* Adjust positioning */
     right: 20px;   /* based on where you want */
     z-index: 10;  /* Make sure it's above the canvas */
     color:rgb(139, 139, 139);
     padding: 10px;
     width: 190px; /* Set a smaller width */
     font-size: 12px; /* Smaller font size */
     height: 50px; /* Set a smaller height */
   }
  
  
    /* Styles for play button */
    #pauseButton.play::before {
            content: ""; /* Required for pseudo-element */
            position: absolute; /* Positioning */
            width: 0; /* Width of the triangle */
            height: 0; /* Height of the triangle */
            border-left: 20px solid white; /* Left side of the triangle */
            border-top: 15px solid transparent; /* Top side of the triangle */
            border-bottom: 15px solid transparent; /* Bottom side of the triangle */
            left: 10px; /* Position for the triangle */
            top: 10px; /* Position from the top */
        }
        @keyframes glitch {
     0% { text-shadow: 1px 0 red, -1px 0 blue; }
     25% { text-shadow: -1px 0 red, 1px 0 blue; }
     50% { text-shadow: 1px 0 red, -1px 0 blue; }
     75% { text-shadow: -1px 0 red, 1px 0 blue; }
     100% { text-shadow: 1px 0 red, -1px 0 blue; }
 }
 @keyframes uranium {
     0% { text-shadow: 1px 0 green, -1px 0 darkgreen; }
     25% { text-shadow: 1px 0 darkgreen, -1px 0 green; }
     50% { text-shadow: 1px 0 green, -1px 0 rgb(255, 98, 0); }
     75% { text-shadow: 1px 0 orange, -1px 0 red; }
     100% { text-shadow: 1px 0 red, -1px 0 green; }
 }
 
 #glitchButton {
     animation: glitch 1s infinite; /* Add this line */
 }
 #uraniumButton {
 
     animation: uranium 50s; /* Add this line */
 }
 
 .load-menu {
    position: fixed;
    right: 0;
    top: 50px; /* Adjust as needed */
    width: 250px; /* Width of the menu */
    background-color: #444;
    color: white;
    padding: 10px;
    border-radius: 10px 0 0 10px;
   
    z-index: 1000; /* Ensure it's above other content */
    gap: 10px;
            height: 85vh; /* Add this line */
            /* Space between buttons */
            overflow-y: auto;
}
.savePopUp{
    position:absolute;
    right: 50%;
    top: 25%;
    color: lightgreen;
   
}

.menu-container {
  position: absolute;
  top: 50%;
  left: 50%;
    height: 500px;
  transform: translate(-50%, -50%);
  background: rgba(255, 255, 255, 0.10);
  border: 1px solid rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(10px);
 border-radius: 5px;
  
  padding: 40px 30px;
  width: 350px;

  text-align: center;
  
  display: none;
  z-index: 150;
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
  
}
.blur {
  position: absolute;
  top: 0;
  left: 0;
  background-color: rgba(0, 0,0,0.5);
  opacity: 50%;
  width: 100vw;
  display: none;
  height: 100vh;
  backdrop-filter: blur(100px);
  -webkit-backdrop-filter: blur(300px); /* for Safari */
  z-index: 149;
  pointer-events: none; /* optional: allows clicking through */
}
.menu-title {
  font-size: 42px;
  font-weight: bold;
  color: #fff;
  margin-bottom: 30px;
  text-shadow: 2px 2px #000;
}

.menu-buttons {
    position: absolute;
    left: 0px;
    width: 50%;
  display: flex;
  flex-direction: column;
  
 
  gap: 25px;
}

.menu-buttons button,
.feedback-button {
  background-color: rgba(0,0,0,0);
  border: none;
  padding: 14px;
  font-size: 18px;
  z-index: 2;
  color: #fff;
  cursor: pointer;
  transition: color 0.2s;
  
  text-decoration: none;
}

.feedback-button:hover{
   color: rgb(235, 235, 235);
}
.menu-buttons button:hover{
   color:  rgb(235, 235, 235);
}

.settings-button {
  position: absolute;
  top: 10px;
  right: 10px;
  background: none;
  border: none;
  color: white;
  font-size: 28px;
  z-index: 2;
  cursor: pointer;
  transition: color 0.2s;
}

.settings-button:hover {
  color: #ccc;
}


        .lavacell1{
            background-color: orangered;
            display: block;
            position:absolute;
            right: 0;
            top: -9.5%;
          
            width: 10%;
            height: 10%;
        }
        .lavacell2{
            background-color: orange;
            display: block;
            position:absolute;
            right: -9.5%;
            top: -9.5%;
          
            width: 10%;
            height: 10%;
        }
        .lavacell3{
            background-color: rgb(255, 111, 0);
            display: block;
            position:absolute;
            right: -9.5%;
            top: 0;
          
            width: 10%;
            height: 10%;
        }
        .lavacell4{
            background-color: rgb(255, 153, 0);
            display: block;
            position:absolute;
            right: -9.5%;
            top: 9.5%;
          
            width: 10%;
            height: 10%;
        }
        .stonecell1{
            background-color: rgb(110, 110, 110);
            display: block;
            position:absolute;
            right: -9.5%;
            top: 19%;
          
            width: 10%;
            height: 60%;
        }
        .lavacell5{
            background-color: rgb(255, 98, 0);
            display: block;
            position:absolute;
            right: -19%;
            top: 9.5%;
          
            width: 10%;
            height: 10%;
        }
        .lavacell6{
            background-color: rgb(240, 84, 27);
            display: block;
            position:absolute;
            right: -19%;
            top: 19%;
          
            width: 10%;
            height: 10%;
        }
        .lavacell7{
            background-color: rgb(240, 144, 27);
            display: block;
            position:absolute;
            right: -19%;
            top: 28.5%;
          
            width: 10%;
            height: 70%;
        }
        .stonecell2{
            background-color: rgb(110, 110, 110);
            display: block;
            position:absolute;
            right: -19%;
            bottom: -8.5%;
          
            width: 10%;
            height: 10%;
        }
        .watercell1{
            background-color: rgb(40, 3, 255);
            display: block;
            position:absolute;
            left: -9.5%;
            bottom: -8.5%;
          
            width: 120%;
            height: 10%;
        }
        .watercell2{
            background-color: rgb(40, 3, 255);
            display: block;
            position:absolute;
            left: 50%;
            bottom: -50%;
          
            width: 10%;
            height: 10%;
        }
        .watercell3{
            background-color: rgb(40, 3, 255);
            display: block;
            position:absolute;
            left: 50%;
            bottom: -17%;
          
            width: 10%;
            height: 10%;
        }
        .catalog{
       
       position:absolute;
           background-color: rgb(255, 255, 255);
           width: 300px;
           height: 300px;
           display: none;
           top: 50%;
   left: 25%;
   transform: translate(-50%, -50%);
   
           z-index: 190;
           overflow-y: auto;
           border-radius: 10px 10px 10px 10px;
      }
  /* Window Styling (Command Prompt look-alike) */
.window {
    position: absolute;
    width: 600px;
    height: 350px;
    background-color: black;
    color: white;
    font-family: Consolas, 'Courier New', Courier, monospace;
    border: 2px solid #444;
    top: 100px;
    left: 100px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    display: none;
    flex-direction: column;
    resize: both;
    overflow: hidden;
    z-index: 130;
}

.window-header {
    background-color: #333;
    padding: 5px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: move;
    border-bottom: 2px solid #444;
}

#closeButton {
    background-color: red;
    color: white;
    border: none;
    padding: 3px 8px;
    cursor: pointer;
    font-size: 14px;
}

#closeButton:hover {
    background-color: darkred;
}

/* Command Prompt Styles */
#commandPrompt {
    flex: 1;
    display: flex;
    flex-direction: column;
    padding: 10px;
    overflow-y: auto;
}

#output {
    flex: 1;
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow-y: auto;
    margin-bottom: 10px;
    font-size: 14px;
}

.input-container {
    display: flex;
    width: 100%;
    margin-top: 10px;
}

#commandInput {
    background-color: black;
    color: white;
    border: none;
    width: 90%;
    padding: 5px;
    font-family: Consolas, 'Courier New', Courier, monospace;
    font-size: 14px;
}
.selection-box {
            position: absolute;
            border: 2px dashed #000;
            background-color: rgba(0, 0, 255, 0);
            pointer-events: none;
            display: none;
        }
  .mapcontainer {
    background-color: rgba(0, 0, 0, 0.3);
    display: grid;
    justify-content: center;
    align-items: center;
    height: 50vh;
    padding: 20px;
    width: 50vw;
    position: fixed;
    top: 50%;
    right: 25px; /* space from the right */
    transform: translateX(100%) translateY(-50%);
    opacity: 0;
    transition: transform 0.4s ease, opacity 0.4s ease;
    grid-template-columns: repeat(4, 1fr);
    z-index: 1000000;
    border-radius: 10px 10px 10px 10px;
    pointer-events: none;
}

.mapcontainer.expand {
    transform: translateX(0) translateY(-50%);
    opacity: 1;
    pointer-events: auto;
}

         .terraincontainer {
            background-color: rgba(0, 0, 0, 0.3);
            display: none;
            justify-content: center;
            align-items: center;
            height: 50vh;
            padding: 20px;
            width: 50vw;
            position: fixed;
            left: 50%;
            transform: translate(-50%, -50%);
            top: 50%;
            grid-template-columns: repeat(4, 1fr);
            z-index: 1000000;
        }
        .new {
    width: 150px;
    height: 150px;
    background-image: url('https://i.imghippo.com/files/Lnk8247oU.png');
    background-size: cover;  /* Ensure the image covers the entire button */
    background-position: center;  /* Center the image */
    font-size: 60px;
    color: white;
    border: none;  /* Optional: Remove button borders */
    z-index: 1;
}

.forest {
    width: 150px;
    height: 150px;
    background-image: url('https://i.imghippo.com/files/AKxl9843nM.png');
    background-size: cover;  /* Ensure the image covers the entire button */
    background-position: center;  /* Center the image */
    font-size: 50px;
    color: white;
    border: none;  /* Optional: Remove button borders */
}
.volcano {
    width: 150px;
    height: 150px;
    background-image: url('https://i.imghippo.com/files/JWo9833IPQ.png');
    background-size: cover;  /* Ensure the image covers the entire button */
    background-position: center;  /* Center the image */
    font-size: 40px;
    color: white;
    border: none;  /* Optional: Remove button borders */
}
.island {
    width: 150px;
    height: 150px;
    background-image: url('https://i.imghippo.com/files/bZn3875cc.png');
    background-size: cover;  /* Ensure the image covers the entire button */
    background-position: center;  /* Center the image */
    font-size: 40px;
    color: white;
    border: none;  /* Optional: Remove button borders */
}
.city {
    width: 150px;
    height: 150px;
    background-image: url('https://i.imghippo.com/files/VYS1568Feo.png');
    background-size: cover;  /* Ensure the image covers the entire button */
    background-position: center;  /* Center the image */
    font-size: 40px;
    color: white;
    border: none;  /* Optional: Remove button borders */
}
.desert {
    width: 150px;
    height: 150px;
    background-image: url('https://i.imghippo.com/files/MD7075bsk.png');
    background-size: cover;  /* Ensure the image covers the entire button */
    background-position: center;  /* Center the image */
    font-size: 40px;
    color: white;
    border: none;  /* Optional: Remove button borders */
}
.wasteland {
    width: 150px;
    height: 150px;
    background-image: url('https://i.imghippo.com/files/DgTZ8401kY.png');
    background-size: cover;  /* Ensure the image covers the entire button */
    background-position: center;  /* Center the image */
    font-size: 30px;
    color: white;
    border: none;  /* Optional: Remove button borders */
}
.terrain {
    width: 150px;
    height: 150px;
    background-image: url('https://raw.githubusercontent.com/Guttobear/soundssimbox/refs/heads/main/terrainmapimage.png');
    background-size: cover;  /* Ensure the image covers the entire button */
    background-position: center;  /* Center the image */
    font-size: 30px;
    color: white;
    border: none;  /* Optional: Remove button borders */
}
.mountain {
    width: 150px;
    height: 150px;
    background-image: url('https://raw.githubusercontent.com/Guttobear/soundssimbox/refs/heads/main/mountainicon.png');
    background-size: cover;  /* Ensure the image covers the entire button */
    background-position: center;  /* Center the image */
    font-size: 30px;
    color: white;
    border: none;  /* Optional: Remove button borders */
}
.plain {
    width: 150px;
    height: 150px;
    background-image: url('https://raw.githubusercontent.com/Guttobear/soundssimbox/refs/heads/main/plainsicon.png');
    background-size: cover;  /* Ensure the image covers the entire button */
    background-position: center;  /* Center the image */
    font-size: 30px;
    color: white;
    border: none;  /* Optional: Remove button borders */
}
.ocean {
    width: 150px;
    height: 150px;
    background-image: url('https://raw.githubusercontent.com/Guttobear/soundssimbox/refs/heads/main/oceanicon.png');
    background-size: cover;  /* Ensure the image covers the entire button */
    background-position: center;  /* Center the image */
    font-size: 30px;
    color: white;
    border: none;  /* Optional: Remove button borders */
}
.forest {
    width: 150px;
    height: 150px;
    background-image: url('https://raw.githubusercontent.com/Guttobear/soundssimbox/refs/heads/main/foresticon.png');
    background-size: cover;  /* Ensure the image covers the entire button */
    background-position: center;  /* Center the image */
    font-size: 30px;
    color: white;
    border: none;  /* Optional: Remove button borders */
}
.taiga {
    width: 150px;
    height: 150px;
    background-image: url('https://raw.githubusercontent.com/Guttobear/soundssimbox/refs/heads/main/taigaicon.png');
    background-size: cover;  /* Ensure the image covers the entire button */
    background-position: center;  /* Center the image */
    font-size: 30px;
    color: white;
    border: none;  /* Optional: Remove button borders */
}
.platuea {
    width: 150px;
    height: 150px;
    background-image: url('https://raw.githubusercontent.com/Guttobear/soundssimbox/refs/heads/main/platueaicon.png');
    background-size: cover;  /* Ensure the image covers the entire button */
    background-position: center;  /* Center the image */
    font-size: 30px;
    color: white;
    border: none;  /* Optional: Remove button borders */
}
.close {
    width: 50px;
    position: absolute;
    right: 0;
    top: 0;
    
}
.settingbuttonopen{
    position: absolute;
    bottom: 0;
    left: 0;
}
.settingcontainer{
        background-color: #3B3B3B;
            display:  none;
           
            border-radius: 20px 20px 20px 20px;
            height: 50vh;
            padding: 20px;
            gap:20px;
            width: 400px;
            position: absolute;
           
            left: 50%;
            transform: translate(-50%, -50%);
            top: 50%;
            grid-template-columns: repeat(1, 1fr);

      }
      .settingtext{
        position:absolute;
        font-size: 60px;
        top: -19%;
        left: 50%;
        transform: translateX(-50%);
      }
      .settingbutton {
        border:none;
    width: 55%;
    height: 15%;
    clip-path: polygon(0% 0%, 80% 0%, 100% 50%, 80% 100%, 0% 100%);
    font-size: 40px;
    cursor: pointer;
    transition: width 0.05s, padding-left 0.01s ease-in-out; /* Smooth transition for width change */
    background-color: rgb(0, 0, 0);
    color: rgb(167, 167, 167);
    text-align: left; /* Align text to the left */
    padding-left: 10%; /* Adjust this value to move the text slightly to the right */
}

.settingbutton:hover {
    width: 65%; /* Increases width on hover */
    padding-left: 20%; 
}

      
      #soundbutton{
        
        top: 5%;
        position:absolute;
        left: 0%;
        transform: scale(1);
        clip-path: polygon(0% 0%, 80% 0%, 100% 50%, 80% 100%, 0% 100%);
        
        font-size: 40px;
       
      }
      #gridbutton{
     
        top: 25%;
        position:absolute;
        left: 0%;
        transform: scale(1);
        clip-path: polygon(0% 0%, 80% 0%, 100% 50%, 80% 100%, 0% 100%);
        
        font-size: 40px;
      }
      #controlsbutton{
     
     top: 45%;
     position:absolute;
     left: 0%;
     transform: scale(1);
     clip-path: polygon(0% 0%, 80% 0%, 100% 50%, 80% 100%, 0% 100%);
     
     font-size: 40px;
   }

   #themebutton{
     
     top: 65%;
     position:absolute;
     left: 0%;
     transform: scale(1);
     clip-path: polygon(0% 0%, 80% 0%, 100% 50%, 80% 100%, 0% 100%);
     
     font-size: 40px;
   }
  
      .gridcontainer{
        background-color:  #3B3B3B;
            display:  none;
           
            border-radius: 20px 20px 20px 20px;
            height: 50vh;
            padding: 20px;
           
            width: 400px;
            position: absolute;
           
            left: 50%;
            transform: translate(-50%, -50%);
            top: 50%;
           

      }
      .controlscontainer{
        background-color: #3B3B3B;
            display:  none;
           
            border-radius: 20px 20px 20px 20px;
            height: 50vh;
            padding: 20px;
           
            width: 400px;
            position: absolute;
           
            left: 50%;
            transform: translate(-50%, -50%);
            top: 50%;
           

      }
      .themecontainer{
        background-color:  #3B3B3B;
            display:  none;
           
            border-radius: 20px 20px 20px 20px;
            height: 50vh;
            padding: 20px;
           
            width: 400px;
            position: absolute;
           
            left: 50%;
            transform: translate(-50%, -50%);
            top: 50%;
           

      }
      .backbutton{
        position: absolute;
        left: 0;
        top: 0;
        background-color: rgb(17, 17, 17);
        color: rgb(157, 157, 157);
            
    border-radius: 20px 0px 9px 1px; /* Rounded on the left */
        font-size: 20px;
      }
      .closebutton{
        position: absolute;
        right: 0;
        top: 0;
        background-color: rgb(17, 17, 17);
        color: rgb(157, 157, 157);
            
    border-radius: 0px 20px 1px 9px; /* Rounded on the left */
        font-size: 20px;
      }
      .nowallstoggle{
        
       
        border:none;
        position: absolute;
        left: 0;
    width: 55%;
    height: 15%;
    top: 25%;
    clip-path: polygon(0% 0%, 80% 0%, 100% 50%, 80% 100%, 0% 100%);
    font-size: 40px;
    cursor: pointer;
    transition: width 0.05s, padding-left 0.05s ease-in-out; /* Smooth transition for width change */
    background-color: rgb(0, 0, 0);
    color: rgb(167, 167, 167);
    text-align: left; /* Align text to the left */
    padding-left: 5%; /* Adjust this value to move the text slightly to the right */

      }
      .voxelsize{
        
        border:none;
        position: absolute;
        left: 0;
    width: 55%;
    height: 15%;
    top: 45%;
    clip-path: polygon(0% 0%, 80% 0%, 100% 50%, 80% 100%, 0% 100%);
    font-size: 36px;
    cursor: pointer;
    transition: width 0.05s, padding-left 0.05s ease-in-out; /* Smooth transition for width change */
    background-color: rgb(0, 0, 0);
    color: rgb(167, 167, 167);
    text-align: left; /* Align text to the left */
    padding-left: 0%; /* Adjust this value to move the text slightly to the right */
      }
      .speed{
        
        border:none;
        position: absolute;
        left: 0;
    width: 55%;
    height: 15%;
    top: 65%;
    clip-path: polygon(0% 0%, 80% 0%, 100% 50%, 80% 100%, 0% 100%);
    font-size: 36px;
    cursor: pointer;
    transition: width 0.05s, padding-left 0.05s ease-in-out; /* Smooth transition for width change */
    background-color: rgb(0, 0, 0);
    color: rgb(167, 167, 167);
    text-align: left; /* Align text to the left */
    padding-left: 0%; /* Adjust this value to move the text slightly to the right */
      }
      #voxelsize{
        background-color:rgb(17, 17, 17);
        width: 20px;
        color: white;
        height: 20px;
      }
.nowallstoggle:hover {
    width: 65%; /* Increases width on hover */
    padding-left: 15%; 
}
.voxelsize:hover {
    width: 60%; /* Increases width on hover */
    padding-left: 10%; 
}
.speed:hover {
    width: 60%; /* Increases width on hover */
    padding-left: 10%; 
}
.themetoggle{
        
       
        border:none;
        position: absolute;
        left: 0;
    width: 55%;
    height: 15%;
    top: 25%;
    clip-path: polygon(0% 0%, 80% 0%, 100% 50%, 80% 100%, 0% 100%);
    font-size: 30px;
    cursor: pointer;
    transition: width 0.05s, padding-left 0.05s ease-in-out; /* Smooth transition for width change */
    background-color: rgb(0, 0, 0);
    color: rgb(167, 167, 167);
    text-align: left; /* Align text to the left */
    padding-left: 5%; /* Adjust this value to move the text slightly to the right */

      }
.themetoggle:hover {
    width: 65%; /* Increases width on hover */
    padding-left: 15%; 
}
.hotkeys{
  background-color: rgba(0, 0, 0, 0);
            display:  block;
            color: rgb(157, 157, 157);
            border-radius: 20px 20px 20px 20px;
            height: 50%;
            top: 15%;
            width: 100%;
            position: absolute;
            justify-content: left;
            left: 10px;
            font-style: bold;
            
           
            
}
.soundcontainer {
    background-color: #3B3B3B;
    display: none;
    border-radius: 20px;
    height: 50vh;
    padding: 20px;
    width: 400px;
    position: absolute;
    left: 50%;
    transform: translate(-50%, -50%);
    top: 50%;
    text-align: center;
    color: #f0f0f0;
    font-family: 'Arial', sans-serif;
  }

  
  .slider-container {
    margin: 20px 0;
    color: #fff;
    text-align: left;
  }

  .slider-container label {
    display: block;
    margin-bottom: 8px;
    font-size: 18px;
    font-weight: 500;
  }

  .slider-container input[type="range"] {
    width: 100%;
    height: 12px; /* Bigger height */
    background: #2a2a2a;
    border-radius: 12px;
    outline: none;
    appearance: none;
    cursor: pointer;
    
    box-sizing: border-box; /* Make sure padding and borders are included in size */
    transition: background 0.3s ease, transform 0.3s ease;
  }

  /* Prevent the slider from growing in height on hover */
  .slider-container input[type="range"]:hover {
    background: #3c3c3c;
    transform: scaleY(1.1);
  }

  .slider-container input[type="range"]::-webkit-slider-thumb {
    appearance: none;
    width: 20px;
    height: 20px;
    background: #888;
    border: 2px solid #111;
    border-radius: 50%;
    box-shadow: 0 0 6px #000;
    
    transition: background 0.3s ease, transform 0.2s ease;
    margin-top: -4px; /* Fix thumb offset (this aligns the thumb correctly) */
  }

  .slider-container input[type="range"]::-webkit-slider-thumb:hover {
    background: #aaa;
    transform: scale(1.1);
  }

  .slider-container input[type="range"]::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: #888;
    border: 2px solid #111;
    border-radius: 50%;
    box-shadow: 0 0 6px #000;
    transition: background 0.3s ease, transform 0.2s ease;
    margin-top: -4px; /* Fix thumb offset */
  }

  .slider-container input[type="range"]::-moz-range-thumb:hover {
    background: #aaa;
    transform: scale(1.1);
  }

  .slider-container input[type="range"]::-webkit-slider-runnable-track {
    background: #444;
    height: 12px;
    border-radius: 10px;
  }

  .slider-container input[type="range"]::-moz-range-track {
    background: #444;
    height: 12px;
    border-radius: 10px;
  }
  .imagecontainer {
      background-color: rgb(83, 83, 83);
      position: absolute;
      right: -5%;
      width: 20%;
      height: 50%;
      bottom: -20%;
      transform: translate(-50%, -50%) scale(0);
      transform-origin: bottom right;
      opacity: 0;
      border-radius: 10px;
      transition: transform 0.3s ease, opacity 0.3s ease;
      pointer-events: none;
    }

    .imagecontainer.show {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
      pointer-events: auto;
    }

    .imagetitle {
      color: white;
      position: absolute;
      font-size: 30px;
      left: 50%;
      width: 100%;
      text-align: center;
      transform: translate(-50%);
      font-weight: bold;
    }

    .imageselector {
      position: absolute;
      top: 20%;
      left: 0%;
    }

    #dynamicImage {
      max-width: 100%;
      max-height: 50%;
      display: block;
      margin: auto;
      position: absolute;
      top: 55%;
      left: 50%;
      transform: translate(-50%, -50%);
      border-radius: 15px;
      border-color: rgb(63, 63, 63);
    }
.search-bar {
  width: 100%;
  padding: 10px;
  box-sizing: border-box;
  margin: 2px;
  font-size: 16px;
}
.first-row{
    width: 100%;
}
.last-row {
    display: grid;
    width: 100%; /* Set a fixed width for the selector */
    grid-template-columns: repeat(auto-fill, minmax(5vw, 1fr)); /* Dynamic columns based on content */
    gap: 10px; /* Consistent space between items */
    height: 100%;
    overflow-y: auto;
    justify-items: stretch; /* Ensure the items fill their grid cells evenly */
}

    .openimageoptions {
      background-color: rgb(66, 66, 66);
      color: black;
      position: absolute;
      display: none;
      right: 0%;
      bottom: 0%;
      width: 40px;
      height: 40px;
      font-size: clamp(10px, 100vw, 40px);
      transform: translate(-50%, -50%);
      font-weight: bold;
      text-align: center;
      user-select: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    .textcontainer {
      background-color: rgb(83, 83, 83);
      position: absolute;
      right: -5%;
      width: 20%;
      height: 50%;
      bottom: -20%;
      transform: translate(-50%, -50%) scale(0);
      transform-origin: bottom right;
      opacity: 0;
      border-radius: 10px;
      transition: transform 0.3s ease, opacity 0.3s ease;
      pointer-events: none;
    }

    .textcontainer.show {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
      pointer-events: auto;
    }

    .texttitle {
      color: white;
      position: absolute;
      font-size: 30px;
      left: 50%;
      width: 100%;
      text-align: center;
      transform: translate(-50%);
      font-weight: bold;
    }

    .textselector {
      position: absolute;
      top: 20%;
      left: 0%;

    }

    .opentextoptions {
      background-color: rgb(66, 66, 66);
      color: black;
      position: absolute;
      display: none;
      right: 0%;
      bottom: 0%;
      width: 40px;
      height: 40px;
      font-size: clamp(10px, 100vw, 40px);
      transform: translate(-50%, -50%);
      font-weight: bold;
      text-align: center;
      user-select: none;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    .texttitle1 {
        position: absolute;
      top: 14%;
      left: 0%;
        color: white;
        font-style: bold;
        font-size:20px;
    }
    .textsize {
        position: absolute;
      top: 40%;
      left: 0%;
      width: 15%;
    }
    .texttitle2 {
        position: absolute;
      top: 35%;
      left: 0%;
        color: white;
        font-style: bold;
        font-size:16px;
    }
   .selectelementtext{
    position:absolute;
    top: 55%;
    left: 0%;
    width: 30%;
   }
   .texttitle3 {
        position: absolute;
      top: 50%;
      left: 0%;
        color: white;
        font-style: bold;
        font-size:16px;
    }
    .linecontainer{
        position:absolute;
        right: 0%;
        bottom: 2%;
        display: none;
         pointer-events: none; /* Disable interaction when hidden */
    }
    .selectelementline{
        width: 30%;
        right: 0px;
         pointer-events: all; /* Disable interaction when hidden */
    }

    </style>
 </head>
 
 
 <body> 
  <div class="blur" id="blur"></div>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
   <div class="menu-container" id="menu-container">
  
  <h1 class="menu-title">SimBox</h1>

  <div class="menu-buttons">
  
    <button id="loadButton">Load Game</button>
    <button id="saveButton"> Save Game</button>
    <button id="catbutton">Catalog</button>
    <a href="mailto:2217696@edtools.psd401.net?subject=Feedback&body=What do you want changed:" class="feedback-button">Feedback</a>
  </div>

  <button class="settings-button" id="settingbuttonopen" onclick="opensettingsmenu();">
    <i class="fa-solid fa-gear"></i>
  </button>
</div>

   
    <div class="catalog" id="catalog">
          <h1>Staggering peaks</h1>
        <h2>V1.5.62</h2>
        <h3>New maps</h3>
        <h4>Terrain with its biomes aka terrain gen</h4>
      
        <p></p>
        
        <p>_____</p>
        <h1><h1>Arts and Shapes?</h1>
        <h2>V1.5.61</h2>
        <h3>New tools</h3>
        <h4>Square, circle, triangle, line and text tools, screen capture, image, media(video) </h4>
      
        <p></p>
        
        <p>_____</p>
        <h1><h1>The Sound Update</h1>
        <h2>V1.5.60</h2>
        <h3>LOTS OF SOUNDS</h3>
        
      
        <p></p>
        
        <p>_____</p>
        <h1><h1>Update Techno</h1>
        <h2>V1.5.59</h2>
        <h3>New elements:</h3>
        <h4>Push Shockwave, Fire shockwave, Portal, lava grenade, tar, snake, midas touch, balloon, drill, paint, paintball, game of life, static, static bomb, pointer, hologram</h4>
      
        <h3>Reworks:</h3>
            <h4>Straw - Now acts like a straw</h4>
            <h3>Bug fixes:</h3>
            <h4>Fish and frog crashing, others i dont remember</h4>
            <h3>Other:</h3>
            <h4>The selection box is now a div</h4>
        
        <p></p>
        
        <p>_____</p>
        <h1>V1.5.58</h1>
        <h2>New elements!</h2>
        <h4>Frog, fish, ant, pistil, snail, coral, pumpkinseed, rat, cockroach(unkillable btw), roach, worm, ghost</h4>
      
        <h2>Bug Fixes!</h2>
        
        <p></p>
        
        <p>_____</p>
        <h1>SIMBOX2.0!!!!</h1>
        <h2>New elements!</h2>
        <h4>Baby oil, Chezburger</h4>
       
      
        
        <p></p>
        
        <p>_____</p>
        <h1>V1.5.57</h1>
        <h2>New elements!</h2>
        <h4>BouncyBall(added acidently in the hotfix), spruce sapling, storm, rain, snow, and cloud clouds added</h4>
        <h2>Misc</h2>
        <h4>Settings!</h4>
        <h2>Bug Fixes!</h2>
        
        <p></p>
        
        <p>_____</p>
        <h1>V1.5.56</h1>
        <h2>New elements!</h2>
        <h4>Napalm, Clusterbomb, Dark Energy, glitch bomb and c4, oxygen, hydrogen, and gasoline</h4>
        <h2>Reworks</h2>
        <h4>Nukes, tornados, slight fire rework</h4>
        <h2>Bug Fixes!</h2>
        
        <p></p>
        
        <p>_____</p>
        <h1>V1.5.55</h1>
        <h2>New Maps!</h2>
        <h4>City, Desert, Wasteland</h4>
        <h2>New elements</h2>
        <h4>radioactive waste, sandstone, coloredvoxel(Dev Exclusive)</h4>
        
        <p></p>
        
        <p>_____</p>
        <h1>V1.5.54</h1>
        <h2>Main menu updates</h2>
        <h4>New load menu where you can load templates</h4>
        <h2>Bug fixes</h2>
        <h4>Fixed liquids going through walls</h4>
        
        <p></p>
        
        <p>_____</p>
        <h1>V1.5.53</h1>
        <h2>New Elements</h2>
        <h4>Wall</h4>
        <h2>Bug fixes</h2>
        <h4>Fixed all liquids going left more than right</h4>
        
        <p></p>
        
        <p>_____</p>
        <h1>V1.5.52</h1>
        <h2>Misc</h2>
        <h4>Selecting!</h4>
        
        <p></p>
        
        <p>_____</p>
        <h1>V1.5.51</h1>
        <h2>Misc</h2>
        <h4>New command prompt!</h4>
        
        <p></p>
        
        <p>_____</p>
        <h1>V1.5.50</h1>
        <h2>New Elements</h2>
        <h4>sonic boom, speaker</h4>
        
        <p></p>
        
        <p>_____</p>
        <h1>V1.5.49</h1>
        <h2>New Elements</h2>
        <h4>snap, snap no mercy</h4>
        <h2>Interactions</h2>
        <h4>boiling water, heating up steel</h4>
        <p></p>
        
        <p>_____</p>
        <h1>V1.5.48</h1>
        <h2>New Elements</h2>
        <h4>PopCorn, Faucet</h4>
        <h2>Other</h2>
        <h4>Bug fixes</h4>
        <p></p>
        
        <p>_____</p>
        <h1>V1.5.47</h1>
        <h2>New Elements</h2>
        <h4>Time Capsule</h4>
        <h2>Other</h2>
        <h4>Huge Optimization changes!</h4>
        <p></p>
        
        <p>_____</p>
        <h1>V1.5.46</h1>
        <h2>New Elements</h2>
        <h4>Grab, Elevate</h4>
        <h2>Other</h2>
        <h4>Bug Fixes!</h4>
        <p></p>
        
        <p>_____</p>
        <h1>V1.5.45</h1>
        <h2>New Elements</h2>
        <h4>Player!</h4>
        
        <p></p>
        
        <p>_____</p>
        <h1>V1.5.44.5</h1>
        <h4>Bug Fixes!</h4>
        <p>_____</p>
        <h1>V1.5.44</h1>
        <h2>New Elements</h2>
        <h4>Cursor</h4>
        <h2>Other</h2>
        <h4>Importing and exporting saves</h4>
        <p></p>
        
        <p>_____</p>
        <h1>V1.5.43</h1>
        <h2>New Elements</h2>
        <h4>Bees, Birds</h4>
        <p></p>
        
        <p>_____</p>
        <h1>V1.5.42</h1>
        <h2>New Elements</h2>
        <h4>Petrol</h4>
        <p></p>
        <h2>UI Updates</h2>
        <h4>Made main menu not show up when starting game</h4>
        <p>_____</p>
        <p></p>
        <h1>V1.5.41</h1>
        <h2>New Elements</h2>
        <h4>Tornado</h4>
        <p></p>
        <h2>UI Updates</h2>
        <h4>New Main Menu</h4>
       </div>
      
   
    
       <div id="commandWindow" class="window" style="display:none;">
        <div class="window-header" id="windowHeader">
            <span>Command Prompt</span>
            <button id="closeButton" onclick="closeWindow()">X</button>
        </div>
        <div id="commandPrompt">
            <pre id="output"></pre>
            <div class="input-container">
                <input type="text" id="commandInput" placeholder="Enter command..." onkeydown="handleKeyDown(event)" />
                <button onclick="executeCommand()">Run</button>
            </div>
        </div>
    </div>
    
    
    
    <div id = 'map' class="mapcontainer">
        <button class = "new" onclick=" newgame(); togglemap(); day();">New</button>
         <button class = "terrain" onclick="initializeGrid(); togglemap(); createTerrain(); useonebiome = false; isPaused = false; day();">normal</button>
        <button class = "mountain" onclick='initializeGrid(); togglemap(); useonebiome = true; biomeused = "mountains"; createTerrain(); isPaused = false; day();'>mountains</button>
        <button class = "plain" onclick='initializeGrid(); togglemap(); useonebiome = true; biomeused = "plains"; createTerrain(); isPaused = false; day();'>plains</button>
        <button class = "ocean" onclick='initializeGrid(); togglemap(); useonebiome = true; biomeused = "ocean"; createTerrain(); isPaused = false; day();'>Ocean</button>
        <button class = "forest" onclick='initializeGrid(); togglemap(); useonebiome = true; biomeused = "forest"; createTerrain(); isPaused = false; day();'>forest</button>
        <button class = "platuea" onclick='initializeGrid(); togglemap(); useonebiome = true; biomeused = "plateua"; createTerrain(); isPaused = false; day();'>plateua</button>
        <button class = "taiga" onclick='initializeGrid(); togglemap(); useonebiome = true; biomeused = "taiga"; createTerrain(); isPaused = false; day();'>taiga</button>


     
    
        </div>
        <div id = 'terrainmap' class="terraincontainer">
        <button class = "terrain" onclick="initializeGrid(); closeterrain(); createTerrain(); useonebiome = false; isPaused = false; day();">normal</button>
        <button class = "mountain" onclick='initializeGrid(); closeterrain(); useonebiome = true; biomeused = "mountains"; createTerrain(); isPaused = false; day();'>mountains</button>
        <button class = "plain" onclick='initializeGrid(); closeterrain(); useonebiome = true; biomeused = "plains"; createTerrain(); isPaused = false; day();'>plains</button>
        <button class = "ocean" onclick='initializeGrid(); closeterrain(); useonebiome = true; biomeused = "ocean"; createTerrain(); isPaused = false; day();'>Ocean</button>
        <button class = "forest" onclick='initializeGrid(); closeterrain(); useonebiome = true; biomeused = "forest"; createTerrain(); isPaused = false; day();'>forest</button>
        <button class = "platuea" onclick='initializeGrid(); closeterrain(); useonebiome = true; biomeused = "plateua"; createTerrain(); isPaused = false; day();'>plateua</button>
        <button class = "taiga" onclick='initializeGrid(); closeterrain(); useonebiome = true; biomeused = "taiga"; createTerrain(); isPaused = false; day();'>taiga</button>






       
      <button class = "close" onclick="closeterrain();">Close</button>
    
        </div>
        <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>

    
        <div id="canvasWrapper" style="position: relative;">
            <canvas id="simulation" width="800" height="600"></canvas>
            <div id="divContainer" style="position: absolute; top: 0; left: 0; display: none;"></div>
        </div>
<button onclick="toggleMaterialSelector();" style="
  position: fixed;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  height: 100px;
  width: 24px;
  font-size: 24px;
  border: none;
  background-color: rgba(255, 255, 255, 0.1);
  color: #333;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  border-radius: 6px 0 0 6px;
  box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.2);
  transition: background-color 0.2s ease;
">
  <span>&gt;</span>
  <span>&gt;</span>
</button>
<button onclick="togglemap();" style="
  position: fixed;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  height: 100px;
  width: 24px;
  font-size: 24px;
  border: none;
  background-color: rgba(255, 255, 255, 0.1);
  color: #333;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  border-radius: 6px 0 0 6px;
  box-shadow: 1px 1px 4px rgba(0, 0, 0, 0.2);
  transition: background-color 0.2s ease;
">
  <span><</span>
  <span><</span>
</button>


<div style="position:fixed;top:10px;left:10px;background:#fff;padding:10px;z-index:999;border:1px solid #000; ">
  <div>Your Peer ID: <span style="user-select: all;" id="my-id">Loading...</span></div>
  <input id="peer-id" placeholder="Enter friend’s ID">
  <button onclick="connectToPeer()">Connect</button>
</div>

    <div class="material-selector" id ="material-selector">
       
      <div class="first-row">
    <input 
      type="text" 
      id="searchBar" 
      placeholder="Search materials..." 
      oninput="filterMaterials()" 
      class="search-bar"
    >
  </div>
  <div class ="last-row">
        <button style="background-color: rgba(0, 0, 255, 0.544);" class="material-button" onclick="selectedElement = 'water';">Water</button>
        <button style="background-color: #A47449;" class="material-button" onclick="selectedElement = 'wood';">Wood</button>
        <button style="background-color: #ff7700;" class="material-button"  onclick="selectedElement = 'lava';">Lava</button>
        <button style="background-color: yellow;" class="material-button" onclick="selectedElement = 'sand';">Sand</button>
        <button style="background-color: gray;" class="material-button" onclick="selectedElement = 'stone';">Stone</button>
        <button style="background-color: #423223;" class="material-button" onclick="selectedElement = 'mud';">Mud</button>
        <button style="background-color: green;" class="material-button" onclick="selectedElement = 'grass';">Grass</button>
        <button style="background-color: lightblue;" class="material-button" onclick="selectedElement = 'ice';">Ice</button>
        <button style="background-color: #f56a00;" class="material-button" onclick="selectedElement = 'fire';">Fire</button>
        <button style="background-color: white;" class="material-button" onclick="selectedElement = 'snow';">Snow</button>
        <button style="background-color: black; color: white;" class="material-button" onclick="selectedElement = 'oil';">Oil</button>
        <button style="background-color: lightyellow;" class="material-button" onclick="selectedElement = 'sugar';">Sugar</button>
        <button style="background-color: #8B0000;" class="material-button" onclick="selectedElement = 'magma';">Magma</button>
        <button style="background-color: lightgray;" class="material-button" onclick="selectedElement = 'steam';">Steam</button>
        <button style="background-color: #57422E;" class="material-button" onclick="selectedElement = 'dirt';">Dirt</button>
        <button style="background-color: rgba(135, 206, 250, 0.5);" class="material-button" onclick="selectedElement = 'glass';">Glass</button>
        <button style="background-color: #3C2F2F; color: white;" class="material-button" onclick="selectedElement = 'obsidian';">Obsidian</button>
        <button style="background-color: #6b0458;" class="material-button" onclick="selectedElement = 'virus';">Virus</button>
        <button style="background-color: rgba(104, 104, 104, 0.933);" class="material-button" onclick="selectedElement = 'concrete';">Cement</button>
        <button style="background-color: red;" class="material-button" onclick="selectedElement = 'tnt';">Tnt</button>
        <button style="background-color: green;" class="material-button"  id="uraniumButton" onclick="selectedElement = 'uranium';">Uranium</button>
        <button style="background-color: #AC9E91" class="material-button" onclick="selectedElement = 'syrup';">Syrup</button>
        <button style="background-color: #323232" class="material-button" onclick="selectedElement = 'smokeBomb';">Smokebomb</button>
        <button style="background-color: #26C53B" class="material-button" onclick="selectedElement = 'Leaf';">Leaves</button>
        <button style="background-color: #025A01" class="material-button" onclick="selectedElement = 'grenade';">Grenade</button>
        <button style="background-color: pink" class="material-button" onclick="selectedElement = 'crystal';">Crystal</button>
        <button style="background-color: rgb(78, 78, 78); color: white;" class="material-button" onclick="selectedElement = 'basalt';">Basalt</button>
        <button style="background-color: orange" class="material-button" id="glitchButton"  onclick="selectedElement = 'glitch';">Glitch</button>
        <button style="background-color: white"  class="material-button" id="randomButton"  onclick="selectedElement = 'random';">dN0Ram</button>
        <button style="background-color: gray" class="material-button" onclick="selectedElement = 'fly';">Fly</button>
        <button style="background-color: #9E9D90" class="material-button" onclick="selectedElement = 'ash';">Ash</button>
        <button style="background-color: #D5CF8D" class="material-button" onclick="selectedElement = 'human';">Human</button> 
        <button style="background-color: black; color: white;" class="material-button" onclick="selectedElement = 'blackhole';">BlackHole</button>
        <button style="background-color: #8DD5BF" class="material-button" onclick="selectedElement = 'liquidN';">liquidNitrogen</button> 
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'milk';">Milk</button> 
        <button style="background-color: #A4A4A4" class="material-button" onclick="selectedElement = 'steel';">Steel</button>
        <button style="background-color: #D5FB00" class="material-button" onclick="selectedElement = 'sponge';">Sponge</button> 
        <button style="background-color: #C100FF" class="material-button" onclick="selectedElement = 'cloner';">Cloner</button> 
        <button style="background-color: #F7CEFE" class="material-button" onclick="selectedElement = 'salt';">Salt</button> 
        <button style="background-color: #FAB2F5" class="material-button" onclick="selectedElement = 'quartz';">Quartz</button> 
        <button style="background-color: rgba(255, 255, 255, 0.5)" class="material-button" onclick="selectedElement = 'fog';">Fog</button> 
        <button style="background-color: #CDCC9F" class="material-button" onclick="selectedElement = 'bone';">Bone</button>
        <button style="background-color: #7EB534" class="material-button" onclick="selectedElement = 'moss';">Moss</button>
        <button style="background-color: #FF8300" class="material-button" onclick="selectedElement = 'copper';">Copper</button>
        <button style="background-color: #8C8C8C" class="material-button" onclick="selectedElement = 'mercury';">Mercury</button>
        <button style="background-color: green" class="material-button" onclick="selectedElement = 'cactus';">Cactus</button>
        <button style="background-color: #80FF54" class="material-button" onclick="selectedElement = 'acid';">Acid</button>
        <button style="background-color: #474747" class="material-button" onclick="selectedElement = 'gunpowder';">Gunpowder</button>
        <button style="background-color: #FF8700" class="material-button" onclick="selectedElement = 'nitro';">Nitroglycerin</button>
        <button style="background-color: #EAEC42" class="material-button" onclick="selectedElement = 'sawdust';">Sawdust</button>
        <button style="background-color: #97522F" class="material-button" onclick="selectedElement = 'rust';">Rust</button>
        <button style="background-color: #F1EA08" class="material-button" onclick="selectedElement = 'pollen';">Pollen</button>
        <button style="background-color: #C100FF" class="material-button" onclick="selectedElement = 'solidcloner';">Solid Cloner</button> 
        <button style="background-color: #3C3C35; color: white;" class="material-button" onclick="selectedElement = 'coal';">Coal</button>
        <button style="background-color: #ADBFE7" class="material-button" onclick="selectedElement = 'plastic';">Plastic</button> 
        <button style="background-color: #EEE637" class="material-button" onclick="selectedElement = 'lasersource';">laser</button>
        <button style="background-color: #4FC8BE" class="material-button" onclick="selectedElement = 'diamond';">Diamond</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'flashbang';">Flashbang</button>
        <button style="background-color: #595552; color: white;" class="material-button" onclick="selectedElement = 'gallium';">Gallium</button> 
        <button style="background-color: #D12A2A; color: white;" class="material-button" onclick="selectedElement = 'brick';">Brick</button>
        <button style="background-color: #272727; color: white;" class="material-button" onclick="selectedElement = 'charcoal';">Charcoal</button>
        <button style="background-color: #ADADAD" class="material-button" onclick="selectedElement = 'clay';">Clay</button>
        <button style="background-color: #FF7DEF" class="material-button" onclick="selectedElement = 'pig';">Pig</button>
        <button style="background-color: #165900; color: white;" class="material-button" onclick="selectedElement = 'nuke';">Nuke</button>
        <button style="background-color: #BFBFBF" class="material-button" onclick="selectedElement = 'aluminum';">Aluminum</button>
        <button style="background-color: #AFAFAF" class="material-button" onclick="selectedElement = 'gravel';">Gravel</button>
        <button style="background-color: black; color: white;" class="material-button" onclick="selectedElement = 'antimatter';">Antimatter</button>
        <button style="background-color: #FF00E4; color: white;" class="material-button" onclick="selectedElement = 'plasma';">Plasma</button>
        <button style="background-color: #DDF242; color: red" class="material-button" onclick="selectedElement = 'supernova';">Supernova</button>
        <button style="background-color: #3AAA33" class="material-button" onclick="selectedElement = 'vine';">Vine</button>
        <button style="background-color: #F1FE75" class="material-button" onclick="selectedElement = 'star';">Star</button>
        <button style="background-color: #444444; color: red" class="material-button" onclick="selectedElement = 'missilehead';">Missile</button>
        <button style="background-color: lightgray" class="material-button" onclick="selectedElement = 'wind';">Wind</button>
        <button style="background-color: #20A100" class="material-button" onclick="selectedElement = 'molotov';">Molotov</button>
        <button style="background-color: #292929; color: white;" class="material-button" onclick="selectedElement = 'bomb';">Bomb</button>
        <button style="background-color: #3A416C; color: white;" class="material-button" onclick="selectedElement = 'wire';">Wire</button>
        <button style="background-color: #883D26; color: white;" class="material-button" onclick="selectedElement = 'battery';">Battery</button>
        <button style="background-color: #834848" class="material-button" onclick="selectedElement = 'redlightoff';">Red light</button>
        <button style="background-color: #FCFF1C" class="material-button" onclick="selectedElement = 'shock';">Shock</button>
        <button style="background-color: #607689" class="material-button" onclick="selectedElement = 'emp';">Emp</button>
        <button style="background-color: #607689" class="material-button" onclick="selectedElement = 'empgrenade';">Emp Grenade</button>
        <button style="background-color: #D1C263" class="material-button" onclick="selectedElement = 'gold';">Gold</button>
        <button style="background-color: #878681; color: white;" class="material-button" onclick="selectedElement = 'titanium';">Titanium</button>
        <button style="background-color: #C0C0C0" class="material-button" onclick="selectedElement = 'silver';">Silver</button>
        <button style="background-color: #393939; color: white;" class="material-button" onclick="selectedElement = 'lead';">Lead</button>
        <button style="background-color: #D6F593" class="material-button" onclick="selectedElement = 'chlorine';">Chlorine</button>
        <button style="background-color: #919191" class="material-button" onclick="selectedElement = 'tin';">Tin</button>
        <button style="background-color: #1D1605; color: orange;" class="material-button" onclick="selectedElement = 'bromine';">Bromine</button>
        <button style="background-color: #C5C2C0" class="material-button" onclick="selectedElement = 'platinum';">Platinum</button>
        <button style="background-color: #AEB4B7" class="material-button" onclick="selectedElement = 'zinc';">Zinc</button>
        <button style="background-color: #B1C0BD" class="material-button" onclick="selectedElement = 'magnesium';">Magnesium</button>
        <button style="background-color: #303030; color: red" class="material-button" onclick="selectedElement = 'mine';">Mine</button>
        <button style="background-color: #9B5D1B" class="material-button" onclick="selectedElement = 'bronze';">Bronze</button>
        <button style="background-color: #C4BA9A" class="material-button" onclick="selectedElement = 'nickel';">Nickel</button>
        <button style="background-color: #1B1A19; color: white;" class="material-button" onclick="selectedElement = 'ink';">Ink</button>
        <button style="background-color: #DC2020" class="material-button" onclick="selectedElement = 'ketchup';">Ketchup</button>
        <button style="background-color: #E48117" class="material-button" onclick="selectedElement = 'caramel';">Caramel</button>
        <button style="background-color: #CDA572" class="material-button" onclick="selectedElement = 'tuff';">Tuff</button>
        <button style="background-color: #CFB697" class="material-button" onclick="selectedElement = 'limestone';">Limestone</button>
        <button style="background-color: red" class="material-button" onclick="selectedElement = 'firework';">Firework</button>
        <button style="background-color: #EED956" class="material-button" onclick="selectedElement = 'vegetableoil';">Vegetable Oil</button>
        <button style="background-color: #525252; color: white;" class="material-button" onclick="selectedElement = 'bullet';">Bullet</button>
        <button style="background-color: #F5EF73" class="material-button" onclick="selectedElement = 'cheese';">Cheese</button>
        <button style="background-color: #E4B572" class="material-button" onclick="selectedElement = 'hay';">Haybale</button>
        <button style="background-color: #BFBDBA" class="material-button" onclick="selectedElement = 'cloth';">Cloth</button>
        <button style="background-color: #CACACA" class="material-button" onclick="selectedElement = 'paper';">Paper</button>
        <button style="background-color: #FDFDFD;  color: blue;" class="material-button" onclick="selectedElement = 'dryice';">Dry Ice</button>
        <button style="background-color: #C0A672" class="material-button" onclick="selectedElement = 'straw';">Straw</button>
        <button style="background-color: #5AFFB9" class="material-button" onclick="selectedElement = 'tractorbeams';">Tractorbeam</button>
        <button style="background-color: #CACACA" class="material-button" onclick="selectedElement = 'bleach';">Bleach</button>
        <button style="background-color: #FF3B00" class="material-button" onclick="selectedElement = 'teslacoil';">Teslacoil</button>
        <button style="background-color: #E8EEA6" class="material-button" onclick="selectedElement = 'vinegar';">Vinegar</button>
        <button style="background-color: #9CCAE5" class="material-button" onclick="selectedElement = 'bubble';">Bubble</button>
        <button style="background-color: #FDFFE4" class="material-button" onclick="selectedElement = 'soap';">Soap</button>
        <button style="background-color: #FF0000" class="material-button" onclick="selectedElement = 'hm';">Homing missile</button>
        <button style="background-color: #61E5FF" class="material-button" onclick="selectedElement = 'freezerays';">Freeze Ray</button>
        <button style="background-color: #393939; color: white;" class="material-button" onclick="selectedElement = 'cb';">Conveyor Belt</button>
        <button style="background-color: #84E84B" class="material-button" onclick="selectedElement = 'radiation';">Radiation</button>
        <button style="background-color: #F09221" class="material-button" onclick="selectedElement = 'honey';">Honey</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'static';">Static</button>
        <button style="background-color: #EC9936" class="material-button" onclick="selectedElement = 'sap';">Sap</button>
        <button style="background-color: #393939; color: yellow;" class="material-button" onclick="selectedElement = 'firefly';">Firefly</button>
        <button style="background-color: #EEEEEE" class="material-button" onclick="selectedElement = 'foam';">Foam</button>
        <button style="background-color: #F0E600" class="material-button" onclick="selectedElement = 'sulfur';">Sulfur</button>
        <button style="background-color: #E0DFBB" class="material-button" onclick="selectedElement = 'sa';">Sulfuric Acid</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'feather';">Feather</button>
        <button style="background-color: black;  color: #00E0FF;" class="material-button" onclick="selectedElement = 'border';">Border</button>
        <button style="background-color: #F56CE5" class="material-button" onclick="selectedElement = 'c4';">C4</button>
        <button style="background-color: lightblue;  color: red;" class="material-button" onclick="selectedElement = 'cf';">Confetti</button>
        <button style="background-color: #FF00EC" class="material-button" onclick="selectedElement = 'partypopper';">Party Popper</button>
        <button style="background-color: #DDDDDD" class="material-button" onclick="selectedElement = 'glue';">Glue</button>
        <button style="background-color: #3D2808; color: white;" class="material-button" onclick="selectedElement = 'soda';">Soda</button>
        <button style="background-color: #D5D5D5" class="material-button" onclick="selectedElement = 'mentos';">Mentos</button>
        <button style="background-color: #FBBE0D" class="material-button" onclick="selectedElement = 'juice';">Juice</button>
        <button style="background-color: #FFF3D2" class="material-button" onclick="selectedElement = 'wax';">Wax</button>
        <button style="background-color: #545454; color: white;" class="material-button" onclick="selectedElement = 'sodium';">Sodium</button>
        <button style="background-color: #6F8929" class="material-button" onclick="selectedElement = 'flowerseed';">Flower Seed</button>
        <button style="background-color: lightgreen" class="material-button" onclick="selectedElement = 'fp';">Flower Petal</button>
        <button style="background-color: #D7D0A7" class="material-button" onclick="selectedElement = 'mushroomseed';">Mushroom Seed</button>
        <button style="background-color: #806641" class="material-button" onclick="selectedElement = 'tinder';">Tinder</button>
        <button style="background-color: #59EA11" class="material-button" onclick="selectedElement = 'bamboo';">Bamboo</button>
        <button style="background-color: #818383" class="material-button" onclick="selectedElement = 'gs';">Galvanized steel</button>
        <button style="background-color: rgba(0, 0, 255, 0.544);" class="material-button" onclick="selectedElement = 'tsunami';">Tsunami</button>
        <button style="background-color: #6F6143" class="material-button" onclick="selectedElement = 'earthquake';">Earthquake</button>
        <button style="background-color: #4A4A4A; color: white;" class="material-button" onclick="selectedElement = 'fuse';">Fuse</button>
        <button style="background-color: #FF3A00" class="material-button" onclick="selectedElement = 'lasercannon';">Laser Cannon</button>
        <button style="background-color: #7C7B7B" class="material-button" onclick="selectedElement = 'nanobug';">Nanobug</button>
        <button style="background-color: #BFBFBF" class="material-button" onclick="selectedElement = 'web';">Web</button>
        <button style="background-color: #4B2E1A; color: white;" class="material-button" onclick="selectedElement = 'flea';">Flea</button>
        <button style="background-color: #77B823" class="material-button" onclick="selectedElement = 'sappling';">Sappling</button>
        <button style="background-color: #A46965" class="material-button" onclick="selectedElement = 'granite';">Granite</button>
        <button style="background-color: #494949; color: white;" class="material-button" onclick="selectedElement = 'antimatterbomb';">Antibomb</button>
        <button style="background-color: #DBDBDB" class="material-button" onclick="selectedElement = 'diorite';">Diorite</button>
        <button style="background-color: #4D4D4D; color: #FC6A05;" class="material-button" onclick="selectedElement = 'fireball';">Fireball</button>
        <button style="background-color: #BCF8E9" class="material-button" onclick="selectedElement = 'hail';">Hail</button>
        <button style="background-color: #2C9530" class="material-button" onclick="selectedElement = 'zombie';">Zombie</button>
        <button style="background-color: #FCF97B" class="material-button" onclick="selectedElement = 'lightning';">Lightning</button>
        <button style="background-color: lightgray" class="material-button" onclick="selectedElement = 'tornado';">Tornado</button>
        <button style="background-color: #284659; color: white;" class="material-button" onclick="selectedElement = 'petrol';">Petrol</button>
        <button style="background-color: #D9C531" class="material-button" onclick="selectedElement = 'bee';">Bee</button>
        <button style="background-color: #878157" class="material-button" onclick="selectedElement = 'bird';">Bird</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'cursor';">Cursor</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'grab';">Grab</button> 
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'elevate';">Elevate</button> 
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'push';">Push</button>
        <button style="background-color: #5D5D5D" class="material-button" onclick="selectedElement = 'timecapsule';">Time Capsule</button>
        <button style="background-color: #6F9383" class="material-button" onclick="selectedElement = 'faucet';">Faucet</button>
        <button style="background-color: #F1EDAB" class="material-button" onclick="selectedElement = 'popcorn';">Popcorn</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'snap';">Snap</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'snapnm';">Snap No Mercy</button>
        <button style="background-color: #FCF341" class="material-button" onclick="selectedElement = 'corn';">Corn</button>
        <button style="background-color: black; color: white;" class="material-button" onclick="selectedElement = 'speaker';">Speaker</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'sonicboom';">Sonic Boom</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'select';">Select</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'move';">Move</button>
        <button style="background-color: #757575" class="material-button" onclick="selectedElement = 'wall';">Wall</button>
        <button style="background-color: white; display: none;" class="material-button" id = "coloredvoxel" onclick="selectedElement = 'coloredvoxel';">ColoredVoxel</button>
        <button style="background-color: #A69B77" class="material-button" onclick="selectedElement = 'sandstone';">Sandstone</button>
        <button style="background-color: #33F209" class="material-button" onclick="selectedElement = 'rwaste';">Radioactive waste</button>
        <button style="background-color: #FFA209" class="material-button" onclick="selectedElement = 'nabomb';">Napalm</button>
        <button style="background-color: #323232; color: white;" class="material-button" onclick="selectedElement = 'clusterbomb';">Cluster Bomb</button>
        <button style="background-color: #4E2C63; color: white;" class="material-button" onclick="selectedElement = 'darkenergy';">Dark Energy</button>
        <button style="background-color: #291A32; color: white;" class="material-button" onclick="selectedElement = 'glitchbomb';">Glitch Bomb</button>
        <button style="background-color: #291A32; color: white;" class="material-button" onclick="selectedElement = 'glitchc4';">Glitch C4</button>
        <button style="background-color: #A4DDED" class="material-button" onclick="selectedElement = 'oxygen';">Oxygen</button>
        <button style="background-color: #E8F6FA" class="material-button" onclick="selectedElement = 'hydrogen';">Hydrogen</button>
        <button style="background-color: #EFD652" class="material-button" onclick="selectedElement = 'gasoline';">Gasoline</button>
        <button style="background-color: red" class="material-button" onclick="selectedElement = 'bouncyball';">Bouncy Ball</button>
        <button style="background-color: #315D2E" class="material-button" onclick="selectedElement = 'sprucesapling';">Spruce Sapling</button>
        <button style="background-color: #585967" class="material-button" onclick="selectedElement = 'stormcloud';">Stormcloud</button>
        <button style="background-color: #909090" class="material-button" onclick="selectedElement = 'raincloud';">Raincloud</button>
        <button style="background-color: #DCDCDC" class="material-button" onclick="selectedElement = 'cloud';">Cloud</button>
        <button style="background-color: #B3B3B3" class="material-button" onclick="selectedElement = 'snowcloud';">Snowcloud</button>
        <button style="background-color: #91E57F" class="material-button" onclick="selectedElement = 'frog';">Frog</button>
        <button style="background-color: #CD1C1C" class="material-button" onclick="selectedElement = 'fish';">Fish</button>
        <button style="background-color: #85170E" class="material-button" onclick="selectedElement = 'ant';">Ant</button>
        <button style="background-color: #7BCB44" class="material-button" onclick="selectedElement = 'pistil';">Pistil</button>
        <button style="background-color: #3E241F; color: white;" class="material-button" onclick="selectedElement = 'snail';">snail</button>
        <button style="background-color: pink" class="material-button" onclick="selectedElement = 'coral';">Coral</button>
        <button style="background-color: #B0C72F" class="material-button" onclick="selectedElement = 'pumpkinseed';">Pumpkinseed</button>
        <button style="background-color: #8A8A8A" class="material-button" onclick="selectedElement = 'rat';">Rat</button>
        <button style="background-color: #643A17" class="material-button" onclick="selectedElement = 'cockroach';">Cockroach</button>
        <button style="background-color: #643A17" class="material-button" onclick="selectedElement = 'cockroach2';">Roach</button>
        <button style="background-color: #732411" class="material-button" onclick="selectedElement = 'wormhead';">Worm</button>
        <button style="background-color: #929293" class="material-button" onclick="selectedElement = 'ghost';">Ghost</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'shockwave';">Push shockwave</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'fireshockwave';">Fire shockwave</button>
        <button style="background-color: #0096FE" class="material-button" onclick="selectedElement = 'teleport';">Portal</button>
        <button style="background-color: #95411F" class="material-button" onclick="selectedElement = 'lavabomb';">Lava Grenade</button>
        <button style="background-color: #39322F; color: white;" class="material-button" onclick="selectedElement = 'tar';">Tar</button>
        <button style="background-color: #299411" class="material-button" onclick="selectedElement = 'snakegame';">Snake</button>
        <button style="background-color: gold" class="material-button" onclick="selectedElement = 'midas_touch';">Midas Touch</button>
        <button style="background-color: red" class="material-button" onclick="selectedElement = 'balloon';">Balloon</button>
        <button style="background-color: #645A53" class="material-button" onclick="selectedElement = 'drill';">Drill</button>
        <button id="color" class="material-button" onclick="selectedElement = 'paint';">Paint</button>
        <button  id="color2" class="material-button"  onclick="selectedElement = 'paintball';">PaintBall</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'gameoflife';">Game Of life</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'static';">Static</button>
        <button style="background-color: black; color: white;" class="material-button" onclick="selectedElement = 'staticbomb';">Static Bomb</button>
        <button  id="color3" class="material-button"  onclick="selectedElement = 'pointer';">Pointer</button>
        <button style="background-color: #14BBCF" class="material-button" onclick="selectedElement = 'hologram';">Hologram</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'image'; ">Image</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'text';">Text</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'media';">Media</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'line';">Line</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'square';">Square</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'circle';">circle</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'triangle';">Triangle</button>
        <button style="background-color: white" class="material-button" onclick="selectedElement = 'screen';">Screen capture</button>
        <button style="background-color: #525252" class="material-button" onclick="selectedElement = 'bedrock';">Bedrock</button>
        <button style="background-color: #428A19" class="material-button" onclick="selectedElement = 'bushe';">Bush</button>
        <button style="background-color: green" class="material-button" onclick="selectedElement = 'cactusexplosion';">Cactus plant</button>
        <button style="background-color: #656565" class="material-button" onclick="selectedElement = 'rocke';">Rock</button>























     



        



       
        

        





       


         

        
        <button  class="material-button" onclick="selectedElement = 'empty';">Eraser</button>
        <p>Brush size: <input type="range" id="brushSize"min="1"max="30" value="1"></p>
        <button id="pauseButton"></button> 
  </div>
    </div>
    

    <div class="linecontainer" id="linecontainer">
        <h3>Element <input id="elementline" class= "selectelementline" type = "text" value="stone" placeholder="Element Name"/></h3>
        <h3>Element 2 <input id="elementline2" class= "selectelementline" type = "text"  placeholder="2nd element name"/></h3>

       
    </div>
    <input type="color" id="colorPicker" value="#ff0000" style="position: absolute; bottom: 10px; right: 10px; display: none;">

  
    <div id="hoverInfo" style="position: absolute; bottom: 10px; left: 10px; color: white; font-size: 16px;"></div>
    
    <div id="loadMenu" class="load-menu" style="display: none;">
        <h2>Load Game</h2>
        <div id="saveList"></div>
        <button onclick="closeLoadMenu()">Close</button>
    </div>
 
 <div class="savePopUp" id="savePopUp" style="display: none;">Saving...</div>
   
 <div class = "settingcontainer" id ="settingcontainer">
    <button class = "closebutton" onclick="opensettingsmenu();">close</button>
      <div class = "settingtext" >Settings</div>
    
      <button class="settingbutton"  id="soundbutton" onclick="opensoundsettings();">Sound</button>
       <button class="settingbutton" id="gridbutton" onclick="opengridsettings();">Grid</button>
       <button class="settingbutton" id="controlsbutton" onclick="opencontrolsettings();">Controls</button>
       <button class="settingbutton" id="themebutton" onclick="openthemesettings();">Theme</button>

      
  </div>
  

  <div id="imagecontainer" class="imagecontainer">
    <div class="imagetitle">Image Settings</div>
    <input class="imageselector" type="file" id="imageUpload" accept="image/*" />
    <img id="dynamicImage" width="300">
    <div style="position: absolute; bottom: 10px; left: 10px; color: white;">
        <label for="scaleSlider">Scale:</label>
        <input type="range" id="scaleSlider" min="0.01" max="1" step="0.01" value="0.05">
        <span id="imagescale"></span>
        <label><input type="checkbox" id="colorToggle"> Use Colored Voxel</label>
        <label><input type="file" id="mediaInput" accept="video/*">Gif or video</label>
        <button id="screencapture" style='display: none;'onclick="captureNewScreen()">Start Screen Capture</button>

      </div>
      
  </div>
  

  <script src="https://unpkg.com/gifuct-js/dist/gifuct.min.js"></script>

  <div id="textcontainer" class="textcontainer">
    <div class="texttitle">Text Settings</div>
    <div class="texttitle1">Text</div>
    <input class="textselector" id="textselection" type="text" placeholder="type your text..." />
    <div class="texttitle2">Size</div>
    <div class="texttitle3">Element</div>
    
    <input class="textsize" id="textsize" value="1" type="number"/>
    <input class="selectelementtext" id="elementtext" type="text" value="stone" placeholder="element name"/>

     
      

   
      
  </div>
  
  <button class="openimageoptions" id="imagebutton" onclick="imageselection();"><</button>
  <button class="opentextoptions" id="textbutton" onclick="textselection();"><</button>

  <div class="soundcontainer" id="soundcontainer">
    <button class="backbutton" onclick="opensoundsettings();">Back</button>
    <div class="settingtext">Sound</div>
  
    <div class="slider-container">
      <label for="musicVolume">Music Volume</label>
      <input type="range" id="musicVolume" min="0" max="1" step="0.01" value="0.5">
      <span id="musicPercent">50%</span>
    </div>
  
    <div class="slider-container">
      <label for="sfxVolume">SFX Volume</label>
      <input type="range" id="sfxVolume" min="0" max="1" step="0.01" value="0.5">
      <span id="sfxPercent">50%</span>
    </div>
    <div class="slider-container">
        <label for="uiVolume">UI Volume</label>
        <input type="range" id="uiVolume" min="0" max="1" step="0.01" value="0.5">
        <span id="uiPercent">50%</span>
      </div>
  
    
  </div>
  <script src="https://cdn.jsdelivr.net/npm/gifuct-js/dist/gifuct.min.js"></script>

 

  <audio id="music" 
       style="display: none; position: absolute; left: 0; top: 0;" 
       loop 
       muted>
</audio>
  
  <audio id='sfx'  preload="auto"></audio>
  <audio id='ui' preload="auto"></audio>
 <audio id = 'musicfeedback' src="https://github.com/Guttobear/soundssimbox/blob/main/slider.mp3?raw=true"></audio>
 <audio id = 'uifeedback' src="https://github.com/Guttobear/soundssimbox/blob/main/slider.mp3?raw=true"></audio>
 <audio id = 'sfxfeedback' src="https://github.com/Guttobear/soundssimbox/blob/main/slider.mp3?raw=true"></audio>
  <div class="themecontainer" id="themecontainer">
    <button class = "backbutton" onclick="openthemesettings();">Back</button>
    <div class = "settingtext">Theme</div>
    <select class="themetoggle" id="themetoggle" onchange="themetoggle()">
        <option value="normal">Normal</option>
        <option value="night">Night</option>
        <option value="dreamspace">Dreamspace</option>
    </select>
    
  </div>
  <div class="gridcontainer" id="gridcontainer">
    <div class = "settingtext">Grid</div>
    
    <button class = "backbutton" onclick="opengridsettings();">Back</button>
    <button class="nowallstoggle" id="nowallstoggle" onclick="nowalls2();">Walls: on</button>
    <div class = "voxelsize">voxelSize: <input type="text" id="voxelsize" min="1"></div>
    
  </div>
  <div class="controlscontainer" id="controlscontainer">
    <div class = "settingtext">Controls</div>
    <button class = "backbutton" onclick="opencontrolsettings();">Back</button>
    <div class="hotkeys">
      <h1>Hotkeys:</h1>
      <h2>Main Menu: ESC</h2>
      <h2>Pause: SPACE</h2>
      <h2>Command prompt: BACKLASH (`)</h2>
      <h2>Brushsize: SCROLL</h2>

    </div>
  </div>
    <script>
 const dreamspacemusic = [
    "https://github.com/Guttobear/soundssimbox/blob/main/Dreamspace1.mp3?raw=true",
    "https://github.com/Guttobear/soundssimbox/blob/main/Dreamspace2.mp3?raw=true"
  ];
  const nightmusic = [
    "https://github.com/Guttobear/soundssimbox/blob/main/night1.mp3?raw=true",
    "https://github.com/Guttobear/soundssimbox/blob/main/night2.mp3?raw=true"
  ];
 


  function getLuminance(r, g, b) {
  const a = [r, g, b].map((v) => {
    v /= 255;
    return v <= 0.03928
      ? v / 12.92
      : Math.pow((v + 0.055) / 1.055, 2.4);
  });
  return 0.2126 * a[0] + 0.7152 * a[1] + 0.0722 * a[2];
}
function fitText(button, minFontSize = 10) {
  const originalFontSize = parseFloat(getComputedStyle(button).fontSize);
  let fontSize = originalFontSize;

  button.style.fontSize = fontSize + "px";

  while (button.scrollWidth > button.clientWidth && fontSize > minFontSize) {
    fontSize -= 1;
    button.style.fontSize = fontSize + "px";
  }
}

// Apply to all .material-button elements
document.querySelectorAll('.material-button').forEach(button => {
  fitText(button);
});

function updateTextColorBasedOnBackground(button) {
  const bg = getComputedStyle(button).backgroundColor;
  const rgb = bg.match(/\d+/g).map(Number);
  const luminance = getLuminance(rgb[0], rgb[1], rgb[2]);
  button.style.color = luminance > 0.5 ? '#000' : '#fff';
}

// Run for all material buttons
document.querySelectorAll('.material-button').forEach(updateTextColorBasedOnBackground);

let soundsettings = false;
      let gridsettings = false;
      let controlsettings = false;
      let themesettings = false;
      let settings = false;
// Assume you have audio elements or objects like this:
const music = document.getElementById('music'); // <audio id="music" ...>
   const selector = document.querySelector('.material-selector');
  const map = document.querySelector('.mapcontainer');

    function toggleMaterialSelector() {
        selector.classList.toggle('expand');
    }
      function togglemap() {
        map.classList.toggle('expand');
    }
    const ui = document.getElementById('ui'); 
  
    const sfxsounds = [
  { id: 1, name: "click2", src: "https://github.com/Guttobear/soundssimbox/blob/main/click2.mp3?raw=true" },
  { id: 2, name: "lava1", src: "https://github.com/Guttobear/soundssimbox/blob/main/lava1.mp3?raw=true" },
  { id: 3, name: "stoneplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/stoneplace2.mp3?raw=true" },
  { id: 4, name: "woodplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/woodplace2.mp3?raw=true" },
  { id: 5, name: "explosion1", src: "https://github.com/Guttobear/soundssimbox/blob/main/explosion1.mp3?raw=true" },
  { id: 6, name: "explosion2", src: "https://github.com/Guttobear/soundssimbox/blob/main/explosion2.mp3?raw=true" },
  { id: 7, name: "grassplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/grassplace1.mp3?raw=true" },
  { id: 8, name: "flashbang1", src: "https://github.com/Guttobear/soundssimbox/blob/main/flashbang1.mp3?raw=true" },
  { id: 9, name: "lightning1", src: "https://github.com/Guttobear/soundssimbox/blob/main/lightning1.mp3?raw=true" },
  { id: 10, name: "lightning2", src: "https://github.com/Guttobear/soundssimbox/blob/main/lightning2.mp3?raw=true" },
  { id: 11, name: "fire1", src: "https://github.com/Guttobear/soundssimbox/blob/main/fire2.mp3?raw=true" },
  { id: 12, name: "fire2", src: "https://github.com/Guttobear/soundssimbox/blob/main/fire1.mp3?raw=true" },
  { id: 13, name: "waterplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/waterplace1.mp3?raw=true" },
  { id: 14, name: "water1", src: "https://github.com/Guttobear/soundssimbox/blob/main/water1.mp3?raw=true" },
  { id: 15, name: "lavaplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/lavaplace1.mp3?raw=true" },
  { id: 16, name: "sandplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/sandplace1.mp3?raw=true" },
  { id: 17, name: "mudplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/mudplace1.mp3?raw=true" },
  { id: 18, name: "iceplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/iceplace1.mp3?raw=true" },
  { id: 19, name: "snowplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/snowplace1.mp3?raw=true" },
  { id: 20, name: "sugarplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/sugarplace1.mp3?raw=true" },
  { id: 21, name: "steamplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/steamplace1.mp3?raw=true" },
  { id: 22, name: "glassplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/glassplace1.mp3?raw=true" },
  { id: 23, name: "virusplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/virusplace1.mp3?raw=true" },
  { id: 24, name: "leafplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/leafplace1.mp3?raw=true" },
  { id: 25, name: "crystalplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/crystalplace1.mp3?raw=true" },
  { id: 26, name: "glitchplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/glitchplace1.mp3?raw=true" },
  { id: 27, name: "glitch1", src: "https://github.com/Guttobear/soundssimbox/blob/main/glitch1.mp3?raw=true" },
  { id: 28, name: "glitch2", src: "https://github.com/Guttobear/soundssimbox/blob/main/glitch2.mp3?raw=true" },
  { id: 29, name: "glitch3", src: "https://github.com/Guttobear/soundssimbox/blob/main/glitch3.mp3?raw=true" },
  { id: 30, name: "nuke1", src: "https://github.com/Guttobear/soundssimbox/blob/main/nuke1.mp3?raw=true" },
  { id: 31, name: "fly1", src: "https://github.com/Guttobear/soundssimbox/blob/main/fly1.mp3?raw=true" },
  { id: 32, name: "flyplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/flyplace1.mp3?raw=true" },
  { id: 33, name: "steelplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/steelplace1.mp3?raw=true" },
  { id: 34, name: "spongeplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/spongeplace1.mp3?raw=true" },
  { id: 35, name: "blackholeplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/blackholeplace1.mp3?raw=true" },
  { id: 36, name: "boneplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/boneplace1.mp3?raw=true" },
  { id: 37, name: "plasticplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/plasticplace1.mp3?raw=true" },
  { id: 38, name: "laserplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/laserplace1.mp3?raw=true" },
  { id: 39, name: "brickplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/brickplace1.mp3?raw=true" },
  { id: 40, name: "clayplace1", src: "https://github.com/Guttobear/soundssimbox/blob/main/clayplace1.mp3?raw=true" }



























];
const terrainmap = document.getElementById("terrainmap");
function openterrainmap(){
    closemap();
    
  terrainmap.style.display = terrainmap.style.display === 'grid' ? 'none' : 'grid';


}
// Preload
sfxsounds.forEach(sound => {
  sound.audio = new Audio(sound.src);
  sound.audio.load();
});


  
const sfx = new Audio(); // master settings
function playrandomsfx(){
   // Generate a random index
  const randomIndex = Math.floor(Math.random() * sfxsounds.length);
  
  // Get the random sound object
  const sound = sfxsounds[randomIndex];

  // Create a new audio element
  const newSound = new Audio(sound.src);
  const id = sound.id;
  const name = sound.name;
  
  // Set the volume (assuming sfx.volume is defined)
  newSound.volume = sfx.volume; // Make sure sfx.volume is defined somewhere in your code
  console.log(`Played sound with id: ${id} and name of: ${name}`);
  // Play the sound
  newSound.play().catch(error => {
    console.warn("Error playing sound:", error);
  });
    
}
document.getElementById('colorToggle').addEventListener("change", function (e) {
    useCustomColor = e.target.checked;
});

function playsfx(name) {
  const sound = sfxsounds.find(s => s.name === name);
  if (sound && sound.audio) {
    const newSound = sound.audio.cloneNode();
    newSound.volume = sfx.volume;
    newSound.play();
    return newSound;
  } else {
    console.warn("Sound not found:", name);
  }
}
let placingLoopAudio = null;

function startPlacingLoop(soundName) {
  const loopSound = sfxsounds.find(s => s.name === soundName);
  if (loopSound) {
    placingLoopAudio = loopSound.audio.cloneNode();
    placingLoopAudio.loop = true;
    placingLoopAudio.volume = sfx.volume;
    placingLoopAudio.play();
  } else {
    console.warn("Loop sound not found:", soundName);
  }
}

// new version:
function stopPlacingLoop(endSoundName = null) {
  if (placingLoopAudio) {
    placingLoopAudio.pause();
    placingLoopAudio = null;

    if (endSoundName) { // Only play if you gave an ending sound
      const endSound = sfxsounds.find(s => s.name === endSoundName);
      if (endSound) {
        const endAudio = endSound.audio.cloneNode();
        endAudio.volume = sfx.volume;
        endAudio.play();
      } else {
        console.warn("End sound not found:", endSoundName);
      }
    }
  }
}
let ambianceState = {
    lava: { count: 0, threshold: 10, soundPlaying: false, chance: 0.01, sound: "lava1" },
    fire: { count: 0, threshold: 3, soundPlaying: false, chance: 0.01, sound: "fire2" },
    water: { count: 0, threshold: 14, soundPlaying: false, chance: 0.01, sound: "water1" },
    glitch: { count: 0, threshold: 2, soundPlaying: false, chance: 0.05, sound: ["glitch1", "glitch2", "glitch3"]},
    fly: { count: 0, threshold: 4, soundPlaying: false, chance: 0.01, sound: "fly1" }


    // you can add water, leaves, glitch, etc.
};
function ambiance() {
    // Reset counts
    for (let key in ambianceState) {
        ambianceState[key].count = 0;
    }

    // Count elements
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            let el = grid[row][col].element;
            if (ambianceState[el]) {
                ambianceState[el].count++;
            }
        }
    }

    // Play or stop sounds based on counts
    for (let key in ambianceState) {
        let a = ambianceState[key];
        
        if (a.count >= a.threshold) {
            if (!a.soundPlaying && Math.random() < a.chance) {
                let soundToPlay = a.sound;

                if (Array.isArray(a.sound)) {
                    soundToPlay = a.sound[Math.floor(Math.random() * a.sound.length)];
                }

                let audio = playsfx(soundToPlay); // Get the audio object
                a.soundPlaying = true;
                a.currentAudio = audio; // Save it here

                // When the sound finishes, allow it to be played again
                audio.addEventListener('ended', () => {
                    a.soundPlaying = false;
                    a.currentAudio = null;
                });
            }
        } else {
            if (a.soundPlaying) {
                stopsfx(a.currentAudio); // Stop the saved audio
                a.soundPlaying = false;
                a.currentAudio = null;
            }
        }
    }
}
  
function stopsfx(audioObj) {
  if (audioObj) {
    audioObj.pause();
    audioObj.currentTime = 0;
  }
}


        function playui(name) {
  const sound = sfxsounds.find(s => s.name === name);
  if (sound) {
    ui.load();
    ui.src = sound.src;
 
    ui.play();
  } else {
    console.warn("Sound not found:", name);
  }
}

document.addEventListener("click", function(event) {
    const clickedElement = event.target;
    
    // Check if the element has an inline onclick attribute
    if (clickedElement.hasAttribute("onclick")) {
       
         playui("click2");
      
    }
  });
  (function () {
      const output = document.getElementById('output');

      function writeToOutput(type, args) {
        const colorMap = {
          log: 'lightblue',
          warn: 'yellow',
          error: 'red',
          info: 'cyan'
        };

        const message = args.map(arg =>
          typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
        ).join(' ');

        const span = document.createElement('span');
        span.style.color = colorMap[type] || '#eee';
        span.textContent = `[${type}] ${message}\n`;
        output.appendChild(span);

        // Auto-scroll to bottom
        output.scrollTop = output.scrollHeight;
      }

      ['log', 'warn', 'error', 'info'].forEach(type => {
        const original = console[type];
        console[type] = function (...args) {
          original.apply(console, args); // Keep native console behavior
          writeToOutput(type, args);     // Redirect to output
        };
      });
    })();
  // Volume Sliders
  const musicSlider = document.getElementById('musicVolume');
  const sfxSlider = document.getElementById('sfxVolume');
  const uiSlider = document.getElementById('uiVolume');
  
  function playDreamspace() {
    music.muted = false;
    const randomIndex = Math.floor(Math.random() * dreamspacemusic.length);
    music.src = dreamspacemusic[randomIndex];
    music.pause();
music.currentTime = 0;

    music.play().catch(e => {
      console.warn("Autoplay might be blocked. Try interacting with the page first.");
    });
  }
  let inputFocused = false;

const input = document.getElementById('textselection');

input.addEventListener('focus', () => {
  inputFocused = true;
});

input.addEventListener('blur', () => {
  inputFocused = false;
});

const inpute = document.getElementById('elementtext');

inpute.addEventListener('focus', () => {
  inputFocused = true;
});

inpute.addEventListener('blur', () => {
  inputFocused = false;
});


  function playnight() {
    music.pause();
music.currentTime = 0;

    music.muted = false;
    const randomIndex = Math.floor(Math.random() * nightmusic.length);
    music.src = nightmusic[randomIndex];
    music.play().catch(e => {
      console.warn("Autoplay might be blocked. Try interacting with the page first.");
    });
  }

  musicSlider.value = localStorage.getItem("musicSlider") || 0.5;
sfxSlider.value = localStorage.getItem("sfxSlider") || 0.5;
uiSlider.value = localStorage.getItem("uiSlider") || 0.5;

  const musicPercentDisplay = document.getElementById("musicPercent");
  const sfxPercentDisplay = document.getElementById("sfxPercent");
  const uiPercentDisplay = document.getElementById("uiPercent");
  function setupSlider(slider, percentDisplay, audio, playbackRate = 0.8, volumeMultiplier = 2) {
  // Load saved value from localStorage if available
  const savedValue = localStorage.getItem(slider.id);
  if (savedValue !== null) {
    slider.value = savedValue;
    percentDisplay.textContent = `${(savedValue * 100).toFixed(0)}%`;
  }

  slider.addEventListener("input", function () {
    const value = parseFloat(slider.value);
    percentDisplay.textContent = `${(value * 100).toFixed(0)}%`;

    // Save to localStorage
    localStorage.setItem(slider.id, slider.value);

    // Update audio properties and play feedback
    if (audio) {
      audio.volume = value * volumeMultiplier;
      audio.playbackRate = playbackRate;
      audio.currentTime = 0;
      audio.play();
    }
  });
}


// Assuming these elements are already defined
setupSlider(musicSlider, musicPercentDisplay, musicfeedback);
setupSlider(sfxSlider, sfxPercentDisplay, sfxfeedback);
setupSlider(uiSlider, uiPercentDisplay, uifeedback);


  // Set initial volume
  music.volume = musicSlider.value;
  sfx.volume = sfxSlider.value;
  ui.volume = uiSlider.value;

  // Add event listeners
  musicSlider.addEventListener('input', () => {
    music.volume = musicSlider.value;
    if( musicSlider.value < 0.01){
        music.pause();
        music.currentTime = 0;
    }
  });
  uiSlider.addEventListener('input', () => {
    ui.volume = uiSlider.value;
    if( uiSlider.value < 0.01){
        ui.pause();
        ui.currentTime = 0;
    }
  });

  sfxSlider.addEventListener('input', () => {
    sfx.volume = sfxSlider.value;
    if( sfxSlider.value < 0.01){
        sfx.pause();
        sfx.currentTime = 0;
    }
  });
      function voxelsizeinput() {
            let inputsize = document.getElementById("voxelsize").value;
            voxelSize = inputsize;
            rows = Math.floor(height / voxelSize);
            cols = Math.floor(width / voxelSize);
            initializeGrid();
           
        }
        document.addEventListener("DOMContentLoaded", function() {
            document.getElementById("voxelsize").addEventListener("keydown", function(event) {
                if (event.key === "Enter") {
                    voxelsizeinput();
                }
            });
        });

      function opensoundsettings(){
        soundsettings = !soundsettings;
        if(soundsettings){
          document.getElementById('settingcontainer').style.display = 'none';
          document.getElementById('soundcontainer').style.display = 'block';

        } else {document.getElementById('settingcontainer').style.display = 'grid';
        document.getElementById('soundcontainer').style.display = 'none';
      }
      }
     
      function opensettingsmenu(){
        settings = !settings;
        if(settings){
          document.getElementById('settingcontainer').style.display = 'grid';
          document.getElementById('menu-container').style.display = 'none';
                    document.getElementById('blur').style.display = 'none';

      

          

        } else {document.getElementById('settingcontainer').style.display = 'none';
        document.getElementById('menu-container').style.display = 'block';
                document.getElementById('blur').style.display = 'block';

       
       
      }
      }

      function openthemesettings(){
        themesettings = !themesettings;
        if(themesettings){
          document.getElementById('settingcontainer').style.display = 'none';
          document.getElementById('themecontainer').style.display = 'block';

        } else {document.getElementById('settingcontainer').style.display = 'grid';
        document.getElementById('themecontainer').style.display = 'none';
      }
      }
      
      let nightmodetoggle = false;
      function themetoggle() {
    const theme = document.getElementById("themetoggle").value;
    if (theme === "night") {
        night();
        playnight();
        
    } else  if(theme === "normal"){
        day();
       
        } else  if(theme === "dreamspace"){
         
        dreamspace();
        playDreamspace();
     
        }
       
    
}
      function opencontrolsettings(){
        controlsettings = !controlsettings;
        if(controlsettings){
          document.getElementById('settingcontainer').style.display = 'none';
          document.getElementById('controlscontainer').style.display = 'block';

        } else {document.getElementById('settingcontainer').style.display = 'grid';
        document.getElementById('controlscontainer').style.display = 'none';
      }
      }

      function opengridsettings(){
        gridsettings = !gridsettings;
        if(gridsettings){
          document.getElementById('settingcontainer').style.display = 'none';
          document.getElementById('gridcontainer').style.display = 'block';

        }else {document.getElementById('settingcontainer').style.display = 'grid';
        document.getElementById('gridcontainer').style.display = 'none';
      }
      }

      function nowalls2() {
            const button = document.getElementById("nowallstoggle");
            const isOn = button.textContent.includes("on");
            button.textContent = `Walls: ${isOn ? "off" : "on"}`;
            button.classList.toggle("active", !isOn);
            nowalls = !nowalls;
        }
    
        
  


      
        function filterMaterials() {
    const query = document.getElementById('searchBar').value.toLowerCase();
    const buttons = document.querySelectorAll('.material-button');

    buttons.forEach(button => {
        const material = button.innerText.toLowerCase();
        if (material.includes(query)) {
            button.style.display = 'inline-block'; // Show matching buttons
        } else {
            button.style.display = 'none'; // Hide non-matching buttons
        }
    });
}




        //saving logic
     
    function newgame() {
      
        initializeGrid();
        document.getElementById('menu-container').style.display = 'none'; // Show load menu
        document.getElementById('material-selector').style.display = 'grid'; // Show load menu
        document.getElementById('simulation').style.display = 'block'; // Show load menu
        document.getElementById('catalog').style.display = 'none'; // Hide menu
        
        catshown = true;
        menushown = false;

        return;
        

    }
    document.getElementById('catbutton').addEventListener('click', () => {
    catshown = !catshown; // Toggle the paused state
    const button = document.getElementById('catbutton');
    if (catshown) {
        document.getElementById('catalog').style.display = 'none'; // Hide menu

    } else {
        document.getElementById('catalog').style.display = 'block'; // Hide menu
    }
});
function downloadSave(saveKey) {
    const savedState = localStorage.getItem(saveKey);
    if (!savedState) {
        console.warn("Save not found.");
        return;
    }

    // Convert the saved state into a Blob and trigger download
    const blob = new Blob([savedState], { type: "application/json" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = saveKey + ".json";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
}

function importSave(event) {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = function (e) {
        try {
            const sparseGrid = JSON.parse(e.target.result);
            const saveKey = `gameState_${Date.now()}`; // Generate a unique save key

            // Save the imported state to localStorage
            localStorage.setItem(saveKey, JSON.stringify(sparseGrid));

            // Capture the canvas as an image for preview
            const canvas = document.getElementById('simulation');
            const imageData = canvas ? canvas.toDataURL() : '';

            // Update the saves list
            const saves = JSON.parse(localStorage.getItem('saves')) || [];
            saves.push({ key: saveKey, date: new Date().toLocaleString(), image: imageData });
            localStorage.setItem('saves', JSON.stringify(saves));

            updateLoadMenu(); // Refresh UI with the new save

            console.log("Game successfully imported!");

            
        } catch (error) {
            console.error("Invalid save file", error);
        }
    };

    reader.readAsText(file);
}



let previousCommand = '';  // Store the previous command
document.addEventListener('keydown', (event) => {
    if (event.key === '`') {
        const commandWindow = document.getElementById("commandWindow");
        if (commandWindow.style.display === 'none') {
            commandWindow.style.display = 'flex';  // Show the command window
            cmd = true;
        } else {
            commandWindow.style.display = 'none';  // Hide the command window
            cmd = false;
        }
    }
}); // Capture phase ensures this runs before other listeners



const commands = {
    "pause": () => { 
        isPaused = !isPaused; 
        return `Simulation ${isPaused ? "paused" : "resumed"}`; 
    },
    "clear": () => { 
        initializeGrid(); 
        drawGrid(); 
        return "Grid cleared"; 
    },
    "help": () => {
    return `Available commands: ${Object.keys(commands).join(", ")}`;
},

    "selectedElement": (element) => {
        if (element) {
            // Assuming you have a function to set the color
            selectedElement = element;
            return `element set to ${element}`;
        } else {
            return "Error: No element provided. Usage: selectedElement <element>";
        }
    },
    "setGrid": (elementtype) => {
        if (elementtype) {
            // Assuming you have a function to set the color
            setGrid(elementtype);
            return `element set to ${elementtype}`;
        } else {
            return "Error: No element provided. Usage: setGrid <element>";
        }
    },
    "nuke": () => { 
        nuke();
        return "dropped the nukes"; 
    },
 "heatdeath": () => { 
    heatDeathActive = !heatDeathActive; // Toggle state
    return `Heat Death ${heatDeathActive ? "activated" : "deactivated"}!`;
},
"voxelSize": (size) => { 
    size = parseInt(size, 10);
    if (!size || size <= 0) return "Invalid voxel size!";

    voxelSize = size;
    rows = Math.floor(height / voxelSize);
    cols = Math.floor(width / voxelSize);

    initializeGrid(); // Clears and resizes the grid
    drawGrid(); // Redraws the simulation

    return `Voxel size set to ${voxelSize}, grid refreshed to ${rows}x${cols}`;
},
"elements": () => {
    const elementList = Object.keys(elements);
    const textToCopy = elementList.join(", ");

    const textarea = document.createElement("textarea");
    textarea.value = textToCopy;
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand("copy");
    document.body.removeChild(textarea);

    return `${textToCopy}\nTotal elements: ${elementList.length}`;
},



"randomize": (args) => {
    const possibleElements = Object.keys(elements).filter(el => 
        el !== 'random' && el !== 'empty' && el !== 'antimatter' && elements[el].type !== 'explosion' && el !== 'cursor'
    );

    if (possibleElements.length === 0) {
        return "No elements available for randomization.";
    }

    let randomizedCount = 0;
    let onlySelected = args === "selected"; // Check if user wants to randomize only selected elements

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            const cell = grid[row][col];

            // If "selected" is specified, only randomize selected elements
            if (onlySelected && !cell.selected) {
                continue;
            }

            if (cell.element !== "empty") {
                const randomElement = possibleElements[Math.floor(Math.random() * possibleElements.length)];
                cell.element = randomElement;
                cell.age = 0; // Reset age when replaced
                randomizedCount++;
            }
        }
    }

    drawGrid(); // Ensure the grid updates visually
    return `Randomized ${randomizedCount} ${onlySelected ? "selected" : "all"} elements in the grid!`;
},

"freeze": () => {
    elements.empty.color = 'rgba(0, 216, 255, 0.15)';
   
                freeze = true;
                return "why is it cold?";
            },
"edit-element": (args) => {
        // Split args into the element name, property, and value
        const [elementName, property, value] = args.split(' ').map(arg => arg.trim());

        // Validate the arguments
        if (!elementName || !property || value === undefined) {
            return "Error: Invalid arguments. Usage: edit-element <elementName> <property> <value>";
        }

        // Check if the element exists
        if (elements[elementName]) {
            // Check if the property exists, if not, add it dynamically
            if (elements[elementName][property] !== undefined) {
                // Property exists, update the value
                elements[elementName][property] = value;
                return `${property} of ${elementName} set to ${value}`;
            } else {
                // Property doesn't exist, add it
                elements[elementName][property] = value;
                return `New property ${property} added to ${elementName} with value ${value}`;
            }
        } else {
            return `Error: Element '${elementName}' not found`;
        }
    },
    "replace": (args) => {
    const [fromElement, toElement] = args.split(' ').map(arg => arg.trim());

    if (!toElement) {
        return "Error: Invalid arguments. Usage: replace <elementToReplace> <newElement>";
    }

    let replacedCount = 0;

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            if (grid[row][col].element === fromElement || (fromElement === "selected" && grid[row][col].selected === true)) {
                grid[row][col].element = toElement;
                grid[row][col].customcolor = selectedColor;
                replacedCount++;
            }
        }
    }

    drawGrid(); // Ensure the grid updates visually
    return `Replaced ${replacedCount} instances of '${fromElement}' with '${toElement}'.`;
},
"liquify": () => {
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
    liquid(row, col);
        }
    }
    return `Way to go, now everything is wet`;
},
"gridArray": () => {
    // Create the grid array representation
    const gridArray = [];
    for (let row = 0; row < rows; row++) {
        const gridRow = [];
        for (let col = 0; col < cols; col++) {
            let cell = grid[row][col];

            // If it's a coloredvoxel, store it as an object with color
            if (cell.element === 'coloredvoxel' && cell.customcolor) {
                gridRow.push(`{element: 'coloredvoxel', color: '${cell.customcolor}'}`);
            } else {
                gridRow.push(`'${cell.element}'`);
            }
        }
        gridArray.push(`[${gridRow.join(', ')}]`); // Keep each row on one line
    }

    // Join rows with a comma after each one, adding a newline every 3 rows
    const gridString = gridArray.map((row, index) => 
        (index + 1) % 3 === 0 ? `${row},\n` : `${row},`
    ).join('\n');

    // Copy to clipboard
    const textarea = document.createElement("textarea");
    textarea.value = `[${gridString}]`;  // Wrap the entire array in square brackets
    document.body.appendChild(textarea);
    textarea.select();
    document.execCommand("copy");
    document.body.removeChild(textarea);

    return "Grid array copied to clipboard!";
},






   "map": (map) => {
        if(map === 'forest'){
            initializeGrid();
            placeShape(0, 0, forest);
            day();
        } else   if(map === 'volcano'){
            initializeGrid();
            placeShape(0, 0, volcano);
            day();
        }  else   if(map === 'desert'){
            initializeGrid();
            placeShape(0, 0, desert);
            day();
        } else   if(map === 'island'){
            initializeGrid();
            placeShape(0, 0, island);
            day();
        } else   if(map === 'wasteland'){
            initializeGrid();
            placeShape(0, 0, wasteland);
            day();
        }else if(map === 'city'){
            initializeGrid();
            placeShape(0, 0, city);
            night();
        }
        return `Map changed to ${map}`
    },
"night": () => {
    night();
    
     return "Night mode activated with stars!";
},
"code":(code) => {
    const cvoxel = document.getElementById("coloredvoxel");
    if(code === "givemenow"){
        cvoxel.style.display = "block"; // Show color picker
        return "Correct code";
    } else return "wrong code!";
},
"flipGravity": () => {
  
    toggleGravity();
     return "well that was unexpeceted";
}
















};


function night(){
    elements.empty.color = '#1A1A2E'; // Set dark background
    createStars();
    stars2 = []; // Clear previous stars
    night = true;
   
}

function dreamspace(){
   
    elements.empty.color = '#FF7575'; // Set dark background
    createDreamStars();
    stars = [];
    night = false;
   

}
function day(){
    elements.empty.color = '#616171'; // Set dark background
    stars = [];
    stars2 = []; // Clear previous stars
    night = false;

}

function createDreamStars() {
    stars2 = []; // Clear previous stars
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            if (grid[row][col].element === "empty" && Math.random() < 0.005) { // 5% chance
                stars2.push({ row, col });
            }
        }
    }
}
let time = 0; // Variable to control the time for sine wave calculation
let stars2 = [];
function drawdreamStar(ctx, x, y, radius) {
    ctx.beginPath();
    let centerX = x;
    let centerY = y;

    // Draw the star shape
    for (let i = 0; i < 5; i++) {
        let angle = (Math.PI * 2 * i) / 5 - Math.PI / 2;
        let outerX = centerX + Math.cos(angle) * radius;
        let outerY = centerY + Math.sin(angle) * radius;

        let innerAngle = angle + Math.PI / 5;
        let innerX = centerX + Math.cos(innerAngle) * (radius / 2);
        let innerY = centerY + Math.sin(innerAngle) * (radius / 2);

        if (i === 0) {
            ctx.moveTo(outerX, outerY); // Starting point for the star
        } else {
            ctx.lineTo(outerX, outerY);
        }
        ctx.lineTo(innerX, innerY); // Connect the inner and outer points of the star
    }

    // Fill the star with a color (you can change the color as you like)
    ctx.closePath();
    ctx.fillStyle = "white"; // Color for the star
    ctx.fill();

    // Now draw the line from the center of the star to the top of the canvas (y = 0)
    ctx.beginPath(); // Start a new path for the line
    ctx.moveTo(centerX, centerY); // Starting at the center of the star
    ctx.lineTo(centerX, 0);       // Drawing a line to the top (y = 0)
    ctx.strokeStyle = "white";      // Color for the line
    ctx.lineWidth = 1;            // Set the line width
    ctx.stroke();                 // Actually draw the line
}




function drawdreamStars(ctx) {
    ctx.fillStyle = "white";

    stars2.forEach(star => {
        if (grid[star.row][star.col].element === "empty") {
            let x = star.col * voxelSize + voxelSize / 2; // Centering inside the voxel
            let yBase = star.row * voxelSize + voxelSize / 2;  // Base y position of the star
            
            // Use a sine wave to make the star move up and down smoothly
            let yOffset = Math.sin(time + star.col + star.row) * 5;  // Adjust 10 for the amplitude
            
            // Update the star's y position based on the sine function
            let y = yBase + yOffset;

            drawdreamStar(ctx, x, y, voxelSize * 1); // Adjust size
        }
    });

    // Increase time to animate the stars
    time += 0.05; // Controls the speed of the movement
}

// Ensure stars are generated before rendering:


// Inside your main render loop, add:





let stars = []; // Array to store star positions
function createStars() {
    stars = []; // Clear previous stars

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            if (grid[row][col].element === "empty" && Math.random() < 0.05) { // 5% chance
                stars.push({ row, col }); // Store grid position
            }
        }
    }
}

function drawStars(ctx) {
    ctx.fillStyle = "white";

    stars.forEach(star => {
        // Only draw the star if the cell is still empty
        if (grid[star.row][star.col].element === "empty") {
            let x = star.col * voxelSize + voxelSize * 0.75; // Shift visually to the right
            let y = star.row * voxelSize + voxelSize / 2;
            ctx.fillRect(x, y, 2, 2); // Draw small star point
        }
    });
}






let heatDeathActive = false; // Default is false
let freeze = false;

function executeCommand() {
    const input = document.getElementById("commandInput").value.trim();
    const output = document.getElementById("output");

    const spaceIndex = input.indexOf(' ');

    let command, args = [];
    if (spaceIndex === -1) {
        command = input;
    } else {
        command = input.slice(0, spaceIndex);
        args = input.slice(spaceIndex + 1).trim().split(',').map(arg => arg.trim()); // Split args by commas and trim spaces
    }

    let message = `<span style="color: white;">> ${input}</span><br>`; // Default white for input

    if (commands[command]) {
        // Execute predefined command with arguments
        const result = commands[command](...args);
        message += `<span style="color: green;">${result}</span><br>`;
    } else if (input.endsWith('();')) {
        // Check if it's a function call like functionname();
        const functionName = input.slice(0, -3); // Remove '();' to get the function name
        if (typeof window[functionName] === 'function') {
            // Call the function dynamically with no arguments
            window[functionName]();
            message += `<span style="color: green;">Function '${functionName}' executed.</span><br>`;
        } else {
            message += `<span style="color: red;">Error: Function '${functionName}' not found.</span><br>`;
        }
    } else {
        message += `<span style="color: red;">Unknown command. Type 'help' for a list.</span><br>`;
    }

    output.innerHTML += message;
    previousCommand = input;
    document.getElementById("commandInput").value = '';  
    output.scrollTop = output.scrollHeight;
}


window.onload = function() {
    const output = document.getElementById("output");
    output.innerHTML = `<span style="color: orange;">Warning! This is used for mostly debug purposes, so unexpected things may happen! But if you don’t care, have some fun! </span><br>`;
};


function handleKeyDown(event) {
    if (event.key === 'Enter') {
        executeCommand();
    } else if (event.key === 'ArrowUp') {
        document.getElementById("commandInput").value = previousCommand;  // Show last command on Up Arrow
    }
}

let isDragging = false;
let offsetX = 0;
let offsetY = 0;

// Function to make the window draggable
const windowElement = document.getElementById('commandWindow');
const headerElement = document.getElementById('windowHeader');

headerElement.addEventListener('mousedown', (e) => {
    isDragging = true;
    offsetX = e.clientX - windowElement.offsetLeft;
    offsetY = e.clientY - windowElement.offsetTop;
});

document.addEventListener('mousemove', (e) => {
    if (isDragging) {
        const x = e.clientX - offsetX;
        const y = e.clientY - offsetY;
        windowElement.style.left = `${x}px`;
        windowElement.style.top = `${y}px`;
    }
});

document.addEventListener('mouseup', () => {
    isDragging = false;
});

// Close the window
function closeWindow() {
    windowElement.style.display = 'none';
    cmd = false;
}

function saveGame() {
    if (isStorageFull()) {
        console.warn("LocalStorage is full. Save aborted to prevent overflow.");
        alert("Unable to save. Memory is full. Please delete old saves.");
        return;
    }

    // Only store non-empty voxels
    const sparseGrid = [];
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            if (grid[row][col].element !== "empty") { // Only save non-empty elements
                sparseGrid.push({ row, col, data: grid[row][col]});
            }
        }
    }

    const gridState = JSON.stringify(sparseGrid);
    const saveKey = `gameState_${Date.now()}`;

    console.log("Saving game with key:", saveKey);
    console.log("Grid state:", gridState);

    // Capture the canvas as an image for preview
    const canvas = document.getElementById('simulation');
    const imageData = canvas ? canvas.toDataURL() : '';

    console.log("Canvas image data:", imageData ? "Captured" : "Not captured");

    // Save the game state
    try {
        localStorage.setItem(saveKey, gridState);
    } catch (error) {
        console.error("Error saving to localStorage:", error);
        alert("Error saving game. Storage may be full.");
        return;
    }

    // Update the list of saves
    let saves = JSON.parse(localStorage.getItem('saves')) || [];
    saves.push({ key: saveKey, date: new Date().toLocaleString(), image: imageData });

    try {
        localStorage.setItem('saves', JSON.stringify(saves));
    } catch (error) {
        console.error("Error updating saves list:", error);
        return;
    }

    updateLoadMenu(); // Refresh UI with the new save

    console.log("Game saved successfully!");
}


function isStorageFull(limitInBytes = 5 * 1024 * 1024) { // Default limit: 5MB
    let total = 0;
    for (let key in localStorage) {
        if (localStorage.hasOwnProperty(key)) {
            total += key.length + localStorage.getItem(key).length;
        }
    }
    return total >= limitInBytes;
}
function openLoadMenu(){
    document.getElementById('loadMenu').style.display = 'block'; // Show load menu
    return;

}
setInterval(() => {
        document.getElementById('savePopUp').style.display = 'none'; // Show load menu
 }, 1000);
function savepopup(){
    document.getElementById('savePopUp').style.display = 'block'; // Show load menu
  

}

let menushown = false;

window.addEventListener('keydown', (e) => {

    if (e.key === 'Escape') { // Use 'Escape' as a string to check for the Escape key
    if (inputFocused) return;
    if(menushown){
        menushown=false;
            document.getElementById('menu-container').style.display = 'none'; // Hide menu
                        document.getElementById('blur').style.display = 'none'; // Hide menu

             document.getElementById('blur').style.display = 'none'; // Hide menu
            isPaused = false; // Toggle the paused state
            document.getElementById('catalog').style.display = 'none'; // Hide menu
        catshown = true;


        } else {
          

            document.getElementById('menu-container').style.display = 'block'; // Show menu
               

            menushown = true;
            isPaused = true; // Toggle the paused state
                   document.getElementById('blur').style.display = 'block'; // Hide menu

        }
    
    }
});

function updateLoadMenu() {
    const saves = JSON.parse(localStorage.getItem('saves')) || [];
    const saveList = document.getElementById('saveList');
    saveList.innerHTML = ''; // Clear previous saves

    saves.forEach((save, index) => {
        const saveItem = document.createElement('div');
        saveItem.style.display = 'flex'; // Use flexbox for layout
        saveItem.style.alignItems = 'center'; // Center items vertically
        saveItem.style.marginBottom = '10px'; // Space between items
        saveItem.innerHTML = `
            <img src="${save.image}" alt="Save Thumbnail" style="width: 50px; height: 50px; margin-right: 10px;" />
            <div style="flex-grow: 1;">
                <p>Date: ${save.date}</p>
            </div>
            <button onclick="loadSpecificGame('${save.key}')">Load</button>
            <button onclick="deleteSave(${index})">Delete</button>
           
           <button style="position:absolute; left: 60%; transform: translateY(100%);"onclick="downloadSave('${save.key}')">Export</button>
        


        `;
        saveList.appendChild(saveItem);
          // Add an input field for importing saves
     
   
    });
    
    const importInput = document.createElement('input');
    importInput.type = 'file';
    importInput.accept = '.json';
    importInput.onchange = importSave;
    saveList.appendChild(importInput);

}
function showmapmenu() {
    var map = document.getElementById("map");
   
      map.style.display = "grid"; // Show element
      menushown=false;

      document.getElementById('menu-container').style.display = 'none'; // Hide load menu
            document.getElementById('blur').style.display = 'none'; // Hide load menu


  }
  function closemap() {
    
   

      map.style.display = "none"; 
      
      
    

  }
   function closeterrain() {
    
   

      terrainmap.style.display = "none"; 
      
      
    

  }
 

  





function deleteSave(index) {
    const saves = JSON.parse(localStorage.getItem('saves')) || [];
    
    // Get the save key to delete the associated game state
    const saveToDelete = saves[index]?.key;
    
    if (saveToDelete) {
        localStorage.removeItem(saveToDelete); // Remove the game state from localStorage
    }
    
    // Remove the save metadata at the specified index
    saves.splice(index, 1);
    
    // Update the saves array in localStorage
    localStorage.setItem('saves', JSON.stringify(saves));
    
    // Refresh the load menu to reflect the changes
    updateLoadMenu();
}

let cmd = false;
function closeLoadMenu() {
    document.getElementById('loadMenu').style.display = 'none'; // Hide load menu
}
function loadSpecificGame(saveKey) {
    const savedState = localStorage.getItem(saveKey);
    if (!savedState) {
        console.log("No saved game found.");
        return;
    }

    let gridState = JSON.parse(savedState);

    // Ensure the grid is initialized
    initializeGrid();

    if (Array.isArray(gridState) && gridState.length > 0 && typeof gridState[0] === 'object' && 'row' in gridState[0] && 'col' in gridState[0]) {
        // ✅ New sparse format detected (array of {row, col, data})
        gridState.forEach(({ row, col, data }) => {
            if (row >= 0 && row < rows && col >= 0 && col < cols) {
                grid[row][col] = data;
            }
        });
    } else {
        // ✅ Old full-grid format detected (2D array)
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (gridState[row] && gridState[row][col]) {
                    grid[row][col] = gridState[row][col];
                }
            }
        }
    }

    drawGrid(); // Redraw the grid to reflect the loaded state
    closeLoadMenu();
    document.getElementById('menu-container').style.display = 'none';
        document.getElementById('blur').style.display = 'none';

    document.getElementById('material-selector').style.display = 'grid';
    document.getElementById('simulation').style.display = 'block';
    document.getElementById('catalog').style.display = 'none';
    catshown = true;
}


    function loadGame2(grid){
        const gridState = JSON.parse(grid);
         // Restore the grid from the saved state
         for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (gridState[row] && gridState[row][col]) {
                    grid[row][col] = gridState[row][col];
                }
            }
        }
        drawGrid(); // Redraw the grid to reflect the loaded state
    }
    function loadGame() {
    const savedState = localStorage.getItem('gameState');
    if (!savedState) {
        console.log("No saved game found.");
        return;
    }

    const sparseGrid = JSON.parse(savedState);

    // Ensure the grid is initialized
    initializeGrid();

    // Restore only the non-empty elements
    sparseGrid.forEach(({ row, col, data }) => {
        if (row >= 0 && row < rows && col >= 0 && col < cols) {
            grid[row][col] = data;
        }
    });

    drawGrid(); // Redraw the grid to reflect the loaded state
}

document.getElementById('loadButton').addEventListener('click', updateLoadMenu);
document.getElementById('loadButton').addEventListener('click', openLoadMenu);
        document.getElementById('saveButton').addEventListener('click', saveGame);
        document.getElementById('saveButton').addEventListener('click', savepopup);

 const glitchButton = document.getElementById('glitchButton');
 const originalText = "Glitch"; // Original text
 
 function randomText() {
     const randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789#@!*^%*()&';
     let result = '';
     for (let i = 0; i < originalText.length; i++) {
         result += randomChars.charAt(Math.floor(Math.random() * randomChars.length));
     }
     return result;
 }
 
 function changeTextRandomly() {
     glitchButton.textContent = randomText(); // Change button text to random characters
 
     // Set a random interval for the next text change (between 200ms and 1000ms)
     const randomDelay = Math.floor(Math.random() * (5 - 1 + 1)) + 50; // Random delay between 200ms and 1000ms
     setTimeout(changeTextRandomly, randomDelay);
 }
 
 // Start the first text change
 changeTextRandomly();
 
 // Restore the original text at a fixed interval (optional)
 setInterval(() => {
     glitchButton.textContent = originalText; // Restore original text
 }, 1000); // Restore original text every 5000 milliseconds (5 seconds)
        const canvas = document.getElementById('simulation');
        const ctx = canvas.getContext('2d');
        let width = 800;
        let height = 600;
        let voxelSize = 10; // Default size
 
 
        let showVoxels = false;
        let selectedElement = 'empty';
        let brushSize = 1;
        let isDrawing = false;
        canvas.width = width;
        canvas.height = height;
 
 
        const buttons = document.querySelectorAll('.material-button');
 // Add event listener for the spacebar to pause/unpause
 window.addEventListener('keydown', (e) => {
 
     if (e.code === 'Space' && cmd === false) { // Check if the spacebar is pressed
        if (inputFocused) return;
         e.preventDefault(); // Prevent default spacebar action (scrolling)
         isPaused = !isPaused; // Toggle the paused state
         const button = document.getElementById('pauseButton');
         if (isPaused) {
             button.classList.remove('pause');
             button.classList.add('play');
             
         } else {
             button.classList.remove('play');
             button.classList.add('pause');
           
         }
     }
 });
 
 
 function deepCopyCell(cell, exclude = []) {
    let copy = {};
    for (let key in cell) {
        if (key === 'emptyColor') continue; // Always skip emptyColor
        if (!exclude.includes(key)) {
            copy[key] = structuredClone(cell[key]);
        }
    }
    return copy;
}

 
 
        buttons.forEach(button => {
            button.addEventListener('click', () => {
                // Remove 'selected' class from all buttons
                buttons.forEach(btn => btn.classList.remove('selected'));
                // Add 'selected' class to the clicked button
                button.classList.add('selected');
                // Update the selected element
                selectedElements = button.getAttribute('data-material'); // Update your selectedElement variable
            });
        });
 
 
 
 
 
        function getRandomColorBetween(color1, color2) {
     return Math.random() < 0.5 ? color1 : color2;
 }
 function getRandomColorBetween1(color1, color2) {
     return Math.random() < 0.2 ? color1 : color2;
 }
 function getRandomColor() {
     const randomColor = Math.floor(Math.random() * 16777215).toString(16);
     return `#${randomColor}`;
 }
 
 function changeGlitchButtonColor() {
     const glitchButton = document.getElementById('glitchButton');
     glitchButton.style.backgroundColor = getRandomColor(); // Set a random color
 }
 
 // Set the interval to change the color every 1000 milliseconds (1 second)
 setInterval(changeGlitchButtonColor, 100);
 
 function changeRandomButtonColor() {
     const randomButton = document.getElementById('randomButton');
     randomButton.style.backgroundColor = getRandomColor(); // Set a random color
 }
 
 // Set the interval to change the color every 1000 milliseconds (1 second)
 setInterval(changeRandomButtonColor, 1000);
 
 
   // Existing brush size input event listener
   document.getElementById('brushSize').addEventListener('input', (e) => {
     brushSize = parseInt(e.target.value, 10);
 });
 
 // New wheel event listener for changing brush size
 canvas.addEventListener('wheel', (e) => {
     e.preventDefault(); // Prevent the default scrolling behavior
     if (e.deltaY < 0) {
         // Scrolling up, increase brush size
         brushSize = Math.min(100, brushSize + 1); // Limit max size to 30
     } else {
         // Scrolling down, decrease brush size
         brushSize = Math.max(1, brushSize - 2); // Limit min size to 1
     }
     document.getElementById('brushSize').value = brushSize; // Update the slider value
 });    
 let rows, cols;
        let cols2 = width / voxelSize;
        let rows2 = height / voxelSize;
        let nowalls = false;
        
        if(nowalls === true){
         rows = rows2 + 1
         cols = cols2 + 1;
        } else {
            rows = rows2;
            cols = cols2 + 1;
        }
        const grid = [];
 
        const elements = {
            empty: {
                color: '#616171',
                type: 'empty',
                density: 0

               
            },
            water: {
                colors:[ '#1535C6','#100DCE'],
                type: 'liquid',
                density: 1,
                water: true,
                heavy: 3,
                liquid: true
            },
            lava: {
                colors: ['#Cf1020', '#FF4500', '#FF8C00'],
                type: 'liquid',
                density: 2,
                unsafe: true,
                heavy: 3,
                boil: true,
                liquiddelay: 3,
                liquid: true
            },
            darkLava: {
                color: '#cc5500',
                type: 'liquid',
                density: 2,
                unsafe: true,
                liquid: true,
                liquiddelay: 10
            },
            magma: {
                colors: ['#8B0000', '#4C1111', '#D53D01'],
                type: 'solid',
                density: 2.5,
                unsafe: true,
                heavy: 3,
                boil: true,
                liquid: true,
                liquiddelay: 4
            },
            basalt: {
             initialColor: '#454545', // Initial color for stone
             color1: '#454545', // Light gray
             color2: '#503534', // Dark gray
                type: 'solid',
                density: 2.8
            },
            obsidian: {
             initialColor: 'rgba(0, 0, 0, 0.5)',
             color1: 'rgba(0, 0, 0, 0.5)',
             color2: '#343434',
                type: 'solid',
                density: 3
            },
            sand: {
              
                initialColor: '#c2b280', // Initial color for stone
 
 color1: '#AC9F75', // Light gray
 color2: '#c2b280', // Dark gray
                type: 'solid',
                density: 1.5,
                heavy: 3,
                powder: true
            },
            stone: {
             initialColor: '#8A8A8A', // Initial color for stone
 
             color1: '#8A8A8A', // Light gray
             color2: '#7E7E7E', // Dark gray
                type: 'solid',
                density: 2.5
            },
            mud: {
                color: '#423223',
                type: 'liquid',
                density: 2
            },
            grass: {
             initialColor: '#0BAD00', // Initial color for stone
             color1: '#0BAD00', // Dark green
             color2: '#10C104', // Light green
                type: 'solid',
                density: 1,
                flammable: true
            
            },
            ice: {
                color: '#C7FFFD',
                type: 'solid',
                density: 0.8
            },
            oil: {
                color: 'black',
                type: 'liquid',
                density: 0.9,
                flammable: true,
                heavy: 3,
                liquid: true


            },
            sugar: {
                color: 'lightyellow',
                type: 'solid',
                density: 0.5,
                heavy: 4,
                powder: true
            },
            fire: {
                colors: ['#FF4500', '#FF8C00'],
                type: 'gas',
                density: 0,
                unsafe: true,
                boil: true
                
                
            },
            smoke: {
                color: '#738276',
                type: 'gas',
                density: 0.5,
                heavy: 8
            },
            snow: {
                color: 'white',
                type: 'solid',
                density: 0.5
            },
            steam: {
                color: 'lightgray',
                type: 'gas',
                density: 0.1,
                maxAge: 12000,
                heavy: 8
            }, // 120 seconds assuming 60fps
            wood: {
             initialColor: '#AB8564', // Initial color for stone
             color1: '#A28164', // Dark green
             color2: '#AB8564', // Light green
                type: 'solid',
                density: 1.5,
                flammable: true
            },
            dirt: {
              
                initialColor: '#57422E', // Initial color for stone
             color1: '#43362A', // Dark green
             color2: '#57422E', // Light green
                type: 'solid',
                density: 1.0,
                heavy: 4,
                powder: true
            },
            glass: {
                color: 'rgba(135, 206, 250, 0.5)',
                type: 'solid',
                density: 1.9
            }, // Added Glass Element
            moltensand: {
                colors: ['#F36E12', '#DD6513'],
                type: 'liquid',
                density: 2,
                unsafe: true,
                heavy: 2,
                boil: true,
                liquid: true,
                liquiddelay: 5
            },
            lowheatrock:{
             color: '#9A8A7A',
             type: 'solid',
             density: 2,
             unsafe: true
            },
            mediumheatrock:{
             color: '#AA7A6A',
             type: 'solid',
             density: 2,
             unsafe: true,
             boil: true
            },
            virus:{
             colors:['#6C04A8', '#7603C1'],
             type: 'solid',
             density: 2,
             flammable: true,
             unsafe: true
            },
            concrete:{
             
             initialColor: '#959595', // Initial color for stone
             color1: '#9E9E9E', // Dark green
             color2: '#959595', // Light green
             type:'liquid',
             density:1.5,
             heavy: 1,
             powder: true
            },
            Explosion:{
             color:'#ff4500',
             type: 'gas',
             density: 1,
             unsafe: true
            },
            tnt:{
             color: 'red',
             type:'solid',
             density:1,
             flammable: true,
             unsafe: true
            
            },
            uranium:{
             color:'green',
             type: 'solid',
             density:3,
             unsafe: true
            },
            UExplosion:{
             color:'#ff4500',
             type: 'gas',
             density: 1,
             unsafe: true
            }, 
            syrup:{
             color: '#AC9E91',
             type: 'liquid',
             density: 0.8,
             heavy: 4,
             liquid: true
            },
            smokeBomb:{
             color:'#323232',
             type: 'solid',
             density: 1,
             unsafe: true
            },
            Leaf:{
             color:'#26C53B',
             type: 'solid',
             density: 0.5,
             flammable: true
            }, 
            grenade: {
             color: '#025A01',
             type: 'solid',
             density: 0.9,
             unsafe: true
            },
            Gexplosion:{
             color: '#025A01',
             type: 'gas',
             density: 1,
             unsafe: true
            },
            crystal: {
             color: 'rgba(232, 132, 232, 0.5)',
             type: 'solid',
             density: 1
            
            },
            glitch: {
     type: 'solid',
     density: 1,
     getColor: function() {
         // Generate a random color in hex format
         const randomColor = Math.floor(Math.random()*16777215).toString(16);
         return `#${randomColor}`;
     },
     unsafe: true
 },
           random:{
             color:'black',
             type: 'solid',
             density: 0
           },
           fly: {
             color:'black',
             type: 'solid',
             density: 0.1
           },
           ash: {
             color: '#9E9D90',
             type: 'solid',
             density: 0.2
           }, 
          
     blackhole: {
         color:'black',
         type: 'solid',
         density: 1000000000000
 },
     liquidN:{
         color: '#8DD5BF', 
         type: 'liquid',
         density: 1,
         unsafe: true,
         liquid: true
     },
     milk:{
         color:'white',
         type: 'liquid',
         density: 0.5,
         heavy: 4,
         liquid: true
     },
     steel:{
         color:'#A4A4A4',
         type: 'solid',
         density: 2
 
     },
     sponge:{
         color:'#D5FB00',
         type: 'solid',
         density: 0.4,
         flammable: true
     },
     wetsponge:{
         color:'#B5D500',
         type: 'solid',
         density: 0.4
     },
     cloner:{
         color:'#C100FF',
         type: 'solid',
         density: 0
     },
     salt:{
         color:'#F7CEFE',
         type: 'solid',
         density: 0.4,
         heavy: 3,
         powder: true
     },
     quartz:{
         color:'#FAB2F5',
         type: 'solid',
         density: 1
     }, 
     fog:{
         color: 'lightgray',
         type: 'gas',
         density: 0.1
     },
     bone:{
         color:'#CDCC9F',
         type: 'solid',
         density: 1
     },
     moss:{
        initialColor:'#7EB534',
         color1:'#7EB534',
         color2:'#78AC34',
         type: 'solid',
         density: 0.6,
         flammable: true
     },
     copper:{
         color:'#FF8300',
         type: 'solid',
         density: 1.7
     },
     copper2:{
         color:'#996F33',
         type: 'solid',
         density: 1.7
     },
     copper3:{
         color:'#7B5733',
         type: 'solid',
         density: 1.7
     },
     copper4:{
         color:'#3B7A57',
         type: 'solid',
         density: 1.7
     },
     copper5:{
         color:'#8DBCB9',
         type:'solid',
         density: 1.7
     },
     mercury:{
         color:'#8C8C8C',
         type:'liquid',
         density: 1.5,
         heavy: 2,
         liquid: true
     },
     cactus:{
         color:'green',
         type: 'solid',
         density: 0.8,
         flammable: true
     },
     acid:{
         color:'#80FF54',
         type: 'liquid', 
         density: 1,
         unsafe: true,
         heavy: 4,
         liquid: true
     }, 
     gunpowder:{
         color: '#474747',
         type: 'solid',
         density: 0.6,
         unsafe: true,
         flammable: true,
         heavy: 4,
         powder: true
     },
     nitro:{
         color: '#FF8700',
         type: 'liquid',
         density: 0.6,
         unsafe: true,
         flammable: true,
         heavy: 4,
         liquid: true
     },
     nb:{
         color:'red',
         type:'solid',
         density: 2
     },
     sawdust: {
         color: '#EAEC42',
         type: 'solid',
         density: 0.4,
         flammable: true,
         heavy: 6,
         powder: true
     },
     saltwater:{
         color:'#8291D6',
         type: 'liquid',
         density: 0,
         heavy: 3,
         liquid: true
     },
     wetsand:{
         color:'#A49874',
         type: 'solid',
         density: 1.1
     },
     rust:{
         color:'#A96D6A',
         type: 'solid',
         density: 2
     },
     pollen:{
         color: '#F1EA08',
         type: 'gas',
         density: 0.1,
         flammable: true
     },
     solidcloner:{
         color:'#C100FF',
         type: 'solid',
         density: 0
     },
     coal:{
         color:'#3C3C35',
         type: 'solid',
         density: 1,
         flammable: true
     },
     pwater:{
         color:'#4D6393',
         type: 'liquid',
         density: 1,
         heavy: 3,
         liquid: true
     },
     plastic:{
         color:'#ADBFE7',
         type: 'solid',
         density: 1
     },
     laser:{
            colors: ['#F2C304', '#EE7F37'],
            type: 'gas',
            density: 100142,
            unsafe: true,
            boil: true
        },
        lasersource:{
            colors: ['#F2C304', '#EE7F37'],
            type: 'gas',
            density: 100142,
            unsafe: true
        },
        diamond:{
            initialColor:"#67D3CA",
            color1:"#67D3CA",
            color2:"#4FC8BE",
            type: "solid",
            density: 3
        },
        flashbang:{
            color:'#5F5F5F',
            type: 'solid',
            density: 0.5,
            unsafe: true
        },
        FExplosion:{
            color: 'white',
            type: 'solid',
            density: 0,
            unsafe: true
        },
        flash:{
            color: 'white',
            type: 'gas',
            density: 0,
            unsafe: true
        },
        gallium:{
            color: '#595552',
            type: 'solid',
            density: 0.8,
           
        },
        liquidgallium:{
            color: '#5F5B59',
            type: 'solid',
            density: 0.8,
            heavy: 4,
            liquid: true
        },
        brick:{
            color: '#D12A2A',
            type: 'solid',
            density: 2
        },
        charcoal:{
            color: '#272727',
            type: 'solid',
            density: 0.5,
            flammable: true,
            heavy: 3,
            powder: true
        },
        clay:{
            color: '#B9B9B9',
            type: 'solid',
            density: 1,
            heavy: 3,
            powder: true
        },
        solidclay:{
            color:'#898989',
            type: 'solid',
            denisty: 1.5
        },
        pig:{
            color:'#FF7DEF',
            type: 'solid',
            density: 0.8,
            flammable: true
            
        },
        nuke:{
            color:'#165900',
            type: 'solid',
            density: 3,
            unsafe: true
        },
        aluminum:{
            color: '#BFBFBF',
            type: 'solid',
            density: 1
        },
        gravel:{
            color:'#AFAFAF',
            type: 'solid',
            density: 1.7,
            heavy: 1,
            powder: true
        },
        antimatter:{
            color: 'black',
            type: 'unknown',
            density: 9835934,
            unsafe: true
        },
        plasma:{
            colors: ['#FB00FF', '#FFE400', '#4262F2'],
            type: 'plasma',
            density: 100,
            unsafe: true,
            boil: true,
            powder:true
        },
        supernova:{
            color: 'yellow',
            type: 'explosion',
            density: 3288732789,
            unsafe: true
        },
        vine:{
            color:'#3AAA33',
            type:'plant',
            density: 0.3,
            flammable: true
        },
        star:{
            color:'#F1FE75',
            type: 'solid',
            density: '500',
            unsafe: true
        },
        missilehead:{
            color: '#FA0000',
            type: 'solid',
            density: 2,
            unsafe: true
        },
        missilebody:{
            color:'#444444',
            type: 'solid',
            density: 2,
            unsafe: true
        },
        wind:{
            color:'lightgray',
            type: 'gas',
            density: 0
        },
        molotov:{
            color:'#20A100',
            type: 'solid',
            density: 0.7,
            unsafe: true
        },
        mExplosion:{
            color: 'black', 
            type: 'explosion',
            density: 10
        },
        
        bomb:{
            color:'#3A3A3A',
            type: 'solid',
            density: 1,
            unsafe: true
        },
        
        bExplosion:{
            color: 'black',
            type: 'explosion',
            density: 23
        },
        wire:{
            color:'#525575',
            type: 'solid',
            density: 0.6
        },
        ewire:{
            colors:['#525575','#A5B424'],
            type:'solid',
            density: 0.7,
            boil: true
        },
        battery:{
            color:'#883D26',
            type: 'solid',
            density: 1,
            electric: true,
            boil: true
        },
        redlightoff:{
            color:'#834848',
            type: 'solid',
            density: 0.4
        },
        redlight:{
            color:'#FC2A2A',
            type:'solid',
            density:0.45,
            electric: true
        },
        shock:{
            color:'#FCFF1C',
            type:'gas',
            density: 0,
            unsafe: true,
            electric: true
        },
        emp:{
            color:'#607689',
            type: 'explosion',
            density: 4,
            unsafe: true
        },
        empgrenade:{
            color:'#607689',
            type: 'explosion',
            density: 4,
            unsafe: true
        },
        gold:{
            initialColor:"#E5D883",
            color1:"#D3C66D",
            color2:"#D1C263",
            type: 'solid',
            density: 3

        },
        moltengold:{
            color:'#D1C263',
            type: 'liquid',
            density: 2.8,
            heavy: 2,
            boil: true
        },
        titanium:{
            color:'#878681',
            type: 'solid',
            density: 4
        },
        silver:{
            color:'#C0C0C0',
            type: 'solid',
            density: 1.6
        },
        lead:{
            color:'#393939',
            type: 'solid',
            density: 1.2
        },
        chlorine:{
            color:'#D6F593',
            type: 'liquid',
            density: 0.4,
            heavy: 4,
            liquid: true
        },
        chlorinegas:{
            color:'#C6C55B',
            type: 'gas',
            density: 0.1,
            heavy: 8
        },
        tin:{
            color:'#919191',
            type:'solid',
            density: 0.9
        },
        bromine:{
            color:'#1D1605',
            type: 'liquid',
            density: 2,
            heavy: 4,
            liquid: true
        },
        brominegas:{
            color: 'rgba(143,88,48, 0.5)',
            type: 'gas',
            density: 1,
            heavy: 7
        },
        platinum:{
            color:'#C5C2C0',
            type: 'solid',
            density: 2.6
        },
        zinc:{
            color:'#AEB4B7',
            type:'solid',
            density: 2
        },
        magnesium:{
            color:'#B1C0BD',
            type:'solid',
            density: 2.3
        },
        mine:{
            color: '#303030',
            type: 'solid',
            density: 0.5
        },
        bronze:{
            color:'#9B5D1B',
            type: 'solid',
            density: 1.5
        },
        nickel:{
            color:'#C4BA9A',
            type: 'solid',
            density: 1
        },
        ink:{
            color: '#1B1A19',
            type: 'liquid',
            density: 0.4,
            heavy: 4
        },
        ketchup:{
            color:'#DC2020',
            type: 'liquid',
            density: 0.3,
            heavy: 4,
            liquid: true
        },
        caramel:{
            color:'rgba(228, 129, 23, 0.9)',
            type:'liquid',
            density: 0.3,
            liquid: true
        },
        moltentin:{
            color:'#B3B3B3',
            type: 'liquid',
            density: 1.3,
            heavy: 2,
            boil: true,
            liquid: true
        },
        moltenlead:{
            color:'#515151',
            type: 'liquid',
            denstiy: 1.2,
            heavy: 2,
            boil: true,
            liquid: true,
            liquiddelay: 3
        },
        tuff:{
            color:'#B8A084',
            type: 'liquid',
            density: 1.5,
            heavy: 1,
            powder: true
        },
        limestone:{
            color:'#CFB697',
            type: 'liquid',
            density: 1.8,
            heavy: 1,
            powder: true
        },
        firework:{
            color:'#FF0000',
            type: 'liquid',
            density: 1
        },
        fireworkf:{
            colors:['#DDE237', 'red', 'blue', '#4E72D2', 'orange'],
            type: 'gas',
            density: 12
        },
        fireworke:{
            color: 'black',
            type: 'explosion',
            density: 289
        },
        moltenpla:{
            color:'#C6CBD6',
            type: 'liquid',
            density: 2,
            heavy: 2,
            boil: true,
            liquid: true
        },
        vegetableoil:{
            color:'rgba(238,217,86, 0.7)',
            type:'liquid',
            density: 0.2,
            flammable: true,
            heavy: 4,
            liquid: true
        },
        bullet:{
            color:'#525252',
            type: 'solid',
            density: 1,
            unsafe: true
        },
        cheese:{
            initialColor: '#F5EF73', // Initial color for stone
             color1: '#A6A251', // Dark green
             color2: '#F5EF73', // Light green
            type: 'solid',
            density: 0.3
        },
        meltedcheese:{
            color:'#F5EF73',
            type:'liquid',
            density: 0.3,
            heavy: 4,
            liquid: true
        },
        hay:{
            color:'#E4B572',
            type:'solid',
            density: 0.4,
            flammable: true,
            heavy: 4,
            powder: true
        },
        cloth:{
            initialColor: '#DFDAD2', // Initial color for stone
             color1: '#BFBDBA', // Dark green
             color2: '#DFDAD2', // Light green
             type: 'solid',
             density: 0.2,
             flammable: true
            
        },
        paper:{
            initialColor: '#DADADA', // Initial color for stone
             color1: '#CACACA', // Dark green
             color2: '#DADADA', // Light green
             type: 'solid',
             density: 0.05,
             flammable: true
            
        },
        dryice:{
            initialColor: '#DADADA', // Initial color for stone
             color1: '#FDFDFD', // Dark green
             color2: '#DADADA', // Light green
             type: 'solid',
             density: 0.8

        },
        straw:{
            initialColor: '#AF935B', // Initial color for stone
             color1: '#DEC084', // Dark green
             color2: '#C4AB78', // Light green
             type: 'solid',
             density: 0.2,
             flammable: true
        },
        tractorbeam:{
            color: 'rgba(90,255,185, 0.9)',
            type: 'unknown',
            density: 10,
            unsafe: true
        },
        tractorbeams:{
            color: 'rgba(90,255,185, 0.9)',
            type: 'unknown',
            density: 10,
            unsafe: true
        },
        bleach:{
            color: 'rgba(255,255,255, 0.8)',
            type: 'liquid',
            density: 0.4,
            flammable: true,
            heavy: 4,
            liquid: true
        },
        teslacoil:{
            color:'#FF3B00',
            type: 'solid',
            density: 5,
            unsafe: true
        },
        vinegar:{
            color:'#E8EEA6',
            type: 'liquid',
            density: 0.4,
            heavy: 4,
            liquid: true
        },
        bubble:{
            color:'#9CCAE5',
            type: 'gas',
            density: 0.01
        },
        bubbleo:{
            color:'rgba(156,202,229, 0.6)',
            type: 'gas',
            density: 0.01
        },
        soap:{
            color:'#FDFFE4',
            type: 'liquid',
            density: 0.6,
            heavy: 4,
            liquid: true
        },
        hm:{
            color: '#FF0800',
            type: 'homeing',
            density: 5
        },
        hmb:{
            color:'#2C2C2C',
            type: 'homeing',
            density: 2
        },
        freezeray:{
            color:'#61E5FF',
            type: 'unknown',
            density: 25
        },
        freezerays:{
            color:'#61E5FF',
            type: 'unknown',
            density: 25
        },
        cb:{
           color:'#393939',
           type: 'solid',
           density: 1.5 
        },
        radiation:{
            color:'#84E84B',
            type: 'gas',
            density: 1
        },
        radiationo:{
            color:'rgba(132,232,75, 0.6)',
            type: 'gas',
            density: 1
        },
        honey:{
            color:'rgba(240,146,33, 0.7)',
            type: 'liquid',
            density: 1,
            heavy: 4,
            liquid: true,
            liquiddelay: 6
        },
        static:{
            colors:['white','rgba(0,0,0,0)'],
            type:'solid',
            density: 1,
            unsafe: true
        
        },
        sap:{
            color:'rgba(240,146,33, 0.7)',
            type: 'liquid',
            density: 1.2
        },
        firefly:{
            color:'#ECE436',
            type: 'liquid',
            density: 0.1
        },
        fireflyb:{
            color:'#2F2F2F',
            type: 'liquid',
            density: 0.1

        },
        foam:{
            color:'#CBCBCB',
            type: 'gas',
            density: 0.1

        },
        foamo:{
            color:'#9C9C9C',
            type: 'gas',
            density: 0.1

        },
        sulfur:{
            color:'#F0E600',
            type: 'liquid',
            density: 1.2,
            unsafe: true,
            heavy: 4,
            boil: true,
            powder: true
        },
        sa:{
            color:'#E0DFBB',
            type: 'liquid',
            density: 1.2,
            unsafe: true,
            liquid: true
        },
        feather:{
            color:'white',
            type: 'solid',
            density: 0.01,
            flammable: true
        },
        border:{
            colors:['#0298AD','rgba(97,97,113, 0.6)', '#0298AD'],
            type: 'unbreakable',
            density: 10
        },
        c4:{
            color:'#F56CE5',
            type: 'liquid',
            density: 1,
            flammable: true
        },
        cf:{
            color:'black',
            type: 'solid',
            density: 0.01,
        },
        cfr:{
            color:'#FF0000',
            type: 'cf',
            density: 0.01,
            cf: true
        },
        cfb:{
            color:'#0032FF',
            type: 'cf',
            density: 0.01,
            cf: true
        },
        cfp:{
            color:'#FF00E8',
            type: 'cf',
            density: 0.01,
            cf: true

        },
        cfg:{
            color:'#00FF46',
            type: 'cf',
            density: 0.01,
            
        },
        partypopper:{
            color:'#FF00EC',
            type: 'liquid',
            density: 0.3
        },
        glue:{
            color:'#DDDDDD',
            type: 'glue',
            density: 1,
            heavy: 4
        },
        soda:{
            color:'#3D2808',
            type: 'liquid',
            density: 0.3,
            heavy: 4,
            liquid: true
        },
        mentos:{
            color:'#D5D5D5',
            type: 'liquid',
            density: 0.6,
            heavy: 5,
            powder: true
        },
        juice:{
            color:'#FBBE0D',
            type: 'liquid',
            density: 0.3,
            heavy: 4,
            liquid: true
        },
        wax:{
            color:'#FFF3D2',
            type: 'liquid',
            density: 1,
            heavy: 4
        },
        sodium:{
            color:'#545454',
            type: 'liquid',
            density: 1,
            flammable: true,
            heavy: 4,
            powder: true
        },
        flowerseed:{
            color:'#6F8929',
            type: 'liquid',
            density: 0.2,
            flammable: true
        },
        flowerstem:{
            color:'#67C619',
            type: 'solid',
            density: 0.1,
            flammable: true
        },
        flowerbud:{
            color:'#9AB223',
            type: 'solid',
            density: 0.2,
            flammable: true
        },
        fp:{
            color:'black',
            type: 'fp',
            density: 0.1
        },
        fpr:{
            color:'#FF0000',
            type: 'fp',
            density: 0.01,
            flammable: true
        },
        fpb:{
            color:'#0032FF',
            type: 'fp',
            density: 0.01,
            flammable: true
        },
        fpp:{
            color:'#FF00E8',
            type: 'fp',
            density: 0.01,
            flammable: true

        },
        fpg:{
            color:'#00FF46',
            type: 'fp',
            density: 0.01,
            flammable: true
            
        },
        mushroomseed:{
            color: '#D7D0A7',
            type: 'liquid',
            density: 0.3
        },
        mushroomstem:{
            color: '#D7D0A7',
            type: 'solid',
            density: 0.2
        },
        me:{
            color:'black',
            type: 'explosion',
            density: 1
        },
        mushroomtop:{
            color:'#898361',
            type: 'solid',
            density: 0.5
        },
        tinder:{
            color:'#806641',
            type: 'liquid',
            density: 1,
            flammable: true,
            heavy: 5
        },
        bamboo:{
            initialColor: '#56EA11', // Initial color for stone
             color1: '#6FBB18', // Dark green
             color2: '#41A70E', // Light green
             type: 'solid',
             density: 1,
             flammable: true
        },
        gs:{
            initialColor: '#879090', // Initial color for stone
             color1: '#909C9C', // Dark green
             color2: '#879090', // Light green
             type: 'solid',
             density: 3
        },
        tsunami: {
                colors:[ '#1535C6','#100DCE'],
                type: 'liquid',
                density: 1
        },
        earthquake:{
            color:'black',
            type: 'solid',
            density: 10
        },
        fuse:{
            color:'#4A4A4A',
            type: 'solid',
            density: 1
        },
        mwax:{
            color:'#FFF3D2',
            type: 'liquid',
            density: 1,
            heavy: 4,
            liquid: true
        },
        lasercannon:{
            colors:['#FF6C00', '#FFF300', '#FF3A00'],
            type: 'laser',
            density: 1
        },
        le:{
            color: 'black',
            type: 'explosion',
            density: 1
        },
        nanobug:{
            color:'#7C7B7B',
            type: 'undifined',
            density: 1
        },
        web: {
            initialColor: '#D2D2D2', // Initial color for stone
             color1: '#BFBFBF', // Dark green
             color2: '#D2D2D2', // Light green
             type: 'solid',
             density: 1,
             flammable: true
        },
        flea:{
            color:'#4B2E1A',
            type: 'liquid',
            density: 1,
            flammable: true
        },
        sappling: {
            color:'#77B823',
            type: 'liquid',
            density: 1,
            flammable: true
        },
        log:{
            color:'#523418',
            type: 'solid',
            density: 1,
            flammable: true
        },
        tl:{
            color:'black',
            type: 'solid',
            density: 2
        },
        root:{
            color:'#8C6540',
            type: 'solid',
            density: 1,
            flammable: true
        },
        granite:{
            color:'#A46965',
            type: 'liquid',
            density: 1,
            heavy: 1,
            powder: true
        },
        humantop:{
            color:'#D5CF8D',
            type: 'solid',
            density: 1,
            flammable: true,
            heavy: 4
        },
        human: {
             color: '#3583C1',
     type: 'liquid',
     density: 1,
     flammable: true,
     heavy: 4
 
    
 
        },
        antimatterbomb:{
    color:'#494949',
    type: 'solid',
    density: 1,
    unsafe: true
        },
        diorite:{
    color:'#DBDBDB',
    type: 'solid',
    density: 2,
    heavy: 1,
    powder: true
        },
        fireball:{
            color:'#4D4D4D',
            type: 'solid',
            density: 1
        },
        fireballe:{
            color:'#4D4D4D',
            type: 'solid',
            density: 1
        },
        hail:{
            color:'#BCF8E9',
            type: 'liquid',
            density: 0.6
        },
        moltendiorite:{
            color:'#F14E29',
            type: 'liquid',
            density: 1,
            heavy: 2,
            liquid: true,
            liquiddelay: 4
        },
        moltengranite:{
            color:'#D66530',
            type: 'liquid',
            density: 1,
            heavy: 2,
            liquid: true,
            liquiddelay: 4
        },
        zombie:{
            color:'#3583C1',
            type: 'liquid',
            density: 1,
            flammable: true
        },
        zombietop:{
            color:'#2C9530',
            type: 'liquid',
            density: 1,
            flammable: true
        },
        lightning:{
            color:'#FCF97B',
            type: 'plasma',
            density: 10,
            unsafe: true
        },
        lexplosion:{
            color:'black',
            type: 'explosion',
            density: 1
        },
        lexplosion2:{
            color:'black',
            type: 'explosion',
            density: 1
        },
        tornado:{
            color:'lightgray',
            type: 'gas',
            density: 1
        },
        tornado2:{
            color:'lightgray',
            type: 'gas',
            density: 1
        },
        petrol:{
            color:'#284659',
            type: 'liquid',
            density: 1,
            flammable: true,
            heavy: 4,
            liquid: true
        },
        bee:{
            color:'#D9C531',
            type: 'liquid',
            density: 0.1
        },
        bird:{
            color: '#878157',
            type: 'liquid',
            density: 1,
            flammable: true
        },
        cursor:{
            color: 'black',
            type: 'solid',
            density: 1
        },
        cursorb:{
            color: 'white',
            type: 'solid',
            density: 1
        },
        timecapsule:{
            color: '#5D5D5D',
            type: 'solid',
            density: 1
        },
        faucet: {
    color: '#6F9383',
    type: 'special',
    density: 1.5,
    storedElement: null // Holds the first detected element
},
        popcorn:{
            color: '#FAF163',
            type: 'solid',
            density: 0.2,
            powder: true
            
        },
        popcorno:{
            color: '#F1EDAB',
            type: 'outer',
            density: 0.1
        },
        hotsteel:{
            color: '#A4A4A4',
            type: 'solid',
            density: 2
        },
        snap:{
            color: '#616171',
            type: 'power',
            density: 65217657

        },
        dust:{
            color: '#7D7D7D',
            type: 'gas',
            density: 0.1
        },
        snapnm:{
            color: '#616171',
            type: 'power',
            density: 65217657

        },
        corn:{
            color: '#FCF341',
            type: 'solid',
            density: 0.5,
            heavy: 5,
            powder: true

        },
        speaker:{
            color: '#202020',
            type: 'solid',
            density: 1
        },
        frozendirt:{
            color: '#A89F91',
            type: 'frozen',
            density: 1, 
            heavy: 4,
            powder: true
        },
        frozengrass:{
            color: '#6AB992',
            type: 'frozen',
            density: 1
        },
        wall:{
            color: '#757575',
            type: 'unbreakable',
            density: 1
        },
        
        coloredvoxel:{
            color: 'black',
            type: 'solid',
            density: 1
        },
        sandstone:{
            initialColor: '#C9BD99', // Initial color for stone
             color1: '#c2b280', // Dark green
             color2: '#B4A573', // Light green
             type: 'solid',
             density: 1
        },
        rwaste: {
            color: '#33F209',
            type: 'liquid',
            density: 1,
            liquid: true
        },
        nfire: {
            type: 'liquid',
            density: 1
            
        },
        nabomb: {
            color: '#424242',
            type: 'bomb',
            density: 1
        },
        naexplosion: {
            color: '#424242',
            type: 'bomb',
            density: 1
        },
        clusterbomb: {
            color: '#323232',
            type: 'bomb',
            density: 5
        },
        cexplosion:{
            color: 'black',
            type: 'explosion',
            density: 1
        },
        nuexplosion:{
            color: 'black',
            type: 'explosion',
            density: 10
        },
        darkenergy:{
            color: '#4E2C63',
            type: 'energy',
            density: 100
        },
        glitchc4:{
            color:'#291A32',
            type: 'solid',
            density: 1
        },
        glitche:{
            color: 'black',
            type: 'solid',
            density: 1
        },
        glitchbomb:{
            color:'#291A32',
            type: 'solid',
            density: 1
        },
        oxygen: {
            color: '#A4DDED',
            type: 'gas',
            density: 1,
            heavy: 8

        },
        hydrogen: {
            color: '#E8F6FA',
            type: 'gas',
            density: 1,
            heavy: 8

        },
        h2oe:{
            color: 'black',
            type: 'solid',
            density: 1242
        },
        gasoline:{
            color: '#F4D94299',
            type: 'liquid',
            density: 1,
            liquid: true
        },
        gasolinef:{
            color: '#F4D94299',
            type: 'liquid',
            density: 1,
            liquid: true
        },
        bouncyball:{
            color: 'red',
            type: 'solid',
            density: 1
        },
        sprucesapling:{
            color:'#315D2E',
            type: 'solid',
            density: 1,
            flammable: true
        },
        sprucelog:{
            color:'#3A2D23',
            type: 'solid',
            density: 1,
            flammable: true
        },
        spe:{
            color: 'black',
            type: 'explosion',
            density: 1
        },
        spruceleaf:{
            color: '#3F6639',
            type: 'solid',
            density: 1,
            flammable: true
        },
        stormcloud:{
            color:'#585967',
            type: 'solid',
            density: 1
        },
        rain:{
            color:'blue',
            type: 'liquid',
            density: 1,
            liquid: true
        },
        raincloud:{
            color: '#777777',
            type: 'solid',
            density: 1
        },
        cloud:{
            color: '#DCDCDC',
            type: 'solid',
            density: 1
        },
        snowcloud:{
            color: '#B3B3B3',
            type: 'solid',
            density: 1
        },
        snow2: {
                color: 'white',
                type: 'solid',
                density: 0.5
        },
        frog:{
            color: '#91E57F',
            type: 'solid',
            density: 1
        },
        fish:{
            color: '#CD1C1C',
            type: 'solid',
            density: 1
        },
        ant: {
            color: '#85170E',
            type: 'solid',
            density: 0.1
        },
        pistil:{
            color:'#88A918',
            type: 'solid',
            density: 1,
            flammable: true
        },
        pistil2:{
            color:'#88A918',
            type: 'solid',
            density: 1,
            flammable: true
        },
        snail:{
            color: '#3E241F',
            type: 'solid',
            density: 1
        },
        coral:{
            color:'black',
            type: 'co',
            density: 1
        },
        cob:{
            color:'#559ABE',
            type: 'co',
            density: 1
        },
        cop:{
            color:'pink',
            type: 'co',
            density: 1
        },
        cor:{
            color:'#D34B31',
            type: 'co',
            density: 1
        },
        coy:{
            color:'#CB935B',
            type: 'co',
            density: 1
        },
        copu:{
            color:'#AE55BE',
            type: 'co',
            density: 1
        },
        colpu:{
            color:'#CC93D6',
            type: 'co',
            density: 1
        },
        colpu2:{
            color:'#B5A2B9',
            type: 'co',
            density: 1
        },
        pumpkinseed:{
            color: '#9BC72F',
            type: 'solid',
            density: 1
            
        },
        pumpkinsprout:{
            color: '#6DC72F',
            type: 'solid',
            density: 1
            
        },
        pumpkinvine:{
            color: '#6FAB46',
            type: 'solid',
            density: 1,
            flammable: true
        },
        pumpkin:{
            color: '#FF8F00',
            type: 'solid',
            density: 1
        },
        pumpkinstem:{
            color: '#663415',
            type: 'solid',
            density: 1,
            flammable: true
        },
        rat:{
            color: '#8A8A8A',
            type: 'solid',
            density: 1
        },
        cockroach:{
            color: '#643A17',
            type: 'unbreakable',
            density: 1,

        },
         cockroach2:{
            color: '#643A17',
            type: 'solid',
            density: 1,

        },
        wormhead:{
            color: '#732411',
            type: 'solid',
            density: 1
        },
         wormtail:{
            color: '#732411',
            type: 'solid',
            density: 1
        },
        ghost:{ // 300th element
            color: '#929293',
            type: 'solid',
            density: 1
        },
        teleport1:{
            color: '#FE6F00',
            type: 'teleport',
            density: 1
        },
        teleport2:{
            color: '#0096FE',
            type: 'teleport',
            density: 1
        },
        lavabomb:{
            color: '#95411F',
            type: 'solid',
            density: 1,
            powder: true
        },
        tar:{
            color: '#39322F',
            type: 'solid',
            density: 1
            
        },
        snakegame:{
            color: '#299411',
            type: 'solid',
            density: 1
        },
        snakegametail:{
            color: '#299411',
            type: 'solid',
            density: 1
        },
        apple:{
            color: 'red',
            type: 'solid',
            density: 1
        },
        midas_touch:{
            color: 'gold',
            type: 'solid',
            density: 1,
            liquid:true

        },
        balloon:{
            color: 'black',
            type: 'balloon',
            density: 1
        },
         balloon2:{
            color: 'red',
            type: 'balloon',
            density: 1
        },
         balloon3:{
            color: 'blue',
            type: 'balloon',
            density: 1
        },
         balloon4:{
            color: 'green',
            type: 'balloon',
            density: 1
        },
         balloon5:{
            color: 'yellow',
            type: 'balloon',
            density: 1
        },
        drill:{
            color: '#645A53',
            type: 'solid',
            density: 1,
            
        },
        paint:{
            color: 'red',
            type: 'solid',
            density: 1,
            liquid: true
        },
        paintball:{
            color: 'black',
            type: 'solid',
            density: 1
        },
        painte:{
            color: 'black',
            type: 'solid',
            density: 1
        },
        gameoflife:{
            color: 'white',
            type: 'solid',
            density: 1
        },
        static: {
            colors:['black', 'white'],
            type: 'solid',
            density: 1
        },
        staticbomb:{
            color: 'black',
            type: 'solid',
            density: 1
        },
        statice:{
            color: 'black',
            type: 'solid',
            density: 1
        },
        pointer:{
            color: 'red',
            type: 'solid',
            density: 1
        },
        bedrock:{
            initialColor: '#616161',
            color1: '#616161',
            color2: '#525252',
            type: 'solid',
            density: 2
        },
        bushe:{
            color: 'black',
            type: 'solid',
            density: 1
            
        },
        bushleaf: {
            color: '#428A19',
            type: 'solid',
            density: 1,
            flammable: true
        },
        cactusexplosion:{
            color: 'black',
            type: 'solid',
            density: 1
        },
        rocke:{
            color: 'black',
            type: 'solid',
            density: 1
        }
        
        
        
 
     

        


        
        
        






        
  
        };
        const MILES_PER_VOXEL = 3;
const peer = new Peer(undefined, {
  host: 'peerjs.com',
  port: 443,
  secure: true
});

  let conn = null;

  peer.on('open', id => {
    document.getElementById('my-id').textContent = id;
  });

  peer.on('connection', c => {
    conn = c;
    setupConnection();
  });

  function connectToPeer() {
    const otherId = document.getElementById('peer-id').value;
    conn = peer.connect(otherId);
    conn.on('open', setupConnection);
  }

  function setupConnection() {
    conn.on('data', data => {
      if (data.grid) {
        // Update local grid with remote grid data
        for (let y = 0; y < grid.length; y++) {
          for (let x = 0; x < grid[0].length; x++) {
            grid[y][x] = data.grid[y][x];
          }
        }
      }
    });
  }

  function sendGrid() {
    if (conn && conn.open) {
      conn.send({ grid });
    }
  }

  // Call this every second to sync (optional: optimize to send changes only)
  setInterval(() => {
    sendGrid();
  }, 1000);
function milesToCols(miles) {
    return Math.floor(miles / MILES_PER_VOXEL);
}

function smoothstep(x) {
    return x * x * x * (x * (x * 6 - 15) + 10);
}


function lerp(a, b, t) {
    return a + (b - a) * t;
}

function seededRandom(x, seed = 0) {
    const raw = Math.sin(x * 12.9898 + seed * 78.233) * 43758.5453;
    return raw - Math.floor(raw); // fract: 0 to 1
}

function generateSmoothNoise(cols, spacing, amplitude, seed = 0) {
    const controlPoints = [];
    for (let i = 0; i <= Math.ceil(cols / spacing) + 1; i++) {
        const x = i * spacing;
        const baseRand = Math.sin(x * 12.9898 + seed * 78.233) * 43758.5453;
        const random = (baseRand - Math.floor(baseRand)) * 2 - 1;
        controlPoints.push(random * amplitude);
    }

    const noise = new Array(cols);
    for (let col = 0; col < cols; col++) {
        const segment = Math.floor(col / spacing);
        const t = (col % spacing) / spacing;
        const v1 = controlPoints[segment];
        const v2 = controlPoints[segment + 1];
        noise[col] = lerp(v1, v2, t);
    }

    return noise;
}

let useonebiome = false;
let biomeused = "mountains";
function generateBiomeLayout(cols, seed = 0) {
    const layout = [];
    let col = 0;
    let i = 0;
 
    const biomeTypes = [
        { name: "plateau", temp: "temperate", baseHeight: 27, maxHeight: 29, amplitude: 1, spacing: 70, minWidth: 60, maxWidth: 120 },
        { name: "valley", temp: "temperate", baseHeight: 15, maxHeight: 18, amplitude: 1, spacing: 40, minWidth: 50, maxWidth: 80 },
        { name: "plains", temp: "temperate", baseHeight: 18, maxHeight: 20, amplitude: 1, spacing: 40, minWidth: 40, maxWidth: 90 },
        { name: "forest", temp: "temperate", baseHeight: 18, maxHeight: 23, amplitude: 1.1, spacing: 40, minWidth: 50, maxWidth: 100 },
        { name: "swamp", temp: "cold", baseHeight: 4.5, maxHeight: 6, amplitude: 1.5, spacing: 15, minWidth: 40, maxWidth: 60 },
        { name: "ocean", temp: "cold", baseHeight: 1, maxHeight: 3, amplitude: 1, spacing: 40, minWidth: 50, maxWidth: 200 },
        { name: "desert", temp: "hot", baseHeight: 18, maxHeight: 20, amplitude: 0.5, spacing: 70, minWidth: 60, maxWidth: 160 },
        { name: "mountains", temp: "cold", baseHeight: 27, maxHeight: 40, amplitude: 6, spacing: 25, minWidth: 50, maxWidth: 100 },
        { name: "taiga", temp: "temperate", baseHeight: 18, maxHeight: 23, amplitude: 1, spacing: 35, minWidth: 85, maxWidth: 170 },
        { name: "snowytaiga", temp: "cold", baseHeight: 18, maxHeight: 23, amplitude: 1, spacing: 35, minWidth: 80, maxWidth: 150 }


    ];
 if (useonebiome) {
        const selectedBiome = biomeTypes.find(b => b.name === biomeused) || biomeTypes[0];
        layout.push({
            ...selectedBiome,
            start: 0,
            end: cols
        });
        return layout;
    }
    const compatibleTemps = {
        hot: ["hot", "warm", "temperate"],
        warm: ["hot", "warm", "temperate"],
        temperate: ["hot", "warm", "temperate", "cold"],
        cold: ["temperate", "cold"]
    };

    while (col < cols) {
        let biome;
        let tries = 0;
        const prevBiome = layout.length > 0 ? layout[layout.length - 1] : null;
        const prevTemp = prevBiome ? prevBiome.temp : null;
        const allowedTemps = prevTemp ? compatibleTemps[prevTemp] || [] : null;

        do {
            const rand = seededRandom(i + tries, seed);
            const biomeIndex = Math.floor(rand * biomeTypes.length);
            const candidate = biomeTypes[biomeIndex];

            const tempCompatible = !prevTemp || allowedTemps.includes(candidate.temp);

            // Small chance (10%) to allow a mismatch
            const chanceAllowMismatch = seededRandom(i + tries + 10000, seed) < 0.1;

            const tempOK = tempCompatible || chanceAllowMismatch;

            const desertOK = candidate.name !== "desert" ||
                (prevBiome && (prevBiome.name === "mountains" || prevBiome.name === "ocean"));

            if (tempOK && desertOK) {
                biome = candidate;
                break;
            }

            tries++;
        } while (tries < 10);

        if (!biome) biome = biomeTypes[0]; // fallback to plateau

        const widthRand = seededRandom(i + 999, seed);
        const widthMiles = biome.minWidth + widthRand * (biome.maxWidth - biome.minWidth);
        const biomeCols = milesToCols(widthMiles);

        layout.push({
            ...biome,
            start: col,
            end: Math.min(col + biomeCols, cols)
        });

        col += biomeCols;
        i++;
    }

    return layout;
}






const BLEND_WIDTH_MILES = 50; // transition over 50 miles
const BLEND_WIDTH = milesToCols(BLEND_WIDTH_MILES); // converted to columns

           
function setElement(row, col, elemName, biome = "plains") {
    grid[row][col].element = elemName;
    const elemData = elements[elemName];
    if(biome === "taiga" || biome === "snowytaiga"){
        if(elemName === 'grass'){
         grid[row][col].color = Math.random() < 0.5 ? '#40742F' : '#578349';
    } else{
        if (elemData && elemData.color1 && elemData.color2) {
        grid[row][col].color = Math.random() < 0.5 ? elemData.color1 : elemData.color2;
    }
    }
    } else
    if (elemData && elemData.color1 && elemData.color2) {
        grid[row][col].color = Math.random() < 0.5 ? elemData.color1 : elemData.color2;
    }
}

 // Xorshift PRNG
function Xorshift(seed) {
    let state = seed;
    
    this.next = function() {
        state ^= state << 21;
        state ^= state >>> 35;
        state ^= state << 4;
        return (state >>> 0) / 0xFFFFFFFF;
    }
}



let hell = false;
function createTerrain() {
    const seed = Math.random();
    
if(hell){
    elements.empty.color = '#B47D63';
}
    const layout = generateBiomeLayout(cols, seed);
    const microNoise = generateSmoothNoise(cols, 10, 0.3, seed + 999);
    const SEA_LEVEL = rows - 6;

    function generate2DNoise(width, height, spacing, amplitude, seedOffset = 0) {
        const noise = [];
        for (let y = 0; y < height; y++) {
            noise[y] = generateSmoothNoise(width, spacing, amplitude, seed + seedOffset + y);
        }
        return noise;
    }

    const rockNoise2D = generate2DNoise(cols, rows, 35, 1.0, 1111); // larger spacing for blobs

    for (let i = 0; i < layout.length; i++) {
        const biome = layout[i];
        const nextBiome = layout[i + 1];

        const biomeNoise = generateSmoothNoise(cols, biome.spacing, biome.amplitude, seed + i);
        const nextBiomeNoise = nextBiome
            ? generateSmoothNoise(cols, nextBiome.spacing, nextBiome.amplitude, seed + i + 1)
            : null;

        const biomeCols = biome.end - biome.start;

        for (let localCol = 0; localCol < biomeCols; localCol++) {
            const globalCol = biome.start + localCol;

            let baseHeight = biome.baseHeight;
            let maxHeight = biome.maxHeight;
            let amplitude = biome.amplitude;
            let spacing = biome.spacing;
            let noiseValue = biomeNoise[globalCol];

            // Blend with next biome
            if (nextBiome && globalCol >= biome.end - BLEND_WIDTH) {
                const tRaw = (globalCol - (biome.end - BLEND_WIDTH)) / BLEND_WIDTH;
                const t = smoothstep(tRaw);
                baseHeight = lerp(biome.baseHeight, nextBiome.baseHeight, t);
                maxHeight = lerp(biome.maxHeight, nextBiome.maxHeight, t);
                amplitude = lerp(biome.amplitude, nextBiome.amplitude, t);
                spacing = lerp(biome.spacing, nextBiome.spacing, t);
                noiseValue = lerp(biomeNoise[globalCol], nextBiomeNoise[globalCol], t);
            }

            const finalNoise = noiseValue + microNoise[globalCol];
            const normalized = (finalNoise + 1) / 2;
            const height = Math.floor(baseHeight + normalized * (maxHeight - baseHeight));
            const topRow = rows - height;
            const snowHeightThreshold = 32;

            for (let row = rows - 1; row >= topRow; row--) {
                if (!grid[row] || !grid[row][globalCol]) continue;
 
                const depth = row - topRow;

                if ((rows - row) >= snowHeightThreshold) {
                    if (depth >= 3) {
                        const snowChance = Math.max(0, 0.6 - Math.pow(depth - 2, 2) * 0.02);
                        const frozenDirtChance = Math.max(0, 0.3 - Math.pow(depth - 2, 2) * 0.015);
                        const rand = Math.random();

                        if (rand < snowChance) {
                            if(hell){
                                  setElement(row, globalCol, 'ash');
                            }else
                            setElement(row, globalCol, 'snow');
                        } else if (rand < snowChance + 0.7) {
                            setElement(row, globalCol, 'stone');
                        } else if (rand < snowChance + 0.7 + frozenDirtChance) {
                            setElement(row, globalCol, 'frozendirt');
                        } else {
                            setElement(row, globalCol, 'stone');
                        }
                    } else {
                          if(hell){
                                  setElement(row, globalCol, 'ash');
                            }else
                        setElement(row, globalCol, 'snow');
                    }
                    continue;
                }

                if ((rows - row) <= snowHeightThreshold && (rows - row) <= SEA_LEVEL  && ["plains", "mountain",  "hills", "forest", "valley"].includes(biome.name)) {
                    const saplingChance = biome.name === "forest" ? 0.01 : 0.0005;
                    if (Math.random() < saplingChance && grid[topRow - 1] && grid[topRow - 1][globalCol]) {
                       
                        grid[topRow - 1][globalCol].element = 'sappling';
                      
                    }
                }
                if ((rows - row) <= snowHeightThreshold && (rows - row) <= SEA_LEVEL && ["plains",  "hills", "forest", "valley"].includes(biome.name)) {
                    const saplingChance = biome.name === "forest" ? 0.01 : 0.006;
                    if (Math.random() < saplingChance && grid[topRow - 1] && grid[topRow - 1][globalCol]) {
                      
                            grid[topRow - 1][globalCol].element = 'bushe'; 
                        
                    }
                }
                  if ((rows - row) <= snowHeightThreshold && (rows - row) <= SEA_LEVEL && ["plains",  "platuea", "hills", "forest", "mountain", "valley"].includes(biome.name)) {
                    const saplingChance = biome.name === "platuea" ? 0.05 : 0.005;
                    if (Math.random() < saplingChance && grid[topRow - 1] && grid[topRow - 1][globalCol]) {
                      
                            grid[topRow - 1][globalCol].element = 'rocke'; 
                        
                    }
                }
                if ((rows - row) <= snowHeightThreshold && ["desert"].includes(biome.name)) {
              
                    if (Math.random() < 0.009 && grid[topRow - 1] && grid[topRow - 1][globalCol]) {
                      
                            grid[topRow - 1][globalCol].element = 'cactusexplosion'; 
                        
                    }
                }
                   if ((rows - row) <= snowHeightThreshold && ["taiga", "snowytaiga"].includes(biome.name)) {
              
                    if (Math.random() < 0.009 && grid[topRow - 1] && grid[topRow - 1][globalCol]) {
                      
                            grid[topRow - 1][globalCol].element = 'sprucesapling'; 
                        
                    }
                }
                     if ((rows - row) <= snowHeightThreshold && (rows - row) <= SEA_LEVEL && ["snowytaiga"].includes(biome.name)) {
                   
                    if ( grid[topRow - 1] && grid[topRow - 1][globalCol]) {
                      if(grid[topRow - 1][globalCol].element === 'empty'){
                           if(hell){
                                  setElement(topRow - 1, globalCol, 'ash');
                            }else
                            grid[topRow - 1][globalCol].element = 'snow'; 
                      }
                        
                    }
                }
                

                if (depth <= 1) {
                    if(biome.name !== "desert"){
                    const element = (depth === 1)
                        ? (Math.random() < 0.6 ? 'grass' : (Math.random() < 0.7 ? 'mud' : 'dirt'))
                        : 'grass';
                    setElement(row, globalCol, element, biome.name);
                    } else{
                        setElement(row, globalCol, 'sand');
                    }
                } else if (depth <= 10) {
                    let element;
                    if(biome.name !== "desert"){
                    if (depth >= 7) {
                        element = (Math.random() < 0.1
                            ? (Math.random() < 0.7 ? 'mud' : 'dirt')
                            : 'stone');
                    } else {
                        element = (Math.random() < 0.7 ? 'mud' : 'dirt');
                    }
                    setElement(row, globalCol, element);
                } else{
                    if (depth >= 7) {
                        element = (Math.random() < 0.1
                            ? (Math.random() < 0.7 ? 'sandstone' : 'stone')
                            : 'stone');
                    } else {
                        element = (Math.random() < 0.7 ? 'stone' : 'sandstone');
                    }
                    setElement(row, globalCol, element);
                }
                } else {
                    setElement(row, globalCol, 'stone');
                }
            }
        }
    }

    placeRockBlobs(); // Make sure this is called after the main loop
    placeGravelBlobs(); // Make sure this is called after the main loop
// Second pass: Fill empty spaces below sea level with water
for (let col = 0; col < cols; col++) {
    for (let row = SEA_LEVEL; row < rows; row++) {
        const cell = grid[row][col];
        const biome = layout.find(b => col >= b.start && col < b.end);
        if (!cell) continue;
     
        // First fill empty spaces with water
        if (cell.element === 'empty') {
            if(biome.name === "swamp"){
                if(hell){
                     setElement(row, col, 'lava');
                }else
                if(Math.random() < 0.3){
                setElement(row, col, 'pwater');
                } else{
                       if(hell){
                     setElement(row, col, 'lava');
                }else
                      setElement(row, col, 'water');
                }
            } else
               if(hell){
                     setElement(row, col, 'lava');
                }else
            setElement(row, col, 'water');
        } else {
            // Then check biome if necessary (only for cells that aren't water)
          
            if(cell.element !== 'water'){
            if (biome.name === "ocean") {
                
              
                    if (Math.random() < 0.5) {
                           if(hell){
                     setElement(row, col, 'basalt');
                }else
                        setElement(row, col, 'sand');
                    } else {
                           if(hell){
                     setElement(row, col, 'obsidian');
                }else
                        setElement(row, col, 'stone');
                    }
                
            } else{
                if (biome.name === "swamp") {
              
              if (Math.random() < 0.2) {
                   if(hell){
                     setElement(row, col, 'magma');
                }else
                  setElement(row, col, 'mud');
              } else {
                   if(hell){
                     setElement(row, col, 'basalt');
                }else
                  setElement(row, col, 'stone');
              }
          
      }
     
            }
        }
        } 
    }
}
 
function placeGravelBlobs(spawnChance = 0.005, blobSize = 20, startRowMin = 50) {
    const visited = new Set();

    function key(r, c) {
        return r + "," + c;
    }

    function isValid(r, c) {
        return (
            r >= 0 && r < rows &&
            c >= 0 && c < cols &&
            !visited.has(key(r, c)) &&
            grid[r] && grid[r][c] &&
            grid[r][c].element === 'stone'
        );
    }

    for (let r = startRowMin; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (Math.random() < spawnChance) {
                const queue = [[r, c]];
                let placed = 0;

                while (queue.length > 0 && placed < blobSize) {
                    const [cr, cc] = queue.shift();
                    if (!isValid(cr, cc)) continue;

                    grid[cr][cc].element = 'bedrock';
                    const elemData = elements['bedrock'];
                    if (elemData?.color1 && elemData?.color2) {
                        grid[cr][cc].color = Math.random() < 0.5 ? elemData.color1 : elemData.color2;
                    }

                    visited.add(key(cr, cc));
                    placed++;

                    const neighbors = [
                        [cr - 1, cc], [cr + 1, cc],
                        [cr, cc - 1], [cr, cc + 1],
                    ];

                    for (const [nr, nc] of neighbors.sort(() => Math.random() - 0.5)) {
                        if (isValid(nr, nc)) queue.push([nr, nc]);
                    }
                }
            }
        }
    }
}
function placeRockBlobs(spawnChance = 0.001, blobSize = 20, startRowMin = 20) {
    const visited = new Set();

    function key(r, c) {
        return r + "," + c;
    }

    function isValid(r, c) {
        return (
            r >= 0 && r < rows &&
            c >= 0 && c < cols &&
            !visited.has(key(r, c)) &&
            grid[r] && grid[r][c] &&
            grid[r][c].element === 'stone'
        );
    }

    for (let r = startRowMin; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            if (Math.random() < spawnChance) {
                const queue = [[r, c]];
                let placed = 0;

                while (queue.length > 0 && placed < blobSize) {
                    const [cr, cc] = queue.shift();
                    if (!isValid(cr, cc)) continue;

                    grid[cr][cc].element = 'gravel';
                    const elemData = elements['gravel'];
                    if (elemData?.color1 && elemData?.color2) {
                        grid[cr][cc].color = Math.random() < 0.5 ? elemData.color1 : elemData.color2;
                    }

                    visited.add(key(cr, cc));
                    placed++;

                    const neighbors = [
                        [cr - 1, cc], [cr + 1, cc],
                        [cr, cc - 1], [cr, cc + 1],
                    ];

                    for (const [nr, nc] of neighbors.sort(() => Math.random() - 0.5)) {
                        if (isValid(nr, nc)) queue.push([nr, nc]);
                    }
                }
            }
        }
    }
}

}
function cactus(row, col){
    const size = Math.floor(Math.random() * 4) + 1;
    console.log(height);
    for(r = row; r > row - size; r--){
        grid[r][col].element = 'cactus';
    }
}


        const fontMap = {
    // UPPERCASE A–Z
    A: [[0,1,0],[1,0,1],[1,1,1],[1,0,1],[1,0,1]],
    B: [[1,1,0],[1,0,1],[1,1,0],[1,0,1],[1,1,0]],
    C: [[0,1,1],[1,0,0],[1,0,0],[1,0,0],[0,1,1]],
    D: [[1,1,0],[1,0,1],[1,0,1],[1,0,1],[1,1,0]],
    E: [[1,1,1],[1,0,0],[1,1,0],[1,0,0],[1,1,1]],
    F: [[1,1,1],[1,0,0],[1,1,0],[1,0,0],[1,0,0]],
    G: [[0,1,1],[1,0,0],[1,0,1],[1,0,1],[0,1,1]],
    H: [[1,0,1],[1,0,1],[1,1,1],[1,0,1],[1,0,1]],
    I: [[1,1,1],[0,1,0],[0,1,0],[0,1,0],[1,1,1]],
    J: [[0,0,1],[0,0,1],[0,0,1],[1,0,1],[0,1,0]],
    K: [[1,0,1],[1,1,0],[1,0,0],[1,1,0],[1,0,1]],
    L: [[1,0,0],[1,0,0],[1,0,0],[1,0,0],[1,1,1]],
    M: [[1,0,1],[1,1,1],[1,0,1],[1,0,1],[1,0,1]],
    N: [[1,0,1],[1,1,1],[1,1,1],[1,0,1],[1,0,1]],
    O: [[0,1,0],[1,0,1],[1,0,1],[1,0,1],[0,1,0]],
    P: [[1,1,0],[1,0,1],[1,1,0],[1,0,0],[1,0,0]],
    Q: [[0,1,0],[1,0,1],[1,0,1],[1,1,1],[0,0,1]],
    R: [[1,1,0],[1,0,1],[1,1,0],[1,0,1],[1,0,1]],
    S: [[0,1,1],[1,0,0],[0,1,0],[0,0,1],[1,1,0]],
    T: [[1,1,1],[0,1,0],[0,1,0],[0,1,0],[0,1,0]],
    U: [[1,0,1],[1,0,1],[1,0,1],[1,0,1],[0,1,0]],
    V: [[1,0,1],[1,0,1],[1,0,1],[0,1,0],[0,1,0]],
    W: [[1,0,1],[1,0,1],[1,0,1],[1,1,1],[1,0,1]],
    X: [[1,0,1],[1,0,1],[0,1,0],[1,0,1],[1,0,1]],
    Y: [[1,0,1],[1,0,1],[0,1,0],[0,1,0],[0,1,0]],
    Z: [[1,1,1],[0,0,1],[0,1,0],[1,0,0],[1,1,1]],
    a: [
        [0,0,0],
        [0,1,1],
        [1,0,1],
        [1,1,1],
        [1,0,1]
    ],
    b: [
        [1,0,0],
        [1,1,0],
        [1,0,1],
        [1,0,1],
        [1,1,0]
    ],
    c: [
        [0,0,0],
        [0,1,1],
        [1,0,0],
        [1,0,0],
        [0,1,1]
    ],
    d: [
        [0,0,1],
        [0,1,1],
        [1,0,1],
        [1,0,1],
        [0,1,1]
    ],
    e: [
        [0,0,0],
        [0,1,1],
        [1,1,1],
        [1,0,0],
        [0,1,1]
    ],
    f: [
        [0,1,1],
        [1,0,0],
        [1,1,0],
        [1,0,0],
        [1,0,0]
    ],
    g: [
        [0,0,0],
        [0,1,1],
        [1,0,1],
        [0,1,1],
        [1,1,0]
    ],
    h: [
        [1,0,0],
        [1,1,0],
        [1,0,1],
        [1,0,1],
        [1,0,1]
    ],
    i: [
        [0,1,0],
        [0,0,0],
        [1,1,0],
        [0,1,0],
        [1,1,1]
    ],
    j: [
        [0,0,1],
        [0,0,0],
        [0,0,1],
        [0,0,1],
        [1,1,0]
    ],
    k: [
        [1,0,0],
        [1,0,1],
        [1,1,0],
        [1,0,1],
        [1,0,1]
    ],
    l: [
        [1,1,0],
        [0,1,0],
        [0,1,0],
        [0,1,0],
        [1,1,1]
    ],
    m: [
        [0,0,0],
        [1,1,0],
        [1,0,1],
        [1,0,1],
        [1,0,1]
    ],
    n: [
        [0,0,0],
        [1,1,0],
        [1,0,1],
        [1,0,1],
        [1,0,1]
    ],
    o: [
        [0,0,0],
        [0,1,0],
        [1,0,1],
        [1,0,1],
        [0,1,0]
    ],
    p: [
        [0,0,0],
        [1,1,0],
        [1,0,1],
        [1,1,0],
        [1,0,0]
    ],
    q: [
        [0,0,0],
        [0,1,1],
        [1,0,1],
        [0,1,1],
        [0,0,1]
    ],
    r: [
        [0,0,0],
        [1,1,0],
        [1,0,1],
        [1,0,0],
        [1,0,0]
    ],
    s: [
        [0,0,0],
        [0,1,1],
        [1,1,0],
        [0,0,1],
        [1,1,0]
    ],
    t: [
        [0,1,0],
        [1,1,1],
        [0,1,0],
        [0,1,0],
        [0,1,1]
    ],
    u: [
        [0,0,0],
        [1,0,1],
        [1,0,1],
        [1,0,1],
        [0,1,1]
    ],
    v: [
        [0,0,0],
        [1,0,1],
        [1,0,1],
        [0,1,0],
        [0,1,0]
    ],
    w: [
        [0,0,0],
        [1,0,1],
        [1,0,1],
        [1,1,1],
        [1,0,1]
    ],
    x: [
        [0,0,0],
        [1,0,1],
        [0,1,0],
        [0,1,0],
        [1,0,1]
    ],
    y: [
        [0,0,0],
        [1,0,1],
        [0,1,0],
        [0,1,0],
        [1,1,0]
    ],
    z: [
        [0,0,0],
        [1,1,1],
        [0,0,1],
        [0,1,0],
        [1,1,1]
    ],
    // digits 0–9
    '0': [[1,1,1],[1,0,1],[1,0,1],[1,0,1],[1,1,1]],
    '1': [[0,1,0],[1,1,0],[0,1,0],[0,1,0],[1,1,1]],
    '2': [[1,1,0],[0,0,1],[0,1,0],[1,0,0],[1,1,1]],
    '3': [[1,1,0],[0,0,1],[0,1,0],[0,0,1],[1,1,0]],
    '4': [[1,0,1],[1,0,1],[1,1,1],[0,0,1],[0,0,1]],
    '5': [[1,1,1],[1,0,0],[1,1,0],[0,0,1],[1,1,0]],
    '6': [[0,1,1],[1,0,0],[1,1,0],[1,0,1],[0,1,0]],
    '7': [[1,1,1],[0,0,1],[0,1,0],[0,1,0],[0,1,0]],
    '8': [[0,1,0],[1,0,1],[0,1,0],[1,0,1],[0,1,0]],
    '9': [[0,1,0],[1,0,1],[0,1,1],[0,0,1],[1,1,0]],

    // basic punctuation and symbols
    '!': [[0,1,0],[0,1,0],[0,1,0],[0,0,0],[0,1,0]],
    '?': [[1,1,0],[0,0,1],[0,1,0],[0,0,0],[0,1,0]],
    '.': [[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,1,0]],
    ',': [[0,0,0],[0,0,0],[0,0,0],[0,1,0],[1,0,0]],
    ':': [[0,0,0],[0,1,0],[0,0,0],[0,1,0],[0,0,0]],
    '-': [[0,0,0],[0,0,0],[1,1,1],[0,0,0],[0,0,0]],
    '+': [[0,0,0],[0,1,0],[1,1,1],[0,1,0],[0,0,0]],
    '=': [[0,0,0],[1,1,1],[0,0,0],[1,1,1],[0,0,0]],
    '(': [[0,0,1],[0,1,0],[0,1,0],[0,1,0],[0,0,1]],
    ')': [[1,0,0],[0,1,0],[0,1,0],[0,1,0],[1,0,0]],
    '[': [[0,1,1],[0,1,0],[0,1,0],[0,1,0],[0,1,1]],
    ']': [[1,1,0],[0,1,0],[0,1,0],[0,1,0],[1,1,0]],
    ' ': [[0,0,0],[0,0,0],[0,0,0],[0,0,0],[0,0,0]]
};

        const imagescale = document.getElementById('imagescale');
        document.getElementById('scaleSlider').addEventListener("change", function (e) {
            const scale = parseFloat(document.getElementById("scaleSlider").value);
            imagescale.textContent = `${scale}`
        });

        const image = document.getElementById('dynamicImage');
    const imagecontainer = document.getElementById('imagecontainer');
     const imagebutton = document.getElementById('imagebutton');
    const textcontainer = document.getElementById('textcontainer');
    const textbutton = document.getElementById('textbutton');
    

    
    let selectedimage = null;
   


    document.getElementById("imageUpload").addEventListener("change", function (e) {
      const file = e.target.files[0];
     
      if (!file) return;
      selectedElement = 'image';
      let img = new Image();
      img.onload = () => {
        selectedimage = img;
        image.src = img.src;
      };
      const reader = new FileReader();
      reader.onload = (event) => (img.src = event.target.result);
      reader.readAsDataURL(file);
    });
   

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // Adjust voxelSize here if desired; for example, set a target number of voxels:
    const targetVoxelsX = 80;
    const targetVoxelsY = 60;
   voxelSize = Math.floor(Math.min(canvas.width / targetVoxelsX, canvas.height / targetVoxelsY));
 let cols3 = Math.floor(canvas.width / voxelSize);
    cols = cols3 + 0.5;
    rows = Math.floor(canvas.height / voxelSize);

    // Optional: Recreate or adjust your grid based on new rows/cols
    initializeGrid();
    
}

window.addEventListener("resize", resizeCanvas);
resizeCanvas(); // initial setup
    function drawTextOnGrid(text, startRow, startCol, elementName, fontSize = 1) {
    const charWidth = 3;
    const charHeight = 5;
    const spacing = 1;

    text = text.toString(); // Ensure it’s a string
    let offsetCol = startCol;

    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        const pixels = fontMap[char] || fontMap[' '];

        for (let r = 0; r < charHeight; r++) {
            for (let c = 0; c < charWidth; c++) {
                if (pixels[r][c]) {
                    // Scale each pixel by fontSize
                    for (let dr = 0; dr < fontSize; dr++) {
                        for (let dc = 0; dc < fontSize; dc++) {
                            const gridRow = startRow + r * fontSize + dr;
                            const gridCol = offsetCol + c * fontSize + dc;

                            if (grid[gridRow] && grid[gridRow][gridCol]) {
                                grid[gridRow][gridCol].element = elementName;
                            }
                        }
                    }
                }
            }
        }
        offsetCol += (charWidth * fontSize) + spacing; // Advance to next char
    }
}

function imageselection() {
  // Hide text container if it's shown
  if (textcontainer.classList.contains('show')) {
    textcontainer.classList.remove('show');
    textbutton.textContent = "<";
  }

  // Toggle image container
  const isShown = imagecontainer.classList.contains('show');
  imagecontainer.classList.toggle('show');
  imagebutton.textContent = isShown ? "<" : "^";
}

function textselection() {
  // Hide image container if it's shown
  if (imagecontainer.classList.contains('show')) {
    imagecontainer.classList.remove('show');
    imagebutton.textContent = "<";
  }

  // Toggle text container
  const isShown = textcontainer.classList.contains('show');
  textcontainer.classList.toggle('show');
  textbutton.textContent = isShown ? "<" : "^";
}

    let useCustomColor = false;

    function drawImageToGrid(img, startRow, startCol) {
    const scale = parseFloat(document.getElementById("scaleSlider").value);

    // Final drawn image size (in grid cells)
    const outputWidth = Math.floor(img.width * scale);
    const outputHeight = Math.floor(img.height * scale);

    // Step 1: Downscale image to match output size
    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = outputWidth;
    tempCanvas.height = outputHeight;
    const ctx = tempCanvas.getContext("2d");
    ctx.drawImage(img, 0, 0, outputWidth, outputHeight);

    const imageData = ctx.getImageData(0, 0, outputWidth, outputHeight).data;

    // Step 2: Draw each pixel to 1 grid cell (pixel-art style)
    for (let y = 0; y < outputHeight; y++) {
    for (let x = 0; x < outputWidth; x++) {
        const index = (y * outputWidth + x) * 4;
        const r = imageData[index];
        const g = imageData[index + 1];
        const b = imageData[index + 2];
        const gridY = startRow + y;
        const gridX = startCol + x;

        if (grid[gridY] && grid[gridY][gridX]) {
            if (useCustomColor) {
                grid[gridY][gridX].element = "coloredvoxel";
                grid[gridY][gridX].customcolor = `rgb(${r},${g},${b})`;
            } else {
                const elementName = findClosestElement(r, g, b);
                if (elementName) {
                    grid[gridY][gridX].element = elementName;
                }
            }
            grid[gridY][gridX].stop = true;
        }
    }
}

}
let selectedMedia = null;

document.getElementById("mediaInput").addEventListener("change", function (e) {
    const file = e.target.files[0];
    if (!file) return;

    selectedMedia = file;


    // Optional: auto-switch tool or preview
    selectedElement = 'media';
});


    // We now always pass a URL string
    function playMediaToGrid(fileOrUrl, row, col, scale) {
    const url = (fileOrUrl instanceof File) ? URL.createObjectURL(fileOrUrl) : fileOrUrl;
    playVideoToGrid(url, row, col, scale);

}


function initializeVideoFrameToGrid(video, row, col, scale) {
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;

    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    drawFrameToGrid(canvas, row, col, scale, true); // `true` for initialization
}
function drawFrameToGrid(image, startRow, startCol, scale, isInit = false) {
    const outputWidth = Math.floor(image.width * scale);
    const outputHeight = Math.floor(image.height * scale);

    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = outputWidth;
    tempCanvas.height = outputHeight;
    const ctx = tempCanvas.getContext("2d");
    ctx.drawImage(image, 0, 0, outputWidth, outputHeight);

    const imageData = ctx.getImageData(0, 0, outputWidth, outputHeight).data;

    for (let y = 0; y < outputHeight; y++) {
        for (let x = 0; x < outputWidth; x++) {
            const index = (y * outputWidth + x) * 4;
            const r = imageData[index];
            const g = imageData[index + 1];
            const b = imageData[index + 2];
            const gridY = startRow + y;
            const gridX = startCol + x;

            const cell = grid[gridY]?.[gridX];
            if (!cell) continue;

            if (isInit) {
                if (cell.element === 'empty' && !cell.initialized) {
                    cell.element = "coloredvoxel";
                    cell.customcolor = `rgb(${r},${g},${b})`;
                    cell.stop = true;
                    
                }
            } else {
                if (cell.element === 'coloredvoxel') {
                    cell.customcolor = `rgb(${r},${g},${b})`;
                }
            }
        }
    }
}
const screenStreams = {};        // All captured streams by ID
let screenIdCounter = 0;         // Unique ID generator
let selectedScreenStream = null; // The currently selected one
async function captureNewScreen() {
    try {
        const stream = await navigator.mediaDevices.getDisplayMedia({
            video: true,
            audio: false
        });

        const id = `screen_${screenIdCounter++}`;
        screenStreams[id] = stream;
        selectedScreenStream = id; // Set as the currently selected stream
        console.log(`Captured screen stream with ID: ${id}`);
    } catch (err) {
        console.error("Screen capture failed:", err);
        alert("Screen sharing permission was denied.");
    }
}

let videonuke = false;
function playVideoToGrid(videoSrc, row, col, scale) {
    const video = document.createElement("video");
    video.src = videoSrc;
    video.muted = true;
    video.loop = true;
    video.play();

    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    video.addEventListener("loadeddata", () => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        // One-time initialization
        initializeVideoFrameToGrid(video, row, col, scale);

        // Loop only updates existing coloredvoxels
        function drawLoop() {

            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            if(videonuke === true){
                drawImageToGrid(canvas, row, col);
            } else{
                drawFrameToGrid(canvas, row, col, scale, false);

            }
            requestAnimationFrame(drawLoop);
        }

        drawLoop();
    });
}
function placeSelectedScreenToGrid(row, col, scale) {
    if (!selectedScreenStream || !screenStreams[selectedScreenStream]) {
        console.warn("No selected screen stream to place.");
        return;
    }

    const stream = screenStreams[selectedScreenStream];
    const video = document.createElement("video");
    video.srcObject = stream;
    video.muted = true;
    video.play();

    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");

    video.addEventListener("loadedmetadata", () => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;

        drawFrameToGrid(canvas, row, col, scale, true);

        function drawLoop() {
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            drawFrameToGrid(canvas, row, col, scale, false);
            requestAnimationFrame(drawLoop);
        }

        drawLoop();
    });
}



async function playGifToGrid(gifUrl, row, col) {
    const gif = await fetch(gifUrl).then(res => res.arrayBuffer());
    const parsedGif = window.gifuct.parseGIF(gif);
    const frames = window.gifuct.decompressFrames(parsedGif, true);

    let i = 0;
    function renderNextFrame() {
        const frame = frames[i];
        const canvas = document.createElement("canvas");
        canvas.width = frame.dims.width;
        canvas.height = frame.dims.height;
        const ctx = canvas.getContext("2d");

        const imageData = ctx.createImageData(canvas.width, canvas.height);
        imageData.data.set(frame.patch);
        ctx.putImageData(imageData, 0, 0);

        drawFrameToGrid(canvas, row, col);

        i = (i + 1) % frames.length;
        setTimeout(renderNextFrame, frame.delay || 100);
    }

    renderNextFrame();
}

function findClosestElement(r, g, b) {
    let closest = null;
    let closestDist = Infinity;

    for (const elementKey in elements) {
        const color = elements[elementKey].color;
        if (!color) continue;

        const er = parseInt(color.slice(1, 3), 16);
        const eg = parseInt(color.slice(3, 5), 16);
        const eb = parseInt(color.slice(5, 7), 16);

        const dist = Math.hypot(er - r, eg - g, eb - b);
        if (dist < closestDist) {
            closestDist = dist;
            closest = elementKey;
        }
    }

    return closest;
}

let apples = false;
function undo() {
    for(let row = 0; row < rows; row++){
        for(let col = 0; col < cols; col++){
            if(grid[row][col].lastelement){
        grid[row][col] = grid[row][col].lastelement;
            }
    }
    }
}
document.addEventListener('keydown', function (event) {
    if (event.ctrlKey && event.key === 'z') {
      undo();
    }
});
function updateFaucet(row, col) {
    const cell = grid[row][col];
    if (!grid[row] || !grid[row][col]) return;

    let elementFound = null;

    // Only check direct neighbors (no diagonals)
    const directions = [
        [-1, 0], // Up
        [1, 0],  // Down
        [0, -1], // Left
        [0, 1]   // Right
    ];

    // Find first non-empty, non-faucet element
    for (let [dRow, dCol] of directions) {
        const newRow = row + dRow;
        const newCol = col + dCol;
        if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element !== 'faucet' && grid[newRow][newCol].element !== 'empty') {
            cell.storedElement = grid[newRow][newCol].element;
            break;
        }
    }

    // If found, set all 4 neighbors to that element
    if (cell.storedElement) {
        for (let [dRow, dCol] of directions) {
            const newRow = row + dRow;
            const newCol = col + dCol;
            if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
                grid[newRow][newCol].element = cell.storedElement;
            }
        }
    }
}


function snakegame() {
    apples = false; // reset before checking

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            if (grid[row][col].element === 'apple') {
                apples = true;
            }
        }
    }

    // If no apples found, spawn with small chance
    if (!apples) {
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                if (Math.random() < 0.001 && grid[row][col].element === 'empty') {
                    grid[row][col].element = 'apple';
                    apples = true;
                    
                }
            }
        }
    }
}

function isStrawEnd(row, col) {
    const directions = [
        { row: -1, col: 0 },
        { row: 1, col: 0 },
        { row: 0, col: -1 },
        { row: 0, col: 1 }
    ];

    let connections = 0;

    for (const dir of directions) {
        const r = row + dir.row;
        const c = col + dir.col;
        if (
            grid[r] &&
            grid[r][c] &&
            grid[r][c].element === 'straw'
        ) {
            connections++;
        }
    }

    return connections === 1;
}


function frogjump(cell, row, col){
    
    if(Math.random() < 0.5){
     newCol = col + 1;
    } else { newCol = col - 1;}
    if(newCol > 0 && newCol < cols - 1){
        if(row > 0 && grid[row-1][col].element === 'empty'  && grid[row-1][newCol].element === 'empty'){
            grid[row-1][newCol].element = 'frog';
            grid[row-1][newCol].delay = -4;

            initializeCell(row, col, 'empty');
        }
    }


}
function fishjump(cell, row, col){

if(Math.random() < 0.5){
 newCol = col + 1;
} else if(Math.random() < 0.5) { newCol = col - 1;} else {newCol = col;}
if(newCol > 0 && newCol < cols - 1){
    if(row > 0 && grid[row-1][col].element === 'empty'  && grid[row-1][newCol].element === 'empty'){
        grid[row-1][newCol].element = 'fish';
        grid[row-1][newCol].delay = -4;

        initializeCell(row, col, 'empty');
    }
}


}


function getStrawNetwork(startRow, startCol) {
    const visited = new Set();
    const queue = [{ row: startRow, col: startCol }];
    const network = [];

    while (queue.length > 0) {
        const { row, col } = queue.shift();
        const key = `${row},${col}`;
        if (visited.has(key)) continue;
        visited.add(key);
        network.push({ row, col });

        const directions = [
            { row: -1, col: 0 },
            { row: 1, col: 0 },
            { row: 0, col: -1 },
            { row: 0, col: 1 }
        ];

        for (const dir of directions) {
            const r = row + dir.row;
            const c = col + dir.col;
            const k = `${r},${c}`;

            if (
                grid[r] &&
                grid[r][c] &&
                grid[r][c].element === 'straw' &&
                !visited.has(k)
            ) {
                queue.push({ row: r, col: c });
            }
        }
    }

    return network;
}


function shockwave(startRow, startCol) {
    let queue = [{ row: startRow, col: startCol, radius: 0 }];
    let visited = new Set();
    
    // Function to apply the wave effect slowly
    function stepWave() {
        if (queue.length === 0) return;

        let nextQueue = [];
        let currentRadius = queue[0].radius + 1; // Increase radius each step

        for (let { row, col, radius } of queue) {
            let key = `${row},${col}`;
            if (visited.has(key)) continue;
            visited.add(key);

            // Apply effect to this cell (center of the wave)
            applyWaveEffect(row, col, radius);

            // Check if the current cell should follow the shockwave
            if (grid[row][col].element !== 'empty') {
                // Calculate the direction vector away from the shockwave's origin
                const dx = row - startRow;
                const dy = col - startCol;
              

                // Normalize the direction vector
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                    const stepRow = Math.round(dx / distance); // Step away from shockwave's origin
                    const stepCol = Math.round(dy / distance); // Step away from shockwave's origin

                    let newRow = row + stepRow;
                    let newCol = col + stepCol;

                    // Keep pushing until the object reaches a valid empty space
                    while (newRow < rows - 1 && newRow > 0 && newCol > 0 && newCol < cols - 1) {
                        // Only push the object if the new position is empty
                        if (grid[newRow] && grid[newRow][newCol].element === 'empty') {
                            // Slowly move the object by one step per frame
                            if (!grid[newRow][newCol].shockwaveMoving) {
                                grid[newRow][newCol].shockwaveMoving = true;
                                grid[newRow][newCol].shockwaveDelay = 0;
                            }

                            // Increase the delay each time until it reaches the maximum value
                            if (grid[newRow][newCol].shockwaveDelay < 5) {  // Adjust delay for slower movement
                                grid[newRow][newCol].shockwaveDelay++;
                                continue; // Skip this frame to keep the object in place
                            }

                            // Move the object after delay is reached
                            grid[newRow][newCol].shockwaveDelay = 0;
                            grid[newRow][newCol].element = grid[row][col].element;
                            grid[row][col].element = 'empty';
                            grid[row][col].shockwave = false;
                            grid[row][col].shockwaveMoving = false;
                           
                            // Set the new position's shockwave property
                            grid[newRow][newCol].shockwave = true;

                            // Update position for continuous pushing
                            row = newRow;
                            col = newCol;
                            break;
                        } else {
                            // If the position is occupied, try to push the object blocking the path
                            let block = grid[newRow][newCol];
                            if (block.shockwave === true) {
                                const blockDx = newRow - startRow;
                                const blockDy = newCol - startCol;
                                const blockDistance = Math.sqrt(blockDx * blockDx + blockDy * blockDy);

                                if (blockDistance > 0) {
                                    const blockStepRow = Math.round(blockDx / blockDistance);
                                    const blockStepCol = Math.round(blockDy / blockDistance);

                                    let blockNewRow = newRow + blockStepRow;
                                    let blockNewCol = newCol + blockStepCol;

                                    // Only push the blocking object if the space is empty and valid
                                    if (blockNewRow < rows - 1 && blockNewRow > 0 && blockNewCol > 0 && blockNewCol < cols - 1) {
                                        if (grid[blockNewRow] && grid[blockNewRow][blockNewCol].element === 'empty') {
                                            // Move the blocking object
                                            grid[blockNewRow][blockNewCol].element = block.element;
                                            grid[newRow][newCol].element = 'empty';
                                            block.shockwave = false;
                                          

                                            // Set the new position's properties
                                            grid[blockNewRow][blockNewCol].shockwave = true;

                                            // Now move the original object after the blocking object
                                            grid[newRow][newCol].element = grid[row][col].element;
                                            grid[row][col].element = 'empty';
                                           

                                            // Continue pushing the object
                                            row = newRow;
                                            col = newCol;
                                            break;
                                        }
                                    }
                                }
                            }
                        }

                        // Update the newRow and newCol to continue pushing
                        newRow += stepRow;
                        newCol += stepCol;
                    }
                }
            }

            // Expand outward along the circumference of a circle
            for (let angle = 0; angle < 360; angle++) { // For a smooth circle, use smaller increments
                let radian = (angle * Math.PI) / 180;
                let newRow = Math.round(startRow + currentRadius * Math.sin(radian));
                let newCol = Math.round(startCol + currentRadius * Math.cos(radian));
                let newKey = `${newRow},${newCol}`;

                // Only add points on the circumference if they haven't been visited
                if (!visited.has(newKey)) {
                    nextQueue.push({ row: newRow, col: newCol, radius: currentRadius });
                }
            }
        }

        queue = nextQueue;
        if (queue.length > 0) requestAnimationFrame(stepWave);
    }

    stepWave();
}
function shockwavefire(startRow, startCol) {
    let queue = [{ row: startRow, col: startCol, radius: 0 }];
    let visited = new Set();

    // Function to apply the shockwave effect
    function stepWave() {
        if (queue.length === 0) return;

        let nextQueue = [];
        let currentRadius = queue[0].radius + 1; // Increase radius each step

        for (let { row, col, radius } of queue) {
            let key = `${row},${col}`;
            if (visited.has(key)) continue;
            visited.add(key);

            // Apply the shockwave effect to this cell (without moving it)
            applyWaveEffect2(row, col, radius);

            // Expand outward in a circular pattern to affect adjacent cells
            for (let angle = 0; angle < 360; angle++) {
                let radian = (angle * Math.PI) / 180;
                let newRow = Math.round(startRow + currentRadius * Math.sin(radian));
                let newCol = Math.round(startCol + currentRadius * Math.cos(radian));
                let newKey = `${newRow},${newCol}`;

                // Only add points on the circumference if they haven't been visited
                if (!visited.has(newKey)) {
                    nextQueue.push({ row: newRow, col: newCol, radius: currentRadius });
                }
            }
        }

        queue = nextQueue;
        if (queue.length > 0) requestAnimationFrame(stepWave);
    }

    stepWave();
}

function applyWaveEffect(row, col, radius) {
    if (row >= 0 && row < grid.length && col >= 0 && col < grid[0].length) {
        grid[row][col].shockwave = true;
        grid[row][col].shockwavecolor = true;
    }
}

function applyWaveEffect2(row, col, radius) {
    if (row >= 0 && row < grid.length && col >= 0 && col < grid[0].length) {
     
        grid[row][col].shockwavecolor2 = true;
       
    }
}

function teleportWithinRange(row, col, range) {
    let attempts = 0;
    let maxAttempts = 20; // Prevent infinite loop
    let newRow, newCol;

    while (attempts < maxAttempts) {
        newRow = Math.max(0, Math.min(rows - 1, row + Math.floor(Math.random() * (2 * range + 1)) - range));
        newCol = Math.max(0, Math.min(cols - 1, col + Math.floor(Math.random() * (2 * range + 1)) - range));

        if (grid[newRow][newCol].element === "empty") {
            grid[newRow][newCol] = grid[row][col]; // Move the cell
            grid[row][col] = { element: "empty" }; // Set old position to empty
            return;
        }

        attempts++;
    }
    // If no empty spot was found, just leave the cell in place
}

function teleportWithinRange2(row, col, range) {
  
  let attempts = 0;
  let maxAttempts = 20; // Prevent infinite loop
  let newRow, newCol;

  while (attempts < maxAttempts) {
      // Move only upwards (row will decrease, never increase)
      newRow = Math.max(0, Math.min(row, row + Math.floor(Math.random() * (range + 1)))); 
      newCol = Math.max(0, Math.min(col, col + Math.floor(Math.random() * (2 * range + 1)) - range));

      if (grid[newRow][newCol].element === "empty") {
          grid[newRow][newCol] = grid[row][col]; // Move the cell
          grid[row][col] = { element: "empty" }; // Set old position to empty
          return;
      }

      attempts++;
  
}
  // If no empty spot was found, just leave the cell in place
}


        
        let cursorSize = 150; // Adjust this to make the cursor bigger or smaller
        function cursorb(cell, row, col){

     const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        // Check for adjacent water
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'empty' 
                        );
                        // Transform dark lava into stone if adjacent to water
                        if (Adjacent) {
                           cell.cursorColor = '#000000';
                        } else cell.cursorColor = '#FEFEFE';
        }
      
     
  
        function drawCursorPolygon() {
    ctx.save();
    ctx.beginPath();

    let cursorCells = [];
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            if (grid[row][col].element === 'cursor') {
                cursorCells.push({ x: col * voxelSize, y: row * voxelSize });
            }
        }
    }

    if (cursorCells.length === 0) return;

    let startX = cursorCells[0].x + voxelSize / 2; // Center the cursor on the grid element
    let startY = cursorCells[0].y + voxelSize / 2; // Center the cursor on the grid element

    let angle = Math.atan2(startY - hmrow * voxelSize, startX - hmcol * voxelSize);

    // Define cursor arrow shape relative to (startX, startY)
    ctx.moveTo(startX, startY); // The tip of the cursor is now centered
    ctx.lineTo(startX + cursorSize * Math.cos(angle + Math.PI / 6), startY + cursorSize * Math.sin(angle + Math.PI / 6));
    ctx.lineTo(startX + (cursorSize / 2) * Math.cos(angle), startY + (cursorSize / 2) * Math.sin(angle));
    ctx.lineTo(startX + cursorSize * Math.cos(angle - Math.PI / 6), startY + cursorSize * Math.sin(angle - Math.PI / 6));
    ctx.closePath();

    ctx.fillStyle = 'rgba(255, 255, 255, 0)';
    ctx.fill();
    ctx.restore();

    // Check for elements inside the polygon and change them
    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            let x = col * voxelSize;
            let y = row * voxelSize;

            if (ctx.isPointInPath(x, y)) {
                if (grid[row][col].element !== 'cursor') {
                    grid[row][col].element = 'cursorb';
                    grid[row][col].age = 0;
                }
            }
        }
    }
}



function tornado(cell, row, col) {
    const UexplosionRadius = 10; // Define the explosion radius

    // Clamp row and column ranges to stay within the grid bounds
    const ustartRow = Math.max(0, row - UexplosionRadius);
    const uendRow = Math.min(rows - 1, row);
    const ustartCol = Math.max(0, col - UexplosionRadius);
    const uendCol = Math.min(cols - 1, col + UexplosionRadius);

    for (let r = uendRow; r >= ustartRow; r--) { // Iterate upwards
        let maxColOffset = row - r; // Expands as r decreases (moving up)

        let leftBound = Math.max(0, col - maxColOffset);
        let rightBound = Math.min(cols - 1, col + maxColOffset);

        for (let c = leftBound; c <= rightBound; c++) { 
            if (r >= 0 && r < rows && c >= 0 && c < cols) { // Final check to ensure in bounds
                if (grid[r][c] && grid[r][c].element !== 'tornado' &&
                    (grid[r][c].element === 'empty' || grid[r][c].element === 'tornado2')) {
                    grid[r][c].element = 'tornado2'; 
                    grid[r][c].age = 0; 
                    grid[r][c].firemove = false;
                }
            }
        }
    }
}

    let humanMovementDelay = 10;
    function lightning(cell, row, col) {
            
           
            // Horizontal movement directions (left and right)
            const directions = [
                { row: 1, col: -1},
                {row: 1, col: 1}
            ];
        
           
               
               
            
        
            // Randomly choose a direction (horizontal or up if possible)
            const frandomDirection = directions[Math.floor(Math.random() * directions.length)];
            const newRow = row + frandomDirection.row;
            const newCol = col + frandomDirection.col;
        
            // Check if the target cell is empty before moving the steam
            if(cell.lightning===0){
            if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty' || grid[newRow][newCol].element === 'lightning' || grid[newRow][newCol].element === 'plasma' || grid[newRow][newCol].element === 'flash') {
                if(grid[newRow][newCol].element !== 'stormcloud'){
                grid[newRow][newCol].element = 'lightning';
                   cell.lightning = 1;
                } else cell.element = 'empty';
                
                
            } else  if(grid[newRow][newCol].element !== 'stormcloud') cell.element='lexplosion';
           }
           }
         

        
        function handlepigMovement(cell, row, col) {
     if (!cell.delay) cell.delay = 0; // Initialize delay counter if not defined
 
     // Check for adjacent lava cells within a 5-cell radius
     const lavaNearby = (r, c) => {
         return grid[r] && grid[r][c] && elements[grid[r][c].element].unsafe;
     };
 
     let hasLavaNearby = false;
     let lavaDirection = null;
 
     // Check a 5-cell radius (11x11 area centered on the human)
     for (let r = -5; r <= 5; r++) {
         for (let c = -5; c <= 5; c++) {
             const newRow = row + r;
             const newCol = col + c;
             if (Math.abs(r) + Math.abs(c) <= 5 && lavaNearby(newRow, newCol)) {
                 hasLavaNearby = true;
                 // Determine the direction of the lava
                 if (r < 0) lavaDirection = 'down'; // Lava is above
                 else if (r > 0) lavaDirection = 'up'; // Lava is below
                 else if (c < 0) lavaDirection = 'right'; // Lava is left
                 else if (c > 0) lavaDirection = 'left'; // Lava is right
                 break;
             }
         }
         if (hasLavaNearby) break; // Exit early if lava is found
     }
 
     // Determine movement delay based on proximity to lava
     const movementDelay = hasLavaNearby ? humanMovementDelay / 10 : humanMovementDelay; // Move faster if near lava
 
     // Increment delay
     cell.delay++;
 
     // Check if the human can fall due to gravity
     if (row < rows - 1 && grid[row + 1][col].element === 'empty') {
         // Move down
         grid[row + 1][col].element = 'pig'; // Move the human to the cell below
         cell.element = 'empty'; // Set the old cell to empty
         cell.delay = 0; // Reset delay after moving
         return; // Exit the function after moving down
     }
 
     // If the human cannot fall, check for lateral movement
     if (cell.delay >= movementDelay) { // Check if delay has passed
         const directions = [
             { row: 0, col: -1 }, // Left
             { row: 0, col: 1 },  // Right
         ];
 
         // Determine the opposite direction based on lava direction
         let oppositeDirection = null;
         if (lavaDirection === 'up') oppositeDirection = { row: 1, col: 0 }; // Move down
         else if (lavaDirection === 'down') oppositeDirection = { row: -1, col: 0 }; // Move up
         else if (lavaDirection === 'left') oppositeDirection = { row: 0, col: 1 }; // Move right
         else if (lavaDirection === 'right') oppositeDirection = { row: 0, col: -1 }; // Move left
         
         // If there's a detected lava direction, move in the opposite direction
         if (oppositeDirection) {
             const newRow = row + oppositeDirection.row;
             const newCol = col - oppositeDirection.col;
 
             // Check if the new position is within bounds and empty
             if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && grid[newRow][newCol].element === 'empty') {
                 grid[newRow][newCol].element = 'pig'; // Move the human to the new cell
                 cell.element = 'empty'; // Set the old cell to empty
                 cell.delay = 0; // Reset delay after moving
             } else {
                 // If the cell is not empty, check if there's an empty space above to jump
                 if (row > 0 && newRow < rows && newCol >= 0 && newCol < cols && grid[newRow][newCol].element !== 'empty' && grid[row - 1][newCol].element === 'empty') {
                     grid[row - 1][newCol].element = 'pig'; // Move the human to the cell above the obstacle
                     cell.element = 'empty'; // Set the old cell to empty
                     cell.delay = 0; // Reset delay after jumping
                 } else {
                     // If unable to move or jump, reset delay
                     cell.delay = 0; // Reset delay if unable to move
                 }
             }
         } else {
             // If no lava is detected, move randomly
             const randomDirection = directions[Math.floor(Math.random() * directions.length)];
             const newRow = row + randomDirection.row;
             const newCol = col + randomDirection.col;
 
             // Check if the new position is within bounds and empty
             if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && grid[newRow][newCol].element === 'empty') {
                 grid[newRow][newCol].element = 'pig'; // Move the human to the new cell
                 cell.element = 'empty'; // Set the old cell to empty
                 cell.delay = 0; // Reset delay after moving
             } else {
                 // If the cell is not empty, check if there's an empty space above to jump
                 if (row > 0 && newRow < rows && newCol >= 0 && newCol < cols && grid[newRow][newCol].element !== 'empty' && grid[row - 1][newCol].element === 'empty') {
                     grid[row - 1][newCol].element = 'pig'; // Move the human to the cell above the obstacle
                     cell.element = 'empty'; // Set the old cell to empty
                     cell.delay = 0; // Reset delay after jumping
                 } else {
                     // If unable to move or jump, reset delay
                     cell.delay = 0; // Reset delay if unable to move
                 }
             }
         }
     }
 }
      
 


        function liquid(row, col) {
            elements[grid[row][col].element].liquid = true;
        }
      

        function placeShape(row, col, shape, noempty = false) {
    for (let shapeRow = 0; shapeRow < shape.length; shapeRow++) {
        for (let shapeCol = 0; shapeCol < shape[shapeRow].length; shapeCol++) {
            let cellData = shape[shapeRow][shapeCol];

            if(noempty === false){
                // Ensure the position is within the grid bounds
                if (row + shapeRow < rows && col + shapeCol < cols) {
                    if (typeof cellData === 'object' && cellData.element === 'coloredvoxel') {
                       
                        grid[row + shapeRow][col + shapeCol] = {
                            element: cellData.element,
                            customcolor: cellData.color || "#FFFFFF", // Default to white if color is missing
                            delay: 0
                        };
                        initializeCell(row + shapeRow, col + shapeCol, cellData.element, cellData.color);
                    } else if (typeof cellData === 'string') {
                       
                        initializeCell(row + shapeRow, col + shapeCol);

                        grid[row + shapeRow][col + shapeCol] = { 
                            element: cellData,
                            delay: 0
                        };
                        initializeCell(row + shapeRow, col + shapeCol, cellData);
                    }
                }
            
                } else{
                      // Ensure the position is within the grid bounds
                if (row + shapeRow < rows && col + shapeCol < cols) {
                    if(grid[row + shapeRow][col + shapeCol].element === 'empty'){
                    if (typeof cellData === 'object' && cellData.element === 'coloredvoxel') {
                       
                        grid[row + shapeRow][col + shapeCol] = {
                            element: cellData.element,
                            customcolor: cellData.color || "#FFFFFF", // Default to white if color is missing
                            delay: 0
                        };
                        initializeCell(row + shapeRow, col + shapeCol, cellData.element, cellData.color);
                    } else if (typeof cellData === 'string') {
                       
                        initializeCell(row + shapeRow, col + shapeCol);

                        grid[row + shapeRow][col + shapeCol] = { 
                            element: cellData,
                            delay: 0
                        };
                        initializeCell(row + shapeRow, col + shapeCol, cellData);
                    }
                }
            }
                }
            
            }
    }
}

const wasteland = [['radiation', 'radiationo', 'radiationo', 'radiation', 'radiationo', 'radiation', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'radiation', 'radiation', 'radiationo', 'radiation', 'radiationo', 'radiationo', 'radiation', 'radiation', 'radiationo', 'empty', 'empty', 'radiationo', 'radiationo', 'radiation', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'radiation', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'radiation', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'radiation', 'radiationo', 'empty', 'empty', 'empty'],
['radiationo', 'empty', 'empty', 'radiationo', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'radiationo', 'empty', 'radiationo', 'empty', 'empty', 'radiationo', 'radiationo', 'empty', 'empty', 'radiationo', 'radiation', 'radiationo', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'radiation', 'radiationo', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['ash', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['radiation', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'radiation', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'radiation', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'radiation', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'radiation', 'radiationo', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'radiationo', 'radiation', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'radiation', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'ash', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'radiation', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'ash', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'ash', 'coal', 'coal', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'radiation', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'ash', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'coal', 'coal', 'coal', 'coal', 'coal', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'ash', 'coal', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'ash', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'coal', 'coal', 'coal', 'coal', 'coal', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'ash', 'coal', 'coal', 'coal', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'charcoal', 'ash', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'coal', 'coal', 'coal', 'coal', 'coal', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'coal', 'coal', 'coal', 'coal', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'charcoal', 'charcoal', 'charcoal', 'empty', 'ash', 'empty', 'empty', 'empty', 'empty', 'empty', 'coal', 'coal', 'coal', 'coal', 'coal', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'radiation', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'radiation', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'coal', 'coal', 'coal', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'ash', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['rwaste', 'rwaste', 'rwaste', 'basalt', 'basalt', 'charcoal', 'charcoal', 'charcoal', 'charcoal', 'charcoal', 'charcoal', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'coal', 'radiationo', 'radiation', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'coal', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'ash', 'ash', 'empty', 'empty', 'empty', 'ash', 'empty', 'empty'],
['basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'charcoal', 'charcoal', 'charcoal', 'charcoal', 'charcoal', 'charcoal', 'ash', 'empty', 'empty', 'empty', 'empty', 'empty', 'coal', 'empty', 'radiationo', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'coal', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'ash', 'empty', 'basalt', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'basalt', 'basalt', 'basalt'],

['basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'charcoal', 'charcoal', 'charcoal', 'charcoal', 'charcoal', 'charcoal', 'empty', 'empty', 'empty', 'empty', 'empty', 'coal', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'ash', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'coal', 'empty', 'empty', 'empty', 'ash', 'empty', 'empty', 'basalt', 'basalt', 'basalt', 'basalt', 'rwaste', 'rwaste', 'rwaste', 'basalt', 'basalt', 'basalt', 'basalt'],
['basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'charcoal', 'charcoal', 'charcoal', 'charcoal', 'charcoal', 'ash', 'empty', 'empty', 'ash', 'coal', 'empty', 'empty', 'ash', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'ash', 'empty', 'empty', 'empty', 'empty', 'empty', 'ash', 'empty', 'empty', 'coal', 'empty', 'ash', 'empty', 'basalt', 'rwaste', 'rwaste', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'rwaste', 'rwaste', 'basalt', 'basalt', 'basalt', 'basalt'],
['basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'rwaste', 'rwaste', 'rwaste', 'basalt', 'basalt', 'empty', 'empty', 'empty', 'empty', 'empty', 'ash', 'ash', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'basalt', 'basalt', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'basalt', 'rwaste', 'rwaste', 'rwaste', 'basalt', 'basalt', 'basalt'],

['basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'basalt', 'basalt', 'basalt', 'basalt', 'rwaste', 'rwaste', 'rwaste', 'basalt', 'rwaste', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'rwaste', 'rwaste', 'basalt', 'basalt', 'basalt', 'basalt', 'rwaste', 'rwaste', 'basalt', 'basalt', 'basalt'],
['basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'rwaste', 'rwaste', {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'rwaste', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'rwaste', 'rwaste', 'rwaste', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'rwaste', 'basalt', 'basalt', 'basalt'],
['basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', {element: 'coloredvoxel', color: '#503534'}, 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'rwaste', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt'],

['basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', {element: 'coloredvoxel', color: '#503534'}, 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'rwaste', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt'],
['basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', {element: 'coloredvoxel', color: '#503534'}, 'basalt', {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'empty'],
['basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, {element: 'coloredvoxel', color: '#503534'}, 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'basalt', 'empty'],
];
const desert = [['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'sand', 'sand', 'sand', 'empty', 'empty', 'empty', 'sand', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand'],
['empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand'],

['sand', 'sand', 'sand', 'sand', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'sand', 'sand', 'sand', 'sand', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand'],
['sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand'],
['sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'empty', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'sand', 'empty', 'sand', 'sand', 'empty', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'empty', 'empty', 'cactus', 'empty', 'empty', 'empty', 'cactus', 'cactus', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand'],

['sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'cactus', 'empty', 'empty', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'empty', 'empty', 'empty', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand'],
['sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand'],
['sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone'],

['sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone'],
['sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone'],
['sandstone', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone'],

['sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone'],
['sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone'],
['sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone'],

['sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'stone', 'stone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone'],
['sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'stone', 'stone', 'stone', 'stone'],
['sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone'],

['sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'sandstone', 'stone', 'stone', 'stone', 'stone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone'],
['sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'empty'],
['sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'sandstone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'empty'],
];
const city = [['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#545454'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#383838'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#545454'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#383838'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#545454'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#383838'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#545454'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#383838'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#545454'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#545454'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#545454'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#383838'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#545454'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#383838'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#383838'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#545454'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#383838'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#5c5c5c'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#5c5c5c'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#383838'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#545454'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#383838'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#5c5c5c'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#5c5c5c'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#5f5f53'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#5c5c5c'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#5c5c5c'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#5c5c5c'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#57422e'}, {element: 'coloredvoxel', color: '#57422e'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#5c5c5c'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],

['empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#57422e'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#57422e'}, {element: 'coloredvoxel', color: '#57422e'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#545454'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#5c5c5c'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#57422e'}, {element: 'coloredvoxel', color: '#57422e'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#5c5c5c'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, 'dirt', {element: 'coloredvoxel', color: '#303030'}, 'dirt', {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#57422e'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#383838'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#57422e'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#383838'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#57422e'}, {element: 'coloredvoxel', color: '#57422e'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#383838'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#545454'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#383838'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#57422e'}, {element: 'coloredvoxel', color: '#57422e'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#303030'}, 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#262626'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#57422e'}, {element: 'coloredvoxel', color: '#303030'}, 'dirt', {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#eee84f'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#262626'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', {element: 'coloredvoxel', color: '#424242'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#383838'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#57422e'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#383838'}, {element: 'coloredvoxel', color: '#303030'}, {element: 'coloredvoxel', color: '#424242'}, 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
[{element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}, {element: 'coloredvoxel', color: '#616161'}],
];
const ufoShape = [
    ['empty', 'ufo1', 'ufo1', 'empty'],
    ['ufo2', 'ufo2', 'ufo2', 'ufo2']
];

const tractorBeamShape = [
    ['empty', 'ufo1', 'ufo1', 'empty'],
    ['ufo2', 'ufo3', 'ufo3', 'ufo2']
];
const island = [['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'fog', 'fog', 'empty', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'fog', 'empty', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'Leaf', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'Leaf', 'Leaf', 'wood', 'Leaf', 'Leaf', 'Leaf', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'Leaf', 'empty', 'wood', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'wood', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'wood', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'wood', 'sand', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'sand', 'sand', 'sand', 'sand', 'sand', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'empty', 'water', 'water', 'water', 'water', 'water', 'water', 'empty', 'empty', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'water', 'water', 'water', 'empty', 'water', 'water', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'water', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water'],
['water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water'],
['water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'wetsand', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water'],
['water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water'],
['water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'wetsand', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water'],
['water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water'],
['water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water'],
['water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'stone', 'stone', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water'],
['water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'stone', 'stone', 'stone', 'stone', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water'],
['water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water'],
['water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water'],
['water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water'],
['water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'wetsand', 'wetsand', 'wetsand', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water'],
['water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'wetsand', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water'],
['water', 'water', 'water', 'water', 'water', 'water', 'wetsand', 'wetsand', 'wetsand', 'wetsand', 'wetsand', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water'],
['water', 'water', 'wetsand', 'wetsand', 'wetsand', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'sand', 'stone', 'stone', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water'],
['water', 'water', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'sand', 'sand', 'sand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water'],
['water', 'wetsand', 'wetsand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'stone', 'stone', 'stone', 'stone', 'stone', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'sand', 'wetsand', 'sand', 'sand', 'wetsand', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water', 'water']]
const volcano = [
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'lava', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'basalt', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'obsidian', 'basalt', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'basalt', 'basalt', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'basalt', 'basalt', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'obsidian', 'basalt', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'basalt', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'obsidian', 'obsidian', 'obsidian'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'obsidian', 'basalt', 'basalt', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'obsidian', 'basalt', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'basalt', 'basalt', 'basalt', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'grass', 'grass', 'grass', 'grass', 'grass', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'basalt', 'basalt', 'basalt', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'grass', 'grass', 'grass', 'dirt', 'grass', 'grass', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'empty'],
['empty', 'empty', 'empty', 'grass', 'grass', 'grass', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'grass', 'grass', 'grass', 'dirt', 'dirt', 'grass', 'grass', 'grass', 'grass', 'empty', 'empty', 'empty', 'empty', 'empty', 'grass', 'grass', 'grass', 'empty', 'empty', 'grass', 'grass', 'grass', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'basalt', 'basalt', 'basalt', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['empty', 'grass', 'grass', 'grass', 'dirt', 'dirt', 'grass', 'empty', 'empty', 'empty', 'grass', 'grass', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'grass', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'grass', 'grass', 'empty', 'empty', 'grass', 'grass', 'dirt', 'grass', 'grass', 'grass', 'dirt', 'dirt', 'dirt', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'basalt', 'basalt', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['grass', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'grass', 'grass', 'grass', 'grass', 'dirt', 'grass', 'grass', 'grass', 'empty', 'empty', 'empty', 'empty', 'empty', 'grass', 'grass', 'grass', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'grass', 'grass', 'grass', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'basalt', 'obsidian', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'grass', 'grass', 'grass', 'empty', 'empty', 'grass', 'grass', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'grass', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'obsidian', 'obsidian', 'basalt', 'basalt', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'grass', 'grass', 'grass', 'grass', 'grass', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'obsidian', 'basalt', 'obsidian', 'basalt', 'basalt', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['stone', 'stone', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'basalt', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['stone', 'stone', 'stone', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'dirt', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'basalt', 'basalt', 'basalt', 'obsidian', 'basalt', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'basalt', 'basalt', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'lava', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'basalt', 'basalt', 'basalt', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian'],
['stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'stone', 'obsidian', 'obsidian', 'stone', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian', 'obsidian']
]   
const forest = [
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'empty', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'fog', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'empty', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'fog', 'empty', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'fog', 'fog', 'empty', 'fog', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'fog', 'empty', 'empty', 'fog', 'empty', 'fog', 'empty', 'empty', 'fog', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'Leaf', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'Leaf', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'Leaf', 'empty', 'empty', 'empty', 'empty', 'empty', 'Leaf', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'empty', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'empty', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'empty', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'Leaf', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'grass', 'grass', 'empty', 'empty', 'empty', 'grass', 'grass', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'grass', 'grass', 'empty', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'empty', 'empty', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'empty', 'empty', 'empty', 'log', 'empty', 'empty', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'empty', 'log', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'dirt', 'dirt', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'empty', 'log', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'dirt', 'dirt', 'dirt', 'grass', 'grass', 'empty', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'log', 'grass', 'grass', 'grass', 'grass', 'grass', 'log', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'root', 'dirt', 'dirt', 'dirt', 'dirt', 'grass', 'grass', 'dirt', 'grass', 'grass', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'root', 'root', 'dirt', 'root', 'root', 'root', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'grass', 'empty', 'empty'],
['empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'empty', 'grass', 'grass', 'grass', 'grass', 'grass', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'root', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'root', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'root', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'root', 'root', 'root', 'root', 'root', 'root', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'grass', 'empty', 'empty'],
['grass', 'empty', 'empty', 'empty', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'grass', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'root', 'root', 'root', 'dirt', 'dirt', 'dirt', 'root', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'root', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'grass', 'grass'],
['empty', 'grass', 'grass', 'grass', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'root', 'root', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'root', 'root', 'root', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt'],
['dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'root', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'root', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt'],
['dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'root', 'root', 'root', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'root', 'root', 'root', 'root', 'root', 'root', 'root', 'root', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt'],
['dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'root', 'root', 'root', 'root', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt'],
['dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt'],
['dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt'],
['dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt'],
['dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt'],
['dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt'],
['dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt'],
['dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt', 'dirt']
]


let flashTimer = 0; // Timer to control the flash effect
        function initializeCell(row, col, elementname, color){

            grid[row][col] = {
                       element: elementname,
                       age: 0,
                       uraniumColor: 'green', // Add this line
                       hotsteelColor: '#A4A4A4', // Add this line
                       delay: 0,
                       laserdelay: 0,
                       firemove: true,
                       mineColor: '#303030',
                       firework: false,
                       tractorbeam: false,
                       tlaserdelay:0,
                       cb: true,
                       frdelay: 0,
                       cbdelay: 0,
                       glue: true,
                       fpmove: true,
                       edelay: 0,
                       e: false,
                       unsafeh: false,
                       lightning: 0,
                       lage: 0,
                       right: false,
                       jumpdelay: 10,
                       left: false,
                       jumpdelay: 0,
                       movedelay: 0,
                       grab:false,
                       grabage: 0,
                       elevate: false,
                       grabdelay: 0,
                       elevatedelay: 0,
                       elevateage: 0,
                       pushage: 0,
                       push: false,
                       pushdelay: 0,
                       stop: false,
                       timeage: 0,
                       dirty: true,
                       dirtye: false,
                       felement: null,
                       bdelay: 0,
                       bage: 0,
                       sage: 0,
                       snap: false,
                       snapnm: false,
                       snapthing: false,
                       sound: false,
                       soage: 0,
                       sodelay: 0,
                       frozen: false,
                       selected: false,
                       unbreakable: false,
                       unbreakableelement: null,
                       ldirty: false,
                       ldelay: 0,
                       wind: false,
                       customcolor: color,
                       vy: 1,
                       vyAccum: 0,
                       growth: 0,
                       size: 0,
                        antdirection: null,
                        went: false,
                        shockwave: false,
                        shockwavecolordelay: false,
                        shockwavecolordelay2: false,
                        powered:false,
                        elevatormoving: false,
                        tarmove: false,
                        length: 1,
                        paint: false,
                        lastelement2: null,
                        hologram: false,
                        biome: 'plains'


                   };
        }
        function initializeGrid() {

           for (let row = 0; row < rows; row++) {
               grid[row] = [];
               for (let col = 0; col < cols; col++) {

                   grid[row][col] = {
                       element: 'empty',
                       age: 0,
                       uraniumColor: 'green', // Add this line
                       hotsteelColor: '#A4A4A4', // Add this line
                       delay: 0,
                       laserdelay: 0,
                       firemove: true,
                       mineColor: '#303030',
                       firework: false,
                       tractorbeam: false,
                       tlaserdelay:0,
                       cb: true,
                       frdelay: 0,
                       cbdelay: 0,
                       glue: true,
                       fpmove: true,
                       edelay: 0,
                       e: false,
                       unsafeh: false,
                       lightning: 0,
                       lage: 0,
                       right: false,
                       jumpdelay: 10,
                       left: false,
                       jumpdelay: 0,
                       movedelay: 0,
                       grab:false,
                       grabage: 0,
                       elevate: false,
                       grabdelay: 0,
                       elevatedelay: 0,
                       elevateage: 0,
                       pushage: 0,
                       push: false,
                       pushdelay: 0,
                       stop: false,
                       timeage: 0,
                       dirty: true,
                       dirtye: false,
                       felement: null,
                       bdelay: 0,
                       bage: 0,
                       sage: 0,
                       snap: false,
                       snapnm: false,
                       snapthing: false,
                       sound: false,
                       soage: 0,
                       sodelay: 0,
                       frozen: false,
                       selected: false,
                       unbreakable: false,
                       unbreakableelement: null,
                       ldirty: false,
                       ldelay: 0,
                       wind: false,
                       vy: 1,
                       vyAccum: 0,
                       growth: 0,
                       size: 0,
                    antdirection: null,
                    went: false,
                    shockwave: false,
                    shockwavecolor: false,
                    shockwavecolordelay: 0,
                    shockwavecolordelay2: 0,
                    powered: false,
                    elevatormoving: false,
                    tarmove: false,
                    length: 1,
                    paint: false,
                    lastelement2: null,
                    hologram: false,
                    biome: 'plains'
                   };
               }
           }
           
       }
function createMiniSim(targetContainer) {
  const container = document.createElement("div");
  container.style.position = "absolute";
  container.style.left = 0;
  container.style.top = 0;
  container.style.background = 'rgba(0, 0, 0, 0)';
  container.style.zIndex = "1";
  container.style.fontFamily = "sans-serif";
  container.style.display = "inline-block";
  container.style.border = "none";
  container.style.width = "100%";
  container.style.height = "100%";
container.style.overflow = "hidden"; // Important for containment
  container.innerHTML = `
    <canvas style="display:block; border:none; outline: none; width:100%; height:100%;"></canvas>
  `;

  targetContainer.appendChild(container);

  const canvas = container.querySelector("canvas");
  const ctx = canvas.getContext("2d");

  const voxelSize = 8;
  let width, height, cols, rows;
  let grid = [];

  let selectedElement = "sand";
  let isDrawing = false;

  const colors = {
    sand: "goldenrod", water: "blue", stone: "gray", fire: "orange",
    wood: "saddlebrown", smoke: "lightgray", air: null, empty: null
  };

  const elements = {
    sand: { color: "goldenrod", liquid: false },
    water: { color: "blue", liquid: true, liquiddelay: 2 },
    stone: { color: "gray", liquid: false },
    fire: { color: "orange", liquid: false },
    wood: { color: "saddlebrown", liquid: false },
    smoke: { color: "lightgray", liquid: false },
    air: { color: null, liquid: false },
    empty: { color: null, liquid: false }
  };

  const elementMap = {
    '1': 'sand',
    '2': 'water',
    '3': 'stone',
    '4': 'fire',
    '5': 'wood',
    '6': 'smoke',
    '7': 'empty'
  };

  document.addEventListener('keydown', (e) => {
    if (elementMap[e.key]) {
      selectedElement = elementMap[e.key];
      console.log(`Selected: ${selectedElement}`);
    }
  });

  function initializeSimulation() {
  // Get visual size of the canvas in pixels
  const pixelWidth = canvas.clientWidth;
  const pixelHeight = canvas.clientHeight;

  // Set actual drawing resolution to match
  canvas.width = pixelWidth;
  canvas.height = pixelHeight;

  width = pixelWidth;
  height = pixelHeight;

  cols = Math.floor(width / voxelSize);
  rows = Math.floor(height / voxelSize);

  grid = Array.from({ length: rows }, () =>
    Array.from({ length: cols }, () => ({ element: "empty", delay: 0 }))
  );
}


  function placeStoneUnderButtons() {
   const buttons = targetContainer.querySelectorAll("button, a");

    buttons.forEach(button => {
        if(button.id !== 'settingbuttonopen'){
      const rect = button.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      const startX = Math.floor((rect.left - canvasRect.left) / voxelSize);
      const endX = Math.floor((rect.right - canvasRect.left) / voxelSize);
      const startY = Math.floor((rect.top - canvasRect.top) / voxelSize);
      const endY = Math.floor((rect.bottom - canvasRect.top) / voxelSize);

      for (let y = startY; y <= endY; y++) {
        for (let x = startX; x <= endX; x++) {
          if (x >= 0 && x < cols && y >= 0 && y < rows) {
            grid[y][x] = { element: "stone", delay: 0 };
          }
        }
      }
    }
    });
  
    
  
}

  function placeElement(e) {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / voxelSize);
    const y = Math.floor((e.clientY - rect.top) / voxelSize);
    if (x >= 0 && x < cols && y >= 0 && y < rows) {
      grid[y][x] = { element: selectedElement, delay: 0 };
    }
  }

  canvas.addEventListener("mousedown", (e) => {
    isDrawing = true;
    placeElement(e);
  });
  canvas.addEventListener("mousemove", (e) => {
    if (isDrawing) placeElement(e);
  });
  canvas.addEventListener("mouseup", () => isDrawing = false);
  canvas.addEventListener("mouseleave", () => isDrawing = false);

  function update() {
    for (let row = rows - 1; row >= 0; row--) {
      for (let col = 0; col < cols; col++) {
        const cell = grid[row][col];
        const element = elements[cell.element];
        if (!element) continue;

        if (cell.element === "sand") {
          const below = grid[row + 1]?.[col];
          const downLeft = grid[row + 1]?.[col - 1];
          const downRight = grid[row + 1]?.[col + 1];

          if (below && below.element === "empty") {
            grid[row + 1][col] = { ...cell };
            grid[row][col] = { element: "empty", delay: 0 };
          } else if (downLeft && downLeft.element === "empty") {
            grid[row + 1][col - 1] = { ...cell };
            grid[row][col] = { element: "empty", delay: 0 };
          } else if (downRight && downRight.element === "empty") {
            grid[row + 1][col + 1] = { ...cell };
            grid[row][col] = { element: "empty", delay: 0 };
          }
        }

        if (cell.element === "fire") {
          cell.delay++;
          if (cell.delay > 10) {
            cell.element = 'empty';
            cell.delay = 0;
          }
        }

        if (cell.element === "wood") {
          const adjacent = [
            [row - 1, col], [row + 1, col], [row, col - 1], [row, col + 1]
          ];
          if (adjacent.some(([r, c]) => grid[r]?.[c]?.element === 'fire')) {
            cell.element = 'fire';
          }
        }

        if (element.liquid && row < rows - 1) {
          const liquiddelay = element.liquiddelay || 0;
          cell.delay++;

          if (grid[row + 1][col].element === "empty") {
            grid[row + 1][col] = { ...cell };
            grid[row][col] = { element: "empty", delay: 0 };
          } else {
            const leftEmpty = col > 0 && grid[row][col - 1].element === 'empty';
            const rightEmpty = col < cols - 1 && grid[row][col + 1].element === 'empty';

            if (cell.delay >= liquiddelay) {
              cell.delay = 0;
              if (Math.random() < 0.5) {
                if (col > 1 && grid[row][col - 2].element === 'empty' && leftEmpty) {
                  grid[row][col - 2] = { ...cell };
                  grid[row][col] = { element: "empty", delay: 0 };
                } else if (leftEmpty) {
                  grid[row][col - 1] = { ...cell };
                  grid[row][col] = { element: "empty", delay: 0 };
                }
              } else {
                if (col < cols - 2 && grid[row][col + 2].element === 'empty' && rightEmpty) {
                  grid[row][col + 2] = { ...cell };
                  grid[row][col] = { element: "empty", delay: 0 };
                } else if (rightEmpty) {
                  grid[row][col + 1] = { ...cell };
                  grid[row][col] = { element: "empty", delay: 0 };
                }
              }
            }
          }
        }
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, width, height);
    for (let y = 0; y < rows; y++) {
      for (let x = 0; x < cols; x++) {
        const type = grid[y][x].element;
        const color = colors[type];
        if (color) {
          ctx.fillStyle = color;
          ctx.fillRect(x * voxelSize, y * voxelSize, voxelSize, voxelSize);
        }
      }
    }
  }

  function loop() {
    update();
    draw();
    placeStoneUnderButtons();
    requestAnimationFrame(loop);
  }

  // Observe resizing
  const resizeObserver = new ResizeObserver(() => {
    initializeSimulation();
  });
  resizeObserver.observe(container);

  initializeSimulation();
  loop();
}

  createMiniSim(document.getElementById("menu-container"));
       function setGrid(elementtype) {
           for (let row = 0; row < rows; row++) {
               grid[row] = [];
               for (let col = 0; col < cols; col++) {
                   grid[row][col] = {
                       element: elementtype
                      
                   };
               }
           }
       }

       function nuke() {
           for (let row = 0; row < 1; row++) {
               grid[row] = [];
               for (let col = 0; col < cols; col++) {
                   grid[row][col] = {
                       element: 'nuke'
                      
                   };
               }
           }
       }
     

 
        // Initialize grid with lava properties (if necessary)
        function initializeLavaCell(cell) {
            if (!cell.lastColorChange) {
                cell.lastColorChange = Date.now(); // Set the creation time for the lava cell
                cell.currentColor = elements.lava.colors[Math.floor(Math.random() * elements.lava.colors.length)];
            
            }
        }
        function initializevirusCell(cell) {
            if (!cell.lastColorChange) {
                cell.lastColorChange = Date.now(); // Set the creation time for the lava cell
                cell.currentColor = elements.virus.colors[Math.floor(Math.random() * elements.virus.colors.length)];
            
            }
        }
        

        function initializesandCell(cell) {
            if (!cell.lastColorChange) {
                cell.lastColorChange = Date.now(); // Set the creation time for the lava cell
                cell.currentColor = elements.sand.colors[Math.floor(Math.random() * elements.sand.colors.length)];
            
            }
        }
        function initializewaterCell(cell) {
            if (!cell.lastColorChange) {
                cell.lastColorChange = Date.now(); // Set the creation time for the lava cell
                cell.currentColor = elements.water.colors[Math.floor(Math.random() * elements.water.colors.length)];
            
            }
        }
        function initializeborderCell(cell) {
            if (!cell.lastColorChange) {
                cell.lastColorChange = Date.now(); // Set the creation time for the lava cell
                cell.currentColor = elements.border.colors[Math.floor(Math.random() * elements.border.colors.length)];
            
            }
        }
      
        
 
 
        // Initialize grid with lava properties (if necessary)
        function initializemagmaCell(cell) {
            if (!cell.lastColorChange) {
                cell.lastColorChange = Date.now(); // Set the creation time for the lava cell
                cell.currentColor = elements.magma.colors[Math.floor(Math.random() * elements.magma.colors.length)];
               
            }
        }
       
        function updateCanvasTransform() {
            
    if (gravity === 'up') {
        canvas.style.transform = "scaleY(-1)"; // Flip vertically
    } else {
        canvas.style.transform = "scaleY(1)"; // Normal orientation
    }
}

// Call this function whenever gravity changes

function toggleGravity() {
    gravity = (gravity === 'up') ? 'down' : 'up'; // Toggle between up and down
    updateCanvasTransform();
}

      // delay in milliseconds for each lava cell
      const magmaColorChangeDelay = 1000; // delay in milliseconds for each lava cell
      const lavaColorChangeDelay = 500; // delay in milliseconds for each lava cell
      const waterColorChangeDelay = 1000; // delay in milliseconds for each lava cell
      const sandColorChangeDelay = 5000; // delay in milliseconds for each lava cell
      const virusColorChangeDelay = 5000; // delay in milliseconds for each lava cell
      const borderColorChangeDelay = 500; // delay in milliseconds for each lava cell

      let mouseX = -1; // Track mouse X position
let mouseY = -1; // Track mouse Y position
let isHovering = false; // Track if the mouse is hovering over the canvas

// Add mousemove listener
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();

    if (gravity === 'up') {
        mouseY = Math.floor((rect.bottom - e.clientY) / voxelSize);
    } else {
        mouseY = Math.floor((e.clientY - rect.top) / voxelSize);
    } 
    
    mouseX = Math.floor((e.clientX - rect.left) / voxelSize);
    isHovering = true;
});


canvas.addEventListener('mousemove', (event) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;
    
  
    hmrow = Math.floor(mouseY / voxelSize);
    hmcol = Math.floor(mouseX / voxelSize);

    // Optionally, display the target for debugging
    const hoverInfo = document.getElementById('hoverInfo');
    hoverInfo.innerText = `Target: Row=${hmrow}, Col=${hmcol}`;
});



// Add mouseout listener
canvas.addEventListener('mouseout', () => {
    isHovering = false; // Reset hovering state
});
document.addEventListener('keydown', (e) => {
    if(cmd === false){
    if (e.key === 'Backspace') {
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {

                if (grid[row][col].selected) {
                    grid[row][col].element = 'empty'; // Set selected elements to empty
                    grid[row][col].selected = false;  // Optionally unselect them
                    grid[row][col].stop = false;
                }
            
            }}

        }
    }
});
let voxels = [];

function createVoxel(row, col, color) {
    const rect = canvas.getBoundingClientRect(); // Get the canvas position and size relative to the page

    // Create the div element for the voxel
    const voxel = document.createElement('div');

    // Set the size of the voxel based on the global voxel size
    voxel.style.width = `${voxelSize}px`;
    voxel.style.height = `${voxelSize}px`;

    // Set the position based on the row, column, and the canvas position
    voxel.style.position = 'absolute';
    voxel.style.left = `${rect.left + col * voxelSize + 10}px`; // X position relative to the canvas
    voxel.style.top = `${rect.top + row * voxelSize}px`; // Y position relative to the canvas
    voxel.style.opacity = 0.5;

    let r = 0, g = 0, b = 0;

    if (color.startsWith('rgb')) {
        // Parse the RGB color format: rgb(r, g, b)
        const match = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
        if (match) {
            r = parseInt(match[1]);
            g = parseInt(match[2]);
            b = parseInt(match[3]);
        }
    } else if (color.startsWith('#')) {
        // Parse the hex color format: #ff0000
        const hex = color.slice(1);
        r = parseInt(hex.substring(0, 2), 16);
        g = parseInt(hex.substring(2, 4), 16);
        b = parseInt(hex.substring(4, 6), 16);
    }

    // Modify the color to give it a blue hologram effect
    const hologramBlue = `rgba(${r}, ${g}, ${Math.min(b + 50, 255)}, 1)`;  // Add a subtle blue without overpowering

    // Optional: Add a soft glowing effect
    voxel.style.boxShadow = '0 0 5px rgba(0, 255, 255, 0.6)';  // Soft glowing effect

    // Apply the modified color to the voxel's background
    voxel.style.backgroundColor = hologramBlue;

    // Disable pointer events to avoid any weird behavior
    voxel.style.pointerEvents = 'none'; // Disable mouse interaction on the voxel

    // Append the voxel to the document body or any other container
    document.body.appendChild(voxel);

    const initialTop = rect.top + row * voxelSize + 10;

    // Store the voxel details in the array
    const voxelData = {
        row: row,
        col: col,
        color: color,
        element: voxel,
        initialTop: initialTop,
        bobHeight: 6, // Set how much the voxel will bob
        direction: 1, // 1 for moving up, -1 for moving down
        speed: 0.001 // Speed of bobbing
    };
    voxels.push(voxelData);

    // Bobbing effect
    function bobbingEffect(voxelData) {
        const { element, initialTop, bobHeight, speed } = voxelData;
        const wave = Math.sin(Date.now() * speed) * bobHeight;
        element.style.top = `${initialTop + wave}px`;

        requestAnimationFrame(() => bobbingEffect(voxelData));
    }

    // Start the bobbing effect
    bobbingEffect(voxelData);
}
function deleteholograms() {
    for (const voxel of voxels) {
        if (voxel.element && voxel.element.parentElement) {
            voxel.element.remove();
        }
    }
    // Clear the voxel data array
    voxels = [];
}

let lastUpdateTime2 = 0;
const updateInterval2 = 16;  // 60 FPS (1000ms / 60fps ≈ 16ms)
function updateHoverDiv() {
  

if (isHovering) {
    const currentTime = performance.now();
    
    // Throttle updates to every ~16ms (60 FPS)
    if (currentTime - lastUpdateTime2 < updateInterval2) {
        return;
    }
    lastUpdateTime2 = currentTime;

    const halfBrush = Math.floor(brushSize / 2);

    // Calculate the outer bounds of the brush
    const startX = (mouseX - halfBrush) * voxelSize;
    const startY = (mouseY - halfBrush) * voxelSize;

    const brushWidth = brushSize * voxelSize;
    const brushHeight = brushSize * voxelSize;

    // Ensure the border stays within the canvas
    const clampedStartX = Math.max(0, startX);
    const clampedStartY = Math.max(0, startY);
    const clampedWidth = Math.min(brushWidth, canvas.width - clampedStartX);
    const clampedHeight = Math.min(brushHeight, canvas.height - clampedStartY);

    // Get the canvas bounding box
    const canvasRect = canvas.getBoundingClientRect();

    // Create or update the hover div
    let hoverDiv = document.getElementById('hoverDiv');
    if (!hoverDiv) {
        hoverDiv = document.createElement('div');
        hoverDiv.id = 'hoverDiv';
        document.body.appendChild(hoverDiv);
    }

    // Apply styles to the div
    hoverDiv.style.position = 'absolute';  // Ensure absolute positioning
    hoverDiv.style.left = `${canvasRect.left + clampedStartX}px`;
    hoverDiv.style.top = `${canvasRect.top + clampedStartY}px`;
    hoverDiv.style.width = `${clampedWidth}px`;
    hoverDiv.style.height = `${clampedHeight}px`;
    hoverDiv.style.border = '2px solid white';
    hoverDiv.style.pointerEvents = 'none'; // To avoid interaction with the div
    hoverDiv.style.opacity = '0.5';

    // Set the z-index to ensure it is always in front
    hoverDiv.style.zIndex = '99999'; // Extremely high z-index

    // Use transform for smoother performance
    hoverDiv.style.transform = 'translate3d(0, 0, 0)'; // Ensures GPU acceleration for positioning
}

}

        function drawGrid() {
           
            ctx.clearRect(0, 0, width, height); // Clear canvas
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {

                  // Save state before modifying
                    const cell = grid[row][col];
                    const element = cell.element;
               
                   ctx.fillRect((col-1) * voxelSize, row * voxelSize, voxelSize, voxelSize);
if (col === cols) {
grid[row][col].element = 'wall';
}
if (row === 0 && col === 0) {
  ctx.fillStyle = elements.empty.color;
  ctx.fillRect(0, 0, voxelSize, voxelSize);
}


                    updateHoverDiv();
    if (grid[row][col].selected === true) {
    ctx.save();  // Save canvas state
    ctx.strokeStyle = 'black';  // Selection border color
    ctx.lineWidth = 1;
    ctx.setLineDash([3, 3]); // Dashed outline
    let x = Math.floor(col * voxelSize);
let y = Math.floor(row * voxelSize);

ctx.strokeRect(x+ voxelSize, y, voxelSize, voxelSize);


    ctx.setLineDash([]); // Reset dashes
    ctx.restore(); // Restore canvas state
}



if(cell.shockwavecolor2 === true){
    cell.shockwavecolordelay2++;
    if(cell.element){
        if(elements[grid[row][col].element].flammable === true){
           if(Math.random() < 0.5) cell.element = 'fire';
        }
    ctx.fillStyle = 'orange';
    if(cell.shockwavecolordelay2 > 2){
        cell.shockwavecolor2 = false;
        cell.shockwavecolordelay2 = 0;
    }
    }
} else 

if(cell.shockwavecolor === true){
    cell.shockwavecolordelay++;
    if(cell.element){

    ctx.fillStyle = 'white';
    if(cell.shockwavecolordelay > 2){
        cell.shockwavecolor = false;
        cell.shockwavecolordelay = 0;
    }
    }
} else
    if(cell.color && elements[cell.element].color1){
        ctx.fillStyle = cell.color;
    }
 else if( cell.ink===true){
        if(cell.element !== 'empty'){
        ctx.fillStyle= '#1B1A19';
        } else cell.ink=false;
    
    }else  if( cell.paint===true){
        if(cell.element !== 'empty'){
        ctx.fillStyle= cell.customcolor;
        } else cell.paint=false;
    
    } else if (element === 'mine') {
     ctx.fillStyle = cell.mineColor;
 } else   if (element === 'uranium') {
     ctx.fillStyle = cell.uraniumColor;
 } else   if (element === 'hotsteel') {
     ctx.fillStyle = cell.hotsteelColor;
 }else if (element === 'brick') {
     ctx.fillStyle = cell.brickColor;
 } else if (element === 'cursorb') {
     ctx.fillStyle = cell.cursorColor;
 }else   if (element === 'grass') {
  

    ctx.fillStyle = cell.grassColor || elements.grass.initialColor; 
}
else    if (element === 'dirt') {
    ctx.fillStyle = cell.dirtColor || elements.dirt.initialColor; // Use the stored stone color or initial color
             }else    if (element === 'concrete') {
    ctx.fillStyle = cell.concreteColor || elements.concrete.initialColor; // Use the stored stone color or initial color
             }else    if (element === 'sand') {
    ctx.fillStyle = cell.sandColor || elements.sand.initialColor; // Use the stored stone color or initial color
             }else    if (element === 'coloredvoxel') {
    ctx.fillStyle = cell.customcolor || elements.empty.color;
             }else    if (element === 'pointer') {
    ctx.fillStyle = cell.customcolor || elements.empty.color;
             }else    if (element === 'paint') {
    ctx.fillStyle = cell.customcolor || elements.empty.color;
             }else    if (element === 'paintball') {
    ctx.fillStyle = cell.customcolor || elements.empty.color;
             }else    if (element === 'web') {
    ctx.fillStyle = cell.webColor || elements.web.initialColor; // Use the stored stone color or initial color
             } else   if (element === 'diamond') {
     ctx.fillStyle = cell.diamondColor || elements.diamond.initialColor; // Use the stored stone color or initial color
             }  else   if (element === 'bamboo') {
     ctx.fillStyle = cell.bambooColor || elements.bamboo.initialColor; // Use the stored stone color or initial color
             } else   if (element === 'dryice') {
     ctx.fillStyle = cell.dryiceColor || elements.dryice.initialColor; // Use the stored stone color or initial color
             }else   if (element === 'paper') {
     ctx.fillStyle = cell.paperColor || elements.paper.initialColor; // Use the stored stone color or initial color
             }else   if (element === 'cheese') {
     ctx.fillStyle = cell.cheeseColor || elements.cheese.initialColor; // Use the stored stone color or initial color
             } else if (element === 'moss') {
     ctx.fillStyle = cell.mossColor || elements.moss.initialColor; // Use the stored stone color or initial color
             } else if (element === 'wood') {
     ctx.fillStyle = cell.woodColor || elements.wood.initialColor; // Use the stored stone color or initial color
             }else if (element === 'gs') {
     ctx.fillStyle = cell.gsColor || elements.gs.initialColor; // Use the stored stone color or initial color
             }  else if (element === 'stone') {
                 ctx.fillStyle = cell.stoneColor || elements.stone.initialColor; // Use the stored stone color or initial color
             }else if (element === 'straw') {
                 ctx.fillStyle = cell.strawColor || elements.straw.initialColor; // Use the stored stone color or initial color
             } else if (element === 'bedrock') {
                 ctx.fillStyle = cell.bedrockColor || elements.bedrock.initialColor; // Use the stored stone color or initial color
             } else if (element === 'cloth') {
                 ctx.fillStyle = cell.clothColor || elements.cloth.initialColor; // Use the stored stone color or initial color
             } else if (element === 'basalt') {
                 ctx.fillStyle = cell.basaltColor || elements.basalt.initialColor; // Use the stored stone color or initial color
             } else if (element === 'obsidian') {
                 ctx.fillStyle = cell.obsidianColor || elements.obsidian.initialColor; // Use the stored stone color or initial color
             } else if (element === 'gold') {
                 ctx.fillStyle = cell.goldColor || elements.gold.initialColor; // Use the stored stone color or initial color
             }else if (element === 'sandstone') {
                 ctx.fillStyle = cell.sandstoneColor || elements.sandstone.initialColor; // Use the stored stone color or initial color
             }else if (element === 'fire') {
                        const fireColors = elements.fire.colors;
                        ctx.fillStyle = fireColors[Math.floor(Math.random() * fireColors.length)];
 
 
                    } else if (element === 'static') {
                        const fireColors = elements.static.colors;
                        ctx.fillStyle = fireColors[Math.floor(Math.random() * fireColors.length)];
 
 
                    } else if (element === 'nfire') {
                        const fireColors = elements.fire.colors;
                        ctx.fillStyle = fireColors[Math.floor(Math.random() * fireColors.length)];
 
 
                    } else if (element === 'laser') {
                        const laserColors = elements.laser.colors;
                        ctx.fillStyle = laserColors[Math.floor(Math.random() * laserColors.length)];
 
 
                    } else if (element === 'lasersource') {
                        const lasersourceColors = elements.lasersource.colors;
                        ctx.fillStyle = lasersourceColors[Math.floor(Math.random() * lasersourceColors.length)];
 
 
                    } else if (element === 'ewire') {

                        const ewireColors = elements.ewire.colors;
                        ctx.fillStyle = ewireColors[Math.floor(Math.random() * ewireColors.length)];
 
 
                    }else if (element === 'plasma') {
                        const plasmaColors = elements.plasma.colors;
                        ctx.fillStyle = plasmaColors[Math.floor(Math.random() * plasmaColors.length)];
 
 
                    } else if (element === 'fireworkf') {
                        const fireworkfColors = elements.fireworkf.colors;
                        ctx.fillStyle = fireworkfColors[Math.floor(Math.random() * fireworkfColors.length)];
 
 
                    } else if (element === 'static') {
                        const staticColors = elements.static.colors;
                        ctx.fillStyle = staticColors[Math.floor(Math.random() * staticColors.length)];
 
 
                    }else if (element === 'glitch') {
         ctx.fillStyle = elements.glitch.getColor(); // Get random color for glitch
     }
  else if (element === 'moltensand') {
                        const sandColors = elements.moltensand.colors;
                        ctx.fillStyle = sandColors[Math.floor(Math.random() * sandColors.length)];
                      
 
                    }else if (element === 'water') {
                        const waterColors = elements.water.colors;
                        ctx.fillStyle = waterColors[Math.floor(Math.random() * waterColors.length)];
                       
 
                    }else if (element === 'lasercannon') {
                        const lasercannonColors = elements.lasercannon.colors;
                        ctx.fillStyle = lasercannonColors[Math.floor(Math.random() * lasercannonColors.length)];
                       
 
                    } else if (element === 'tsunami') {
                        const tsunamiColors = elements.tsunami.colors;
                        ctx.fillStyle = tsunamiColors[Math.floor(Math.random() * tsunamiColors.length)];
                       
 
                    } else if (element === 'lava') {
                        const now = Date.now(); // current time
                        initializeLavaCell(cell); // Initialize if it's a new lava cell
                        
 
                        // Check if the delay has passed for this cell
                        if (now - cell.lastColorChange > lavaColorChangeDelay) {
                            const lavaColors = elements.lava.colors;
                            cell.currentColor = lavaColors[Math.floor(Math.random() * lavaColors.length)];
                            cell.lastColorChange = now; // update the last color change time
                           
                        }
                        ctx.fillStyle = cell.currentColor; // set the current lava color
 
 
                    } else if (element === 'border') {
                        const now = Date.now(); // current time
                        initializeborderCell(cell); // Initialize if it's a new lava cell
                        
 
                        // Check if the delay has passed for this cell
                        if (now - cell.lastColorChange > borderColorChangeDelay) {
                            const borderColors = elements.border.colors;
                            cell.currentColor = borderColors[Math.floor(Math.random() * borderColors.length)];
                            cell.lastColorChange = now; // update the last color change time
                           
                        }
                        ctx.fillStyle = cell.currentColor; // set the current lava color
 
 
                    }else if (element === 'virus') {
                        const now = Date.now(); // current time
                        initializevirusCell(cell); // Initialize if it's a new lava cell
                        
 
                        // Check if the delay has passed for this cell
                        if (now - cell.lastColorChange > virusColorChangeDelay) {
                            const virusColors = elements.virus.colors;
                            cell.currentColor = virusColors[Math.floor(Math.random() * virusColors.length)];
                            cell.lastColorChange = now; // update the last color change time
                           
                        }
                        ctx.fillStyle = cell.currentColor; // set the current lava color
 
 
                    } else if (element === 'magma') {
                        const now = Date.now(); // current time
                        initializemagmaCell(cell); // Initialize if it's a new lava cell
 
 
                        // Check if the delay has passed for this cell
                        if (now - cell.lastColorChange > magmaColorChangeDelay) {
                            const magmaColors = elements.magma.colors;
                            cell.currentColor = magmaColors[Math.floor(Math.random() * magmaColors.length)];
                            cell.lastColorChange = now; // update the last color change time
                           
                        } 
                        ctx.fillStyle = cell.currentColor; // set the current lava color
                    }  else {
                        ctx.fillStyle = elements[element].color;
                    }
            
                    if(cell.element==='tornado'){
                        tornado(cell, row, col);
                    }
                    if(cell.element === 'cockroach'){
    cell.delay++;
    if(row < rows - 1 && grid[row+1][col].element === 'empty'){
        
    grid[row+1][col] = structuredClone(grid[row][col]);
    initializeCell(row, col, 'empty');
        
    } else {
        let left = col > 0 && grid[row][col - 1].element === 'empty';
        let right = col < cols - 1 && grid[row][col + 1].element === 'empty';
    
 
       
   let newCol = Math.random() < 0.5 ? col - 1 : col + 1;
   if(Math.random() < 0.1){
            if(newCol > 0 && newCol < cols - 1){
                if(grid[row][newCol].element === 'empty'){
                    grid[row][newCol] = structuredClone(grid[row][col], ['delay']);
                    initializeCell(row, col, 'empty');
                } else{
                   
                        newRow = row - 1
                    if(newRow > 0 && newRow < rows - 1){
                        if(grid[newRow][newCol].element === 'empty'){
                            grid[newRow][newCol] = structuredClone(grid[row][col],  ['delay']);
                            initializeCell(row, col, 'empty');
                        }
                    }
                }
            }
        }
        
    }
}
                    if(grid[row][col].unbreakable === true){
                        cell.stop = true;
                        if(grid[row][col].type !== 'unbreakable'){
                            grid[row][col].element = cell.unbreakableelement;
                            cell.stop = true;
                        }
                    }
                    if(elements[grid[row][col].element].type === 'unbreakable'){
                        cell.unbreakable= true;
                        cell.unbreakableelement= cell.element;

                    }
                   
 

    


    
                    if (cell.element === 'timecapsule') {
     const explosionRadius = 10; // Define the explosion radius
     const startRow = Math.max(0, row - explosionRadius);
     const endRow = Math.min(rows - 1, row + explosionRadius);
     const startCol = Math.max(0, col - explosionRadius);
     const endCol = Math.min(cols - 1, col + explosionRadius);
 
    
     for (let r = startRow; r <= endRow; r++) {
         for (let c = startCol; c <= endCol; c++) {
             const distance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (distance <= explosionRadius) {
              if (grid[r][c] && grid[r][c].element !== 'timecapsule') {
                     grid[r][c].stop = true;
                     grid[r][c].timeage = 1;
                    
                
             }
         }
     }
    
 }
}


                    if(cell.element==='lightning' && col > 0 && col < cols - 1){
                        if(row < rows -1){
        lightning(cell, row, col);
                        } else cell.element='lexplosion';
  }
 
  if (cell.element === 'cursorb') {

     cursorb(cell, row, col);
   
    }

   
    if (elements[grid[row][col].element].liquid === true) {

    // Check all 8 surrounding cells (up, down, left, right, and diagonals)
    let allSurroundingWater = true;

    // Check top
    if (row > 0 && elements[grid[row - 1][col].element].liquid !== true) {
        allSurroundingWater = false;
    }
    // Check bottom
    if (row < rows - 1 && elements[grid[row + 1][col].element].liquid !== true) {
        allSurroundingWater = false;
    }
    // Check left
    if (col > 0 && elements[grid[row][col - 1].element].liquid !== true) {
        allSurroundingWater = false;
    }
    // Check right
    if (col < cols - 1 && elements[grid[row][col + 1].element].liquid !== true) {
        allSurroundingWater = false;
    }
    // Check top-left diagonal
    if (row > 0 && col > 0 && elements[grid[row - 1][col - 1].element].liquid !== true) {
        allSurroundingWater = false;
    }
    // Check top-right diagonal
    if (row > 0 && col < cols - 1 && elements[grid[row - 1][col + 1].element].liquid !== true) {
        allSurroundingWater = false;
    }
    // Check bottom-left diagonal
    if (row < rows - 1 && col > 0 && elements[grid[row + 1][col - 1].element].liquid !== true) {
        allSurroundingWater = false;
    }
    // Check bottom-right diagonal
    if (row < rows - 1 && col < cols - 1 && elements[grid[row + 1][col + 1].element].liquid !== true) {
        allSurroundingWater = false;
    }

    // If all surrounding cells are water, mark this cell as dirty
    if (allSurroundingWater) {
        cell.ldelay++;
        if(grid[row][col].ldelay >= 2){
        grid[row][col].ldirty = true;
        }
    } else  grid[row][col].ldirty = false; cell.ldelay = 0;
}
// Array to store the hologram colors for each cell (using a 2D array or map)

    if(isPaused === false){

        if(cell.hologram===true && cell.element !== 'empty'){
    createVoxel(row, col, ctx.fillStyle);
    cell.element = 'empty';
    cell.hologram=false;

}
if(cell.element === 'empty'){
    cell.hologram = false;
}
        if(cell.element==='empty'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            }, // Right
                            {
                                row: row - 1,
                                col: col - 1
                            }, // Up-Left (Diagonal)
                            {
                                row: row - 1,
                                col: col + 1
                            }, // Up-Right (Diagonal)
                            {
                                row: row + 1,
                                col: col - 1
                            }, // Down-Left (Diagonal)
                            {
                                row: row + 1,
                                col: col + 1
                            } // Down-Right (Diagonal)
                        ];
                        const Adjacentd1 = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'vine'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacentd1) {
                            cell.age++;
 
 
 
 
 
 
 
                            
                            // Replace water with grass after delay of 30 frames
                            if (cell.age >= 10) {
                            
                       
                        
                                cell.element = 'vine';
                                cell.age = 0;
                            }
                        }
                    }
                    if(cell.element === 'empty'){
                        if(cell.shockwave === true){
                        cell.shockwave= false;
                        }
                    }
                    if(cell.went === true){
                        if(cell.element === 'empty'){
                            cell.went = false;
                        }
                    }
                    if(cell.element==='vine'){
                        const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && elements[grid[r][c].element].type==='solid' 
                        );
                            
 
                            if(Adjacent){
                                continue;
                            } else cell.element='empty';
 
 
 
 
                    }
                    if(cell.element==='nfire'){
                        const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element !=='empty' && grid[r][c].element !=='nfire' 
                        );
                            
 
                            if(Adjacent){
                                cell.firemove=false;
                            } else  cell.firemove=true;
 
 
 
 
                    }
                  
                    if(cell.element==='tar'){
                        const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element !=='empty' && grid[r][c].element !=='tar' && grid[r][c].element !=='fire' 
                        );
                            
 
                            if(Adjacent){
                                if(Math.random() < 0.4){
                                cell.tarmove=false;
                                }
                            } else  cell.tarmove=true;
 
 
 
 
                    }
                    if(cell.element === 'empty'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacentbu = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'bubble'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacentbu) {
                            
 
 
 
 
 
 
 
 
                            cell.element='bubbleo';
                               
                            
                        }
            }
            if(cell.element === 'empty'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacentpo = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'popcorn'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacentpo) {
                            
 
 
 
 
 
 
 
 
                            cell.element='popcorno';
                               
                            
                        }
            }
            if(cell.element === 'bubbleo'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'bubble'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            
 
 
 
 
 
 
 
 
                        
                               
                            
                        } else cell.element='empty';
            }
            if(cell.snap === true){
                cell.stop=true;
                
   if(Math.random() < 0.3){
    cell.snap = false;
    
    if(Math.random() < 0.5){
        cell.element = 'dust';
    
    } else cell.element = 'empty';

 }

}
if(cell.snapnm === true){

                cell.stop=true;
               
   if(Math.random() < 0.3){
    cell.snapnm = false;
    
    if(Math.random() < 0.5){
        cell.element = 'dust';
    
    } else cell.element = 'empty';

 }
 
}
            if(cell.element === 'popcorno'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'popcorn'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            
 
 
 
 
 
 
 
 
                        
                               
                            
                        } else cell.element='empty';
            }
            if(cell.element === 'empty' ){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacentfo = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'foam'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacentfo) {
                            
 
 
 
 
 
 
 
 
                            cell.element='foamo';
                               
                            
                        }
            }
            if(cell.element === 'foamo'  ){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'foam'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            
 
 
 
 
 
 
 
 
                        
                               
                            
                        } else cell.element='empty';
            }
            if(cell.element === 'empty'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacentra = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'radiation'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacentra) {
                            
 
 
 
 
 
 
 
 
                            cell.element='radiationo';
                               
                            
                        }
            }
            if(cell.element === 'radiationo'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                             {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'radiation'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            
 
 
 
 
 
 
 
 
                        
                               
                            
                        } else cell.element='empty';
            }
            if(cell.element==='empty'){
    if(cell.e===true){
    cell.e=false;
    }
 }
 if(cell.element==='empty'){
                    cell.jumpdelay = 0;
                    cell.movedelay = 0;
                 }
                 if(cell.element==='empty'){
                            cell.ink=false;
                        }
                        if (cell.element === 'empty'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let emptyAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'virus'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (emptyAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay === 41) {
                                cell.element = 'virus';
                               
                            }
                        } else {
                            // Reset delay if not adjacent to grass
                            cell.delay = 0;
                        }
                    }
    }
                
 
 
                    if (showVoxels) {
                        ctx.strokeStyle = 'black';
                        ctx.strokeRect(col * voxelSize, row * voxelSize, voxelSize, voxelSize);
                    }
                }
            }
             
        }
        const blackHoleRadius = 10; // Define the radius of influence for the black hole
        const blackHoleRadiuss = 100; // Define the radius of influence for the black hole
        const starRadius = 5; // Define the radius of influence for the black hole
     
 const pullSpeed = 0.05; // Speed at which elements are pulled towards the black hole
 const pullSpeeds = 0.05; // Speed at which elements are pulled towards the black hole
 const starpullSpeed = 0.001; // Speed at which elements are pulled towards the black hole
 const missileSpeed = 0.01; // Speed at which elements are pulled towards the black hole
 // Function to apply gravity logic to the grid
let gravity = 'down';

        function updateGrid() {

            let row = rows - 1;
for (let col = 0; col < cols; col++) {
    const cell = grid[row][col];
    // Process the cell (row is fixed, col moves)
}

// Then, process all rows, one column at a time:
for (let col = 0; col < cols; col++) {
    for (let row = rows - 1; row >= 0; row--) {
      
        const cell = grid[row][col];
        if(nowalls === true){
                    if(cell.element){
                        if(row === rows - 1 || col === 0 || col === cols - 1){
                            cell.element = 'empty';
                        }
                    }
                }
                    if (heatDeathActive) {
                        elements.empty.color = 'rgba(181, 109, 109, 0.5 )'
                        if(cell.element !== 'empty'){
                            cell.element = 'lava';
                        }
                    }
                    
                  if(cell.selected===true){
                    continue;
                  }
                  
                  
                    if (cell.stop === true) {
                        
                        cell.stop = false;
            continue; // Skip this iteration and don't update the cell
                    
        }
        if(elements[grid[row][col].element].liquid === true && cell.ldirty === true){
            continue;
        }
        
                    if(cell.element==='empty'){
                      
                     cell.dirty = true;
                       
                    } else{ cell.dirty = false;}
                    if(cell.dirty === true){
                        continue;
                    }
                    
                  
                  
        
          
                    // Ice melting into water
                    if (cell.element === 'ice') {
                        if (Math.random() < 0.005) {
                            grid[row][col].element = 'water';
                        }
                    }
                    if (cell.element === 'syrup') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'syrup';
 
        
        
 
     }}
  
     if (cell.element === 'syrup') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'syrup';
 
        
        
 
     }}
     if (cell.element === 'liquidN') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'liquidN';
 
        
        
 
     }}
     if (cell.element === 'liquidN') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'liquidN';
 
        
        
 
     }}
     if (cell.element === 'human') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'human';
 
         
        
 
     }}
     if (cell.element === 'water') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'water';
 
         // Swap the ages
        
 
     }}
     if (cell.element === 'sugar') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'sugar';
 
        
 
      
     }}
     if (cell.element === 'lava') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'lava';
 
         
        
 
     }}
     if (cell.element === 'mercury') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'mercury';
 
         
        
 
     }}
     if (cell.element === 'mercury') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'mercury';
 
         
        
 
     }}
     if (cell.element === 'human') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'human';
 
         
        
 
     }}
     if (cell.element === 'gunpowder') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'gunpowder';
 
         
        
 
     }}
     if (cell.element === 'nitro') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'nitro';
 
         
        
 
     }}
     if (cell.element === 'nitro') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'nitro';
 
         
        
 
     }}
     if (cell.element === 'gunpowder') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'gunpowder';
 
         
        
 
     }}
     if (cell.element === 'moltensand') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'moltensand';
 
      
        
 
     }}
     if (cell.element === 'magma') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
         
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'magma';
 
        
 
     }}
     if (cell.element === 'sand') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'sand';
 
       
     
 
     }}
     if (cell.element === 'oil') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let oilCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'oil';
 
       
     
 
     }}
     if (cell.element === 'dirt') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'dirt';
 
     
       
 
     }}
     
     if (cell.element === 'oil') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'oil';
 
      
        
 
     }}
     if (cell.element === 'oil') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'oil';
 
        
        
 
     }}
 
     if (cell.element === 'water') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'water';
 
        
        
 
     }}
 
     if (cell.element === 'concrete') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'concrete';
 
        
        
 
     }}
     if (cell.element === 'concrete') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'concrete';
 
        
        
 
     }}
     if (cell.element === 'sugar') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'sugar';
 
        
 
     }}
     if (cell.element === 'lava') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'lava';
 
        
 
     }}
     if (cell.element === 'milk') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'milk';
 
        
 
     }}
     if (cell.element === 'milk') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'milk';
 
        
 
     }}
     if (cell.element === 'sawdust') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'sawdust';
 
        
 
     }}
     if (cell.element === 'sawdust') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'sawdust';
 
        
 
     }}
     if (cell.element === 'gravel') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'gravel';
 
        
 
     }}
     if (cell.element === 'gravel') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'gravel';
 
        
 
     }}
     if (cell.element === 'moltensand') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'moltensand';
 
         
        
 
     }}
     if (cell.element === 'saltwater') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'saltwater';
 
         
        
 
     }}
     if (cell.element === 'saltwater') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'saltwater';
 
         
        
 
     }}
     if (cell.element === 'pwater') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'pwater';
 
         
        
 
     }}
     if (cell.element === 'pwater') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'pwater';
 
         
        
 
     }}
     if (cell.element === 'salt') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'salt';
 
         
        
 
     }}
     if (cell.element === 'salt') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'salt';
 
         
        
 
     }}
     if (cell.element === 'magma') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'magma';
 
        
 
     }}
     if (cell.element === 'sand') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'sand';
 
       
 
     }}
     if (cell.element === 'dirt') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'dirt';
 
         
       
 
     }}
     if (cell.element === 'charcoal') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'charcoal';
 
         
       
 
     }}
     if (cell.element === 'charcoal') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'charcoal';
 
         
       
 
     }}
     if (cell.element === 'clay') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'steam') {
         // Swap water with steam
         let steamCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'steam';
         grid[row + 1][col].element = 'clay';
 
         
       
 
     }}
     if (cell.element === 'clay') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'smoke') {
         // Swap water with steam
         let smokeCell = grid[row + 1][col];
 
         // Swap the elements
         grid[row][col].element = 'smoke';
         grid[row + 1][col].element = 'clay';
 
         
       
 
     }}
     if (cell.element === 'concrete') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let waterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'concrete';
 
       
 
     }}
     if (cell.element === 'gravel') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let waterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'gravel';
 
       
 
     }}
     if (cell.element === 'human') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let waterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'human';
 
       
 
     }}
     if (cell.element === 'snow') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let waterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'snow';
 
       
 
     }}
     if (cell.element === 'charcoal') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let waterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'charcoal';
 
       
 
     }}
     if (cell.element === 'grenade') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let waterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'grenade';
 
       
 
     }}
     if (cell.element === 'clay') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let waterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'clay';
 
       
 
     }}
     if (cell.element === 'mercury') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let waterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'mercury';
 
       
 
     }}
     if (cell.element === 'cactus') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let waterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'cactus';
 
       
 
     }}
     if (cell.element === 'gunpowder') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'water') {
         // Swap water with steam
         let waterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'water';
         grid[row + 1][col].element = 'gunpowder';
 
       
 
     }}
     if (cell.element === 'gunpowder') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'pwater') {
         // Swap water with steam
         let pwaterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'pwater';
         grid[row + 1][col].element = 'gunpowder';
 
       
 
     }}
     if (cell.element === 'dirt') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'pwater') {
         // Swap water with steam
         let pwaterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'pwater';
         grid[row + 1][col].element = 'dirt';
 
       
 
     }}
     if (cell.element === 'concrete') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'pwater') {
         // Swap water with steam
         let pwaterCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'pwater';
         grid[row + 1][col].element = 'concrete';
 
       
 
     }}
     if (cell.element === 'gunpowder') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'gunpowder';
 
       
 
     }}
     if (cell.element === 'dirt') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'dirt';
 
       
 
     }}
     if (cell.element === 'sand') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'sand';
 
       
 
     }}
     if (cell.element === 'cactus') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'cactus';
 
       
 
     }}
     if (cell.element === 'mercury') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'mercury';
 
       
     }}
     if (cell.element === 'salt') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'salt';
 
       
     }}
     if (cell.element === 'snow') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'snow';
 
       
     }}
     if (cell.element === 'milk') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'milk';
 
       
     }}
     if (cell.element === 'human') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'human';
 
       
     }}
     if (cell.element === 'sugar') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'sugar';
 
       
     }}
     if (cell.element === 'concrete') {
     // Check if steam is directly below the water
     if (row < rows - 1 && grid[row + 1][col].element === 'nitro') {
         // Swap water with steam
         let nitroCell = grid[row - 1][col];
 
         // Swap the elements
         grid[row][col].element = 'nitro';
         grid[row + 1][col].element = 'concrete';
 
       
     }}
     if(cell.element==='virus'){
         cell.age++;
         if(cell.age >=39){
             if (Math.random() < 0.6) {
             cell.element='empty'
             cell.age=0;}
         }
     }
     if(cell.element==='shock'){
         cell.age++;
         if(cell.age >=4){
             if (Math.random() < 0.4) {
             cell.element='empty'
             cell.age=0;}
         }
     }
    
     
     
     
   if(cell.element === 'nuke'){

    if(row < rows - 1){
        if(grid[row+1][col].element === 'empty' || grid[row+1][col].element === 'fire' || grid[row+1][col].element === 'smoke' || grid[row+1][col].element === 'nuke'){
            grid[row+1][col].element = 'nuke';
            initializeCell(row, col, 'empty');

        } else cell.element = 'nuexplosion';
    } else cell.element = 'nuexplosion';
   }
   
            if(cell.element === 'cf') {
                 // List of possible elements to replace the virus
                
                 const possibleElements = Object.keys(elements).filter(el => elements[el].type === 'cf');
                 const randomElement = possibleElements[Math.floor(Math.random() * possibleElements.length)];
 
                 // Replace virus with a random element
                 cell.element = randomElement;
                 cell.age = 0; // Reset age when replaced
             }
             if(cell.element === 'fp') {
                 // List of possible elements to replace the virus
                
                 const possibleElements = Object.keys(elements).filter(el => elements[el].type === 'fp');
                 const randomElement = possibleElements[Math.floor(Math.random() * possibleElements.length)];
 
                 // Replace virus with a random element
                 cell.element = randomElement;
                 cell.age = 0; // Reset age when replaced
             }
             if(cell.element === 'coral') {
                 // List of possible elements to replace the virus
                
                 const possibleElements = Object.keys(elements).filter(el => elements[el].type === 'co');
                 const randomElement = possibleElements[Math.floor(Math.random() * possibleElements.length)];
 
                 // Replace virus with a random element
                 cell.element = randomElement;
                 cell.age = 0; // Reset age when replaced
             }
              if(cell.element === 'balloon') {
                 // List of possible elements to replace the virus
                
                 const possibleElements = Object.keys(elements).filter(el => elements[el].type === 'balloon');
                 const randomElement = possibleElements[Math.floor(Math.random() * possibleElements.length)];
 
                 // Replace virus with a random element
                 cell.element = randomElement;
                 cell.age = 0; // Reset age when replaced
             }
             
           
            
      
     if (cell.element === 'grass'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let  vAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'virus'
                        );
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (vAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 27) {
                             if (Math.random() < 0.8) {
                                cell.element = 'virus';
                             } 
                            }
                        } else {
                            // Reset delay if not adjacent to grass
                            cell.delay = 0;
                        }
 
     }
   
   
     if (cell.element === 'Leaf'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let  lAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'virus'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (lAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 27) {
                             if (Math.random() < 0.8) {
                                cell.element = 'virus';
                             }
                            }
                        } else {
                            // Reset delay if not adjacent to grass
                            cell.delay = 0;
                        }
 
     }
    
     if (cell.element === 'steel'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let  stAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (stAdjacent) {
                            cell.age++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.age >= 300) {
                             if (Math.random() < 0.8) {
                                cell.element = 'rust';
                                cell.age=0;
                             }
                            }
                        } 
 
     }
     if (cell.element === 'sulfur'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        const  Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                           
 
 
 
 
 
 
 
 
                           
                             
                                cell.element = 'sa';
                               
                             
                            }
                        } 
 
     
     if (cell.element === 'steel'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let  stAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'empty'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (stAdjacent) {
                            cell.delay++;
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 1000) {
                             if (Math.random() < 0.8) {
                                cell.element = 'rust';
                             }
                            }
                        } 
 
     }

     if(cell.element==='copper'){
         cell.age++;
         if(cell.age>500){
            
             cell.element='copper2';
             cell.age=0;
             
         }
     }
     if(cell.element==='copper2'){
         cell.age++;
         if(cell.age>500){
            
             cell.element='copper3';
             cell.age=0;
             
         }
     }
     if(cell.element==='copper3'){
         cell.age++;
         if(cell.age>500){
            
             cell.element='copper4';
             cell.age=0;
             
         }
     }
     if(cell.element==='copper4'){
         cell.age++;
         if(cell.age>500){
            
             cell.element='copper5';
             cell.age=0;
             
         }
     }
     if (cell.element === 'tnt'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let tntAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'fire'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (tntAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 10) {
                                cell.element = 'Explosion';
                               
                            }
                        } else {
                            // Reset delay if not adjacent to grass
                            cell.delay = 0;
                        }
 
     }
    
     if (cell.element === 'fuse'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'fire'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            
 
 
 
 
 
 
 
 
                        
                                cell.element = 'flash';
                                
                               
                            
                        } 
                    }
                    if (cell.element === 'fuse'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        const fAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'flash'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (fAdjacent) {
                       
 
 
 
 
 
 
 
 
                          
                                cell.element = 'flash';
                              
                               
                            
                        } 
                    }
     if (cell.element === 'nitro'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let nAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'fire'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (nAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 10) {
                                cell.element = 'nb';
                               
                            }
                        } else {
                            // Reset delay if not adjacent to grass
                            cell.delay = 0;
                        }
 
     }
     if (cell.element === 'gunpowder'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let gunpAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'fire'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (gunpAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 10) {
                                cell.element = 'Explosion';
                               
                            }
                        } else {
                            // Reset delay if not adjacent to grass
                            cell.delay = 0;
                        }
 
     }
     if (cell.element === 'ice'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let wAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'Lava'  
                        );
                   
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (wAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 5) {
                                cell.element = 'water';
                               
                            }
                        } else {
                            // Reset delay if not adjacent to grass
                            cell.delay = 0;
                        }
 
     }
     
     if (cell.element === 'water'){
         const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
                        // Check for adjacent grass cells
                        let NAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'liquidN'  
                        );
                        
                      
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (NAdjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                          
                                cell.element = 'ice';
                             
                            cell.age=-50;
                        } 
 
     }
    
     
     if(cell.element==='laser'){
              cell.age++;
                   if(cell.age >= 0){
                        cell.element='empty';
                   }
                } 
                if(cell.element==='tractorbeam'){
              cell.age++;
                   if(cell.age >= 0){
                        cell.element='empty';
                   }
                } 
                if(cell.element==='freezeray'){
              cell.age++;
                   if(cell.age >= 0){
                        cell.element='empty';
                   }
                } 
                if(cell.element==='lasersource'){
              cell.age++;
                   if(cell.age >= 2){
                        cell.element='empty';
                   }
                } 
                if(cell.element==='tractorbeams'){
              cell.age++;
                   if(cell.age >= 2){
                        cell.element='empty';
                   }
                } 
                if(cell.element==='freezerays'){
              cell.age++;
                   if(cell.age >= 2){
                        cell.element='empty';
                   }
                } 
             
             
             
             if (cell.element === 'lasersource') {
                // Change the entire column below to laser
                for (let r = row + 1; r < rows; r++) {
                    if (grid[r][col].element === 'empty' || grid[r][col].element === 'laser') {
                        grid[r][col].element = 'laser'; // Change to laser
                        grid[r][col].age = 0;
                    } else {
                        break; // Stop if we hit a non-empty cell
                    }
                }
            }
            if (cell.element === 'freezerays') {
                // Change the entire column below to laser
                for (let r = row + 1; r < rows; r++) {
                    if (grid[r][col].element === 'empty' || grid[r][col].element === 'freezeray') {
                        grid[r][col].element = 'freezeray'; // Change to laser
                        grid[r][col].age = 0;
                    } else {
                        break; // Stop if we hit a non-empty cell
                    }
                }
            }
          
            if (cell.element === 'tractorbeams') {
                // Change the entire column below to laser
                for (let r = row + 1; r < rows; r++) {
                    
                    
                    

                    if (grid[r][col].element === 'empty' || grid[r][col].element === 'tractorbeam') {
                        grid[r][col].element = 'tractorbeam'; // Change to laser
                        grid[r][col].age = 0;
                    } else {
                        break; // Stop if we hit a non-empty cell
                    }
                }
            }
            if (cell.element === 'ufo3') {
                // Change the entire column below to laser
                for (let r = row + 1; r < rows; r++) {
                    
                    
                    

                    if (grid[r][col].element === 'empty' || grid[r][col].element === 'tractorbeam') {
                        grid[r][col].element = 'tractorbeam'; // Change to laser
                        grid[r][col].age = 0;
                    } else {
                        break; // Stop if we hit a non-empty cell
                    }
                }
            }
            if(cell.element){
                if(cell.tractorbeam === true){
                    cell.tlaserdelay++;
                }
            }
           if(cell.element!=='empty' && row > 0 && cell.element!=='tractorbeams' && cell.element!=='tractorbeam' && row < rows - 1 ){
            for (let r2 = row + 1; r2 > 0; r2--) {
                if(grid[r2][col].element==='tractorbeams' || grid[r2][col].element==='tractorbeam'){
                  cell.tractorbeam=true;
                    if( cell.tlaserdelay >= 3){
                       if(grid[row-1][col].element==='empty' || grid[row-1][col].element==='tractorbeam'){
                  
                    grid[row-1][col].element=cell.element;
                   cell.element= 'empty';
                   cell.tlaserdelay = 0;
                   cell.age=0;
                   cell.delay=0;
                       }
                }
                }
            }
           }
           if(freeze){
            if(cell.element === 'dirt'){
                cell.element = 'frozendirt';
            } else
            if(cell.element === 'grass'){
                cell.element = 'frozengrass';
            } else
            if(cell.element === 'water'){
                cell.element = 'ice';
                cell.age = -100;
            } else 
            if(cell.element === 'root'){
                elements.root.color = '#BE9D8A';
            } else 
            if(cell.element === 'log'){
                elements.log.color = '#B98374';
            } else 
            if(cell.element === 'Leaf'){
                elements.Leaf.color = '#8CB974';
            } else 
            if(cell.element !== 'empty'){
                cell.element = 'ice';
                cell.age = -100;

            }
            
           }
            

            if(cell.element==='stone'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'lava';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='star'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 10) {
                            
                       
                        
                                cell.element = 'supernova';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='lava'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            
            
            if(elements[grid[row][col].element].flammable){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 1) {
                            
                       
                        
                                cell.element = 'fire';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='antimatter'){
                cell.age++;
                if(cell.age>=3){
                    if (Math.random() < 0.3) {
                             
                    cell.element = 'empty';
                    cell.age=0;
                    }
                }
            }
            if(cell.element !== 'empty' && cell.element !== 'antimatter'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'antimatter'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                           
 
 
 
 
 
 
                            
                            
                            if (Math.random() < 0.92) {
                             
                                cell.ink=false;
                        
                                cell.element = 'antimatter';
                            }
                           
                        
            }
        }
        if(cell.element !== 'empty' && cell.element !== 'plasma' && cell.element !== 'blackhole' && cell.element !== 'star' && cell.element !== 'antimatter' ){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'plasma'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                           
 
 
 
 
 
 
                            
                            
                            if (Math.random() < 0.92) {
                             
                             
                        
                                cell.element = 'fire';
                            }
                           
                        
            }
        }
      
        if(cell.element !== 'empty' && cell.element !== 'star' && cell.element !== 'fire' && cell.element !== 'smoke' && cell.element !== 'supernova' && cell.element !== 'antimatter' && cell.element !== 'blackhole'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'star'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                           
 
 
 
 
 
 
                            
                            
                            if (Math.random() < 0.92) {
                             
                             
                        
                                cell.element = 'fire';
                            }
                           
                        
            }
        }

        if(cell.element !== 'empty' && cell.element !== 'midas_touch' ){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacentgold = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'midas_touch'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacentgold) {
                           
 
 
 
 
 
 
                            
                            
                          cell.element = 'gold';
                           cell.goldColor = getRandomColorBetween(elements.gold.color1, elements.gold.color2); // Store the random color
                        
            }
        }
            if(cell.element==='fire'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 1) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='water'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'steam';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='steam'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 0) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            
            if(cell.element==='sand'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 4) {
                            
                       
                        
                                cell.element = 'moltensand';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='moltensand'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='mud'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'dirt';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='dirt'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 5) {
                            
                       
                        
                                cell.element = 'magma';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='magma'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='ice'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 0) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='snow'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 1) {
                            
                       
                        
                                cell.element = 'water';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='glass'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'moltensand';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='obsidian'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'magma';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='concrete'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'stone';
                                cell.laserdelay = -2;
                            }
                        }
            }
            if(cell.element==='sugar'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 4) {
                            
                       
                        
                                cell.element = 'caramel';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='crystal'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'lava';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='basalt'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'magma';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='glitch'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 50) {
                            
                       
                        
                                cell.element = 'blackhole';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='blackhole'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 50) {
                            
                       
                        
                                cell.element = 'UExplosion';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='fly'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 0) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
    





            if(cell.element==='ash'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 0) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='liquidN'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'ice';
                                cell.laserdelay = 0;
                            }
                        }
            }
            
            if(cell.element==='milk'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 4) {
                            
                       
                        
                                cell.element = 'steam';
                                cell.laserdelay = 0;
                            }
                        }
            }
           
            if(cell.element==='hotsteel'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
                            cell.sage = (cell.sage + 2);
 
 
 
 
                            
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 15) {
                            
                                if(Math.random() < 0.2){
                                
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                                }
                            }
                        }
            }
            
            if(cell.element==='rust'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'magma';
                                cell.laserdelay = 0;
                            }
                        }
            }
              
            if(cell.element==='wetsponge'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'sponge';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='salt'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'crystal';
                                cell.laserdelay = 0;
                            }
                        }
            }
          
           
            if(cell.element==='quartz'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 4) {
                            
                       
                        
                                cell.element = 'crystal';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='fog'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 0) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='bone'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'stone';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='copper'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 4) {
                            
                       
                        
                                cell.element = 'copper2';
                                cell.laserdelay = 0;
                            }
                        }
            }
            
            if(cell.element==='copper2'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'copper3';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='copper3'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'copper4';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='copper4'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'copper5';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='copper5'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='mercury'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 5) {
                            
                       
                        
                                cell.element = 'steel';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='acid'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='plastic'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'pwater';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='diorite'){
                 const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'moltendiorite';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='granite'){
                 const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'moltengranite';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='moltendiorite'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='moltengranite'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='pwater'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 4) {
                            
                       
                        
                                cell.element = 'water';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='wetsand'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'sand';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='saltwater'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'salt';
                                cell.laserdelay = 0;
                            }
                        }
            }
            
            if(cell.element==='brick'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='liquidgallium'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='clay'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 5) {
                            
                       
                        
                                cell.element = 'solidclay';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='solidclay'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 5) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
          
            if(cell.element==='aluminum'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'steel';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element === 'lightning'){
        cell.age++;
        if(cell.age > 5){
            cell.element='empty';
            cell.age=0;
            cell.delay=0;
            cell.lightning=0;
        }
     }
            if(cell.element==='silver'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'rust';
                                cell.laserdelay = 0;
                            }
             
                        }
            }
             
                           
            if(cell.element==='zinc'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'steel';
                                cell.laserdelay = 0;
                            }
                        }
            }


            if(cell.element==='gravel'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'magma';
                                cell.laserdelay = 0;
                            }
                        }
                    }
                    if(cell.element==='tin'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'moltentin';
                                cell.laserdelay = 0;
                            }
                        }
                    }
                    if(cell.element === 'pointer'){
                        cell.age++;
                        if(cell.age > 4){
                            grid[row][col] = cell.lastelement;
                        }
                    }
                    if(cell.element==='moltentin'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
                    }
                   
                    if(cell.element==='wind'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 1) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
                    }
                    
                    if(cell.element==='gold'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'moltengold';
                                cell.laserdelay = 0;
                            }
                        }
                    }
              
                    if(cell.element==='titanium'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 3) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
                    }
                    if(cell.element==='lead'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'moltenlead';
                                cell.laserdelay = 0;
                            }
                        }
                    }
                    if(cell.element === 'rain'){
                        if(row < rows - 1){
                       if(grid[row+1][col].element !== 'empty' && grid[row+1][col].element !== 'rain'){
                        initializeCell(row,col,'empty');
                       }
                    } else initializeCell(row,col,'empty');
                    }
                    if(cell.element === 'stormcloud'){
                        cell.age++;
                        const adjacentCells = [{
                              row: row - 1,
                              col: col
                          }, // Up
                         
                          {
                              row: row,
                              col: col - 1
                          }, // Left
                          {
                              row: row,
                              col: col + 1
                          } // Right
                      ];
                      adjacentCells.forEach(({
                                    row: r,
                                    col: c
                                }) => {
                                    if(Math.random() < 0.55){
                                    if(grid[r] && grid[r][c] && grid[r][c].element === 'empty'){
                                        if(cell.age < cell.size){
                                        grid[r][c].element = 'stormcloud';
                                        grid[r][c].age = cell.age;
                                        grid[r][c].size = cell.size;
                                        }
                                    }
                                }
                                });
                    }
                    if(cell.element === 'raincloud'){
                        cell.age++;
                        const adjacentCells = [{
                              row: row - 1,
                              col: col
                          }, // Up
                         
                          {
                              row: row,
                              col: col - 1
                          }, // Left
                          {
                              row: row,
                              col: col + 1
                          } // Right
                      ];
                      adjacentCells.forEach(({
                                    row: r,
                                    col: c
                                }) => {
                                    if(Math.random() < 0.55){
                                    if(grid[r] && grid[r][c] && grid[r][c].element === 'empty'){
                                        if(cell.age < cell.size){
                                        grid[r][c].element = 'raincloud';
                                        grid[r][c].age = cell.age;
                                        grid[r][c].size = cell.size;
                                        }
                                    }
                                }
                                });
                    }

                    if(cell.element === 'cloud'){
                        
                       
                        cell.age++;
                        const adjacentCells = [{
                              row: row - 1,
                              col: col
                          }, // Up
                         
                          {
                              row: row,
                              col: col - 1
                          }, // Left
                          {
                              row: row,
                              col: col + 1
                          } // Right
                      ];
                      adjacentCells.forEach(({
                                    row: r,
                                    col: c
                                }) => {
                                    if(Math.random() < 0.55){
                                    if(grid[r] && grid[r][c] && grid[r][c].element === 'empty'){
                                    
                                        if(cell.age < cell.size){
                                        grid[r][c].element = 'cloud';
                                        grid[r][c].age = cell.age;
                                        grid[r][c].size = cell.size;
                                        }
                                    }
                                }
                                });
                    }
                    if(cell.element === 'snowcloud'){
                        
                       
                        cell.age++;
                        const adjacentCells = [{
                              row: row - 1,
                              col: col
                          }, // Up
                         
                          {
                              row: row,
                              col: col - 1
                          }, // Left
                          {
                              row: row,
                              col: col + 1
                          } // Right
                      ];
                      adjacentCells.forEach(({
                                    row: r,
                                    col: c
                                }) => {
                                    if(Math.random() < 0.55){
                                    if(grid[r] && grid[r][c] && grid[r][c].element === 'empty'){
                                    
                                        if(cell.age < cell.size){
                                        grid[r][c].element = 'snowcloud';
                                        grid[r][c].age = cell.age;
                                        grid[r][c].size = cell.size;
                                        }
                                    }
                                }
                                });
                    }
                    if(cell.element === 'stormcloud'){
                        if(cell.age > 1000){
                            if(Math.random() < 0.01){

                                cell.element = 'empty';
                            }
                        }
                    }
                    
                      if(cell.element === 'raincloud'){
                        if(cell.age > 6000){
                            if(Math.random() < 0.01){

                                cell.element = 'empty';
                            }
                        }
                    }
                    if(cell.element === 'cloud'){
                        if(cell.age > 7000){
                            if(Math.random() < 0.01){

                                cell.element = 'empty';
                            }
                        }
                    }
                    if(cell.element === 'stormcloud' && row < rows - 1){
                        if(grid[row+1][col].element === 'empty'){
                            if(Math.random() < 0.01){
                            grid[row+1][col].element = 'rain';
                            }
                        }
                    }
                    if(cell.element === 'snowcloud' && row < rows - 1){
                        if(grid[row+1][col].element === 'empty'){
                            if(Math.random() < 0.002){
                            grid[row+1][col].element = 'snow2';
                            }
                        }
                    }
                    if(cell.element === 'raincloud' && row < rows - 1){
                        if(grid[row+1][col].element === 'empty'){
                            if(Math.random() < 0.007){
                            grid[row+1][col].element = 'rain';
                            }
                        }
                    }
                    if(cell.element === 'stormcloud' && row < rows - 1){
                        if(grid[row+1][col].element === 'empty'){
                            if(cell.age > 50){
                                if( cell.age < 5000){
                            if(Math.random() < 0.001){
                            grid[row+1][col].element = 'lightning';
                            }
                            }
                        }
                        }
                    }
                    if(cell.element==='moltenlead'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
                    }

                    if(cell.element==='magnesium'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 5) {
                            
                       
                        
                                cell.element = 'wire';
                                cell.laserdelay = 0;
                            }
                        }
                    }
                    
                    
                    if(cell.element==='tornado' && row < rows -1){
                        if(grid[row+1][col].element==='empty'){
                            grid[row+1][col].element='tornado';
                            cell.element='empty';
                        }
                    }
                    if(cell.element==='platinum'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 5) {
                            
                       
                        
                                cell.element = 'moltenpla';
                                cell.laserdelay = 0;
                            }
                        }
            }
            if(cell.element==='moltenpla'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
            }
                    if(cell.element==='nickel'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'aluminum';
                                cell.laserdelay = 0;
                            }
                        }
                    }
                    if(cell.element==='tuff'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'magma';
                                cell.laserdelay = 0;
                            }
                        }
                    }
                    if(cell.element==='limestone'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'lava';
                                cell.laserdelay = 0;
                            }
                        }
                    }
                    if(cell.element === 'chezburger'){
                        placeShape(row, col, chezburger);
                    }
                    if(cell.element==='cheese'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'meltedcheese';
                                cell.laserdelay = 0;
                            }
                        }
                    }
                    if(cell.element==='caramel'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'fire';
                                cell.laserdelay = 0;
                            }
                        }
                    }
                    if(cell.element==='meltedcheese'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 2) {
                            
                       
                        
                                cell.element = 'fire';
                                cell.laserdelay = 0;
                            }
                        }
                    }
                    
                    if(cell.element==='bronze'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 5) {
                                
                       
                                if(Math.random < 0.12){
                                cell.element = 'tin';
                                } else {
                                    cell.element='copper';
                                }
                                cell.laserdelay = 0;
                            }
                        }
                    }
                    if(cell.element==='moltengold'){
                const laseradjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const laserAdjacent = laseradjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'laser'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (laserAdjacent) {
                            cell.laserdelay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.laserdelay >= 1) {
                            
                       
                        
                                cell.element = 'empty';
                                cell.laserdelay = 0;
                            }
                        }
                    }
                    if(cell.element==='aluminum'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'lava'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 2) {
                            
                       
                                if(Math.random() < 0.1){
                                cell.element = 'empty';
                                } else cell.element = 'fire';
                                cell.delay = 0;
                                
                            }
                        }
                    }
                    if(cell.element==='gasoline'){
                        const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            }, // Right
                            {
                                row: row - 1,
                                col: col - 1
                            }, // Up-Left (Diagonal)
                            {
                                row: row - 1,
                                col: col + 1
                            }, // Up-Right (Diagonal)
                            {
                                row: row + 1,
                                col: col - 1
                            }, // Down-Left (Diagonal)
                            {
                                row: row + 1,
                                col: col + 1
                            } // Down-Right (Diagonal)
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'fire'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            
 
 
 
 
 
 
 
 
                            
                       
                             
                                cell.element = 'gasolinef';
                               
                            }
                        }
                        if(cell.element==='gasoline'){
                        const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            }, // Right
                            {
                                row: row - 1,
                                col: col - 1
                            }, // Up-Left (Diagonal)
                            {
                                row: row - 1,
                                col: col + 1
                            }, // Up-Right (Diagonal)
                            {
                                row: row + 1,
                                col: col - 1
                            }, // Down-Left (Diagonal)
                            {
                                row: row + 1,
                                col: col + 1
                            } // Down-Right (Diagonal)
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'gasolinef'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            
 
 
 
 
 
 
 
 
                            
                       
                             
                                cell.element = 'gasolinef';
                               
                            }
                        }
                    
                   if(cell.element === 'rwaste' && row > 0){
                    if(grid[row-1][col].element === 'empty'){
                        if(Math.random() < 0.001){
                            grid[row-1][col].element = 'radiation';
                        }
                    }
                   }
                   if(cell.element === 'gasolinef'){
                    if(Math.random() < 0.05){
                        initializeCell(row, col, 'empty');
                    }
                   }
                   if(cell.element === 'gasolinef' && row > 1){
                  
                    if(Math.random() < 0.1){
                        if(Math.random() < 0.5){
                            if(grid[row-1][col].element === 'empty'){
                       grid[row-1][col].element = 'fire';
                            }

                        } else      if(grid[row-2][col].element === 'empty' && grid[row-1][col].element === 'empty' || grid[row-1][col].element === 'fire'){
                            grid[row-2][col].element = 'fire';
                        }
                    }
                }
                   
                  
                    if(cell.element==='c4'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'shock'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                           
 
 
 
 
 
 
 
 
                            
                              cell.element='Explosion';
                              cell.age=0;
                              cell.delay=0;
                            
                                
                            }
                        
                    }
                   
                    if(cell.element!=='dryice' && cell.element!=='empty' ){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'dryice'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 10) {
                            
                       
                                cell.element='ice';
                                cell.delay = 0;
                                
                            }
                        }
                    }
                    
                    if(cell.element==='cheese'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'fire'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 5) {
                            
                       
                              
                                cell.element = 'meltedcheese';
                               
                                cell.delay = 0;
                                
                            }
                        }
                    }
                    if(cell.element === 'radiation'){
                        if(Math.random() < 0.001){
                            cell.element = 'empty';
                        }
                    }
                    if(cell.element==='corn'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && elements[grid[r][c].element].boil === true
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 2) {
                            
                       
                              
                                cell.element = 'popcorn';
                               
                                cell.delay = 0;
                                
                            }
                        }
                    }
                    if(cell.element==='cb'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'battery'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            
 
 
 
 
 
 
 
 
                            
                       
                              
                                cell.cb=false;
                                
                            } else  cell.cb=true;
                        
                    }
             
                
                    if(cell.element!=='cb' && cell.element!=='empty'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element ==='cb' && grid[r][c].cb === true
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            
 
 
 
 
 
 
 
 
                          cell.cbdelay++;
                        }
                    }
                
            
                    if(cell.element!=='empty'){
                const adjacentCellsbl = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacentbl = adjacentCellsbl.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'bleach'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacentbl) {
                            
 
 
 
 
 
 
 
 
                            
                            
                       
                              
                                cell.ink = false;
                               
                                
                                
                            }
                        }
                        if(cell.element==='fireflyb'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'firefly'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            
 
 
 
 
 
 
 
 
                            
                            
                       
                              
                                
                               
                                
                                
                            } else cell.element ='empty';
                        }
                        if(cell.element!=='empty'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacentso = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'soap'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacentso) {
                            
 
 
 
 
 
 
 
 
                            
                            
                       
                              
                                cell.ink = false;
                               
                                
                                
                            }
                        }
                        if(cell.element==='ice'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'freezeray'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) { 
                            cell.laserdelay++;
                            if(cell.laserdelay>=10){
                                cell.element='empty';
                                cell.laserdelay=0;
                            }
                        }
                    }
                        if(cell.element!=='empty' && cell.element !== 'ice' && cell.element !== 'freezeray' && cell.element !== 'freezerays'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacentfz = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'freezeray'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacentfz) {
                            cell.frdelay++;
                            if(cell.frdelay>=5){
                                cell.element='ice';
                                cell.frdelay = 0;
                            }
 
 
 
 
 
 
 
 
                            
                            
                       
                              
                              
                               
                                
                                
                            }
                        }
                    
                     










                    if(cell.element==='tin'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'lava'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 2) {
                            
                       
                                if(Math.random() < 0.1){
                                cell.element = 'empty';
                                } else if(Math.random()<0.1){
                                    cell.element = 'moltentin';} else {
                                        cell.element = 'fire';
                                cell.delay = 0;
                                    }
                                
                            }
                        }
                    }
                   if(cell.element === 'clusterbomb'){
                    if(row < rows - 1){
                    if(grid[row+1][col].element === 'empty'){
                        grid[row+1][col].element ='clusterbomb';
                        cell.element = 'empty';
                    } else cell.element = 'cexplosion';
                } else cell.element = 'cexplosion';
                   }
                   
                    if(cell.element==='chlorine'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'charcoal'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 2) {
                            
                       
                                
                                grid[row-1][col].element='fire';
                                cell.delay = 0;
                                
                            }
                        }
                    }
                    if(cell.element === 'fish'){
                        cell.delay++;
                        if(row < rows - 1){
                            if(cell.delay>0){
                          
                          if(grid[row+1][col].element === 'empty'){
                              grid[row+1][col].element = 'fish';
                              cell.element = 'empty';
                              cell.delay=0;
                          }
                        }
                      
                  }
                    }
                    if(cell.element==='snail'){
                       
                            if(row < rows - 1 && grid[row+1][col].element === 'empty'){
                                grid[row+1][col].element = 'snail';
                                initializeCell(row, col, 'empty');
                            } else{
                                if(Math.random() < 0.01){
                                    if(Math.random() < 0.5){
                                        if(col > 0){
                                        if(grid[row][col-1].element === 'empty'){
                                            grid[row][col-1].element = 'snail';
                                            initializeCell(row,col,'empty');
                                        } else if(row > 0 && grid[row-1][col].element === 'empty' && grid[row-1][col-1].element === 'empty'){
                                            grid[row-1][col-1].element = 'snail';
                                            initializeCell(row,col,'empty');
                                        }
                                    }
                                
                                } else   if(col < cols - 1){  
                                    if(grid[row][col+1].element === 'empty'){
                                            grid[row][col+1].element = 'snail';
                                            initializeCell(row,col,'empty');
                                        } else if(row > 0 && grid[row-1][col].element === 'empty' && grid[row-1][col+1].element === 'empty'){
                                            grid[row-1][col+1].element = 'snail';
                                            initializeCell(row,col,'empty');
                                        }
                                    }
                            }
                        }

                        }
                    
                    if(cell.element === 'fish'){
               
                      
                  
                    
    
                  
            
            
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
                        
                        if(Adjacent){
                         
                            if(Math.random() < 0.4){
                            const randomdirection1 = Math.floor(Math.random() * adjacentCells.length);
                            const randomDirection2 = adjacentCells[randomdirection1];

                            const newRow = randomDirection2.row;
                            const newCol = randomDirection2.col;
                           if(newRow < rows - 1 && newRow > 0 && newCol > 0 && newCol < cols - 1){
                            if(grid[newRow][newCol].element !== 'water'){} else{
                                grid[row][col].element = 'water';
                            grid[newRow][newCol].element = 'fish';
                            
                            
                           }
                        }
                            }
                        } else   if(row < rows - 1){
       if(grid[row+1][col].element !== 'empty'){
       if(Math.random() < 0.2) fishjump(cell, row, col);
       }
   } else if(Math.random() < 0.2) fishjump(cell, row, col);

                    }
  if(cell.element === 'ghost'){
               
                      
                  
                    
    
                  
            
            
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            }, // Right
                            {
                                row: row - 1,
                                col: col - 1
                            }, // Up-Left (Diagonal)
                            {
                                row: row - 1,
                                col: col + 1
                            }, // Up-Right (Diagonal)
                            {
                                row: row + 1,
                                col: col - 1
                            }, // Down-Left (Diagonal)
                            {
                                row: row + 1,
                                col: col + 1
                            } // Down-Right (Diagonal)
                        ];
                       
                        
                       
                         
                            if(Math.random() < 0.8){
                            const randomdirection1 = Math.floor(Math.random() * adjacentCells.length);
                            const randomDirection2 = adjacentCells[randomdirection1];

                            const newRow = randomDirection2.row;
                            const newCol = randomDirection2.col;
                           if(newRow < rows - 1 && newRow > 0 && newCol > 0 && newCol < cols - 1){
                            if(grid[newRow][newCol].element !== 'empty'){
                                const lastelement =  grid[newRow][newCol].element;
                                grid[newRow][newCol].element = 'ghost';
                                cell.element = lastelement;

                            } else{
                                grid[row][col].element = 'empty';
                            grid[newRow][newCol].element = 'ghost';
                            
                            
                           }
                        }
                            }
                        }
                       
                         if(cell.element === 'static'){
                            if(Math.random() < 0.1){
                                grid[row][col] = cell.lastelement;
                            }
                         }

                        
                       
                       
                    if (cell.element === 'ant') {
    const directions = [
        { row: row - 1, col: col },  // Up
        { row: row + 1, col: col },  // Down
        { row: row, col: col - 1 },  // Left
        { row: row, col: col + 1 },  // Right
    ];

    const diagonals = [
        { row: row - 1, col: col - 1 },  // Up-Left (Diagonal)
        { row: row - 1, col: col + 1 },  // Up-Right (Diagonal)
        { row: row + 1, col: col - 1 },  // Down-Left (Diagonal)
        { row: row + 1, col: col + 1 },  // Down-Right (Diagonal)
    ];

    const below = row + 1 < rows ? grid[row + 1][col].element : 'solid'; // Check below
    const leftWall = col - 1 >= 0 ? grid[row][col - 1].element : 'empty'; // Check left wall
    const rightWall = col + 1 < cols ? grid[row][col + 1].element : 'empty'; // Check right wall
    const above = row - 1 >= 0 ? grid[row - 1][col].element : 'solid'; // Check above (ceiling)

    // Function to check if the surface is solid (non-empty)
    const isSolid = (element) => element !== 'empty';

    // If the ant is on the ground (below), it can only move left, right, or fall
    if (below === 'empty' && !isSolid(leftWall) && !isSolid(rightWall)) {
        const fallRow = row + 1;
        if (fallRow < rows && grid[fallRow][col].element === 'empty') {
            grid[row][col].element = 'empty';
            grid[fallRow][col].element = 'ant';
        }
    } 
    // If the ant is on a left wall, allow movement along the wall or down (but prevent walking off)
    else if (isSolid(leftWall)) {
        const directionsForLeftWall = [
            { row: row, col: col - 1 },  // Move left (move along the wall)
            { row: row + 1, col: col },  // Move down (move along the wall)
            { row: row - 1, col: col },  // Move up (move along the wall)
            { row: row, col: col + 1 },  // Move right (move along the wall)
        ];

        const randomDir = directionsForLeftWall[Math.floor(Math.random() * directionsForLeftWall.length)];
        const newRow = randomDir.row;
        const newCol = randomDir.col;

        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
            const targetCell = grid[newRow][newCol];
            if (targetCell.element === 'empty') {
                grid[row][col].element = 'empty';
                grid[newRow][newCol].element = 'ant';
            }
        }
    } 
    // If the ant is on a right wall, allow movement along the wall or down (but prevent walking off)
    else if (isSolid(rightWall)) {
        const directionsForRightWall = [
            { row: row, col: col + 1 },  // Move right (move along the wall)
            { row: row - 1, col: col },  // Move up (move along the wall)
            { row: row + 1, col: col },  // Move down (move along the wall)
            { row: row, col: col - 1 },  // Move left (move along the wall)
        ];

        const randomDir = directionsForRightWall[Math.floor(Math.random() * directionsForRightWall.length)];
        const newRow = randomDir.row;
        const newCol = randomDir.col;

        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
            const targetCell = grid[newRow][newCol];
            if (targetCell.element === 'empty') {
                grid[row][col].element = 'empty';
                grid[newRow][newCol].element = 'ant';
            }
        }
    } 
    // If the ant is on the ceiling (above), allow movement along the ceiling or down
    else if (isSolid(above)) {
        const directionsForCeiling = [
            { row: row - 1, col: col },  // Move up (move along the ceiling)
            { row: row + 1, col: col },  // Move down (move along the ceiling)
            { row: row, col: col - 1 },  // Move left (move along the ceiling)
            { row: row, col: col + 1 },  // Move right (move along the ceiling)
        ];

        const randomDir = directionsForCeiling[Math.floor(Math.random() * directionsForCeiling.length)];
        const newRow = randomDir.row;
        const newCol = randomDir.col;

        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
            const targetCell = grid[newRow][newCol];
            if (targetCell.element === 'empty') {
                grid[row][col].element = 'empty';
                grid[newRow][newCol].element = 'ant';
            }
        }
    } 
    // If the ant is on the ground, move normally (up, down, left, right)
    else {
        const randomDir = directions[Math.floor(Math.random() * directions.length)];
        const newRow = randomDir.row;
        const newCol = randomDir.col;

        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
            const targetCell = grid[newRow][newCol];
            if (targetCell.element === 'empty') {
                grid[row][col].element = 'empty';
                grid[newRow][newCol].element = 'ant';
            }
        }
    }
}
 


                    
                    if(cell.element==='firework'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'fire'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 2) {
                            
                       
                                
                                
                                cell.firework=true;
                                
                            }
                        }
                    }
                    
                   
                    if(cell.element==='lead'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'lava'
                        );
                        const Adjacent2 = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'fire'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 2) {
                            
                       
                                
                                cell.element = 'moltenlead';
                                cell.delay = 0;
                                
                            }
                        }
                        if (Adjacent2) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 2) {
                            
                       
                                
                                cell.element = 'moltenlead';
                                cell.delay = 0;
                                
                            }
                        }
                    }
                   
                    if(cell.element==='lead'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'magma' 
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 2) {
                            
                       
                                
                                cell.element = 'moltenlead';
                                cell.delay = 0;
                                
                            }
                        }
                    }
              
if (cell.element !== 'empty' && cell.element !== 'teleport1' && cell.element !== 'teleport2') {
    const adjacentCells = [
    {
        row: row + 1,
        col: col
    }, // Down
    {
        row: row,
        col: col - 1
    }, // Left
    {
        row: row,
        col: col + 1
    } // Right
    ];

    // Check if any adjacent cell has teleport1 or teleport2
    const adjacent = adjacentCells.some(({ row: r, col: c }) => 
        grid[r] && grid[r][c] && grid[r][c].element === 'teleport1'
    );

    if (adjacent) {
       
                    for (let rr = 0; rr < rows; rr++) {
                        for (let cc = 0; cc < cols; cc++) {
                            if (grid[rr][cc].element === 'teleport2') {
                                // Move the object to the position 1 row below teleport1
                                if (rr + 1 < rows) {
                                    grid[rr + 1][cc] = structuredClone(grid[row][col]); // Teleport 1 row below
                                    initializeCell(row, col, 'empty');
                                    break; // Exit once teleportation is done
                                }
                            }
                        }
                    }
                }
            
        
    
}

if (cell.element !== 'empty' && cell.element !== 'teleport1' && cell.element !== 'teleport2') {
    const adjacentCells = [
    {
        row: row + 1,
        col: col
    }, // Down
    {
        row: row,
        col: col - 1
    }, // Left
    {
        row: row,
        col: col + 1
    } // Right
    ];

    // Check if any adjacent cell has teleport1 or teleport2
    const adjacent2 = adjacentCells.some(({ row: r, col: c }) => 
        grid[r] && grid[r][c] && grid[r][c].element === 'teleport2'
    );

    if (adjacent2) {
       
                    for (let rr = 0; rr < rows; rr++) {
                        for (let cc = 0; cc < cols; cc++) {
                            if (grid[rr][cc].element === 'teleport1') {
                                // Move the object to the position 1 row below teleport1
                                if (rr + 1 < rows) {
                                    grid[rr + 1][cc] = structuredClone(grid[row][col]); // Teleport 1 row below
                                    initializeCell(row, col, 'empty');
                                    break; // Exit once teleportation is done
                                }
                            }
                        }
                    }
                }
            
        
    
}
if (cell.element !== 'empty' && cell.element !== 'straw' && elements[grid[row][col].element].liquid === true) {
    const adjacentCells = [
        { row: row + 1, col: col },
        { row: row, col: col - 1 },
        { row: row, col: col + 1 }
    ];

    for (const { row: r, col: c } of adjacentCells) {
        if (
            grid[r] &&
            grid[r][c] &&
            grid[r][c].element === 'straw' &&
            isStrawEnd(r, c)
        ) {
            // Get the network this straw belongs to
            const network = getStrawNetwork(r, c);
            const strawEnds = network.filter(({ row, col }) => isStrawEnd(row, col));

            if (strawEnds.length === 2) {
                // Find the other end (not the one we're next to)
                const otherEnd = strawEnds.find(e => !(Math.abs(e.row - r) <= 1 && Math.abs(e.col - c) <= 1));
                if (otherEnd && otherEnd.row + 1 < rows) {
                    grid[otherEnd.row + 1][otherEnd.col] = structuredClone(grid[row][col]);
                    initializeCell(row, col, 'empty');
                    break; // Exit after teleport
                }
            }
        }
    }
}




                    if(cell.element==='wire'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            }, // Right
                            {
                                row: row - 1,
                                col: col - 1
                            }, // Up-Left (Diagonal)
                            {
                                row: row - 1,
                                col: col + 1
                            }, // Up-Right (Diagonal)
                            {
                                row: row + 1,
                                col: col - 1
                            }, // Down-Left (Diagonal)
                            {
                                row: row + 1,
                                col: col + 1
                            } // Down-Right (Diagonal)
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && elements[grid[r][c].element].electric
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 1) {
                            
                       
                                
                                cell.element = 'ewire';
                                cell.delay = 0;
                                
                            }
                        }
                    }
                    if(cell.element==='redlightoff'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            }, // Right
                            {
                                row: row - 1,
                                col: col - 1
                            }, // Up-Left (Diagonal)
                            {
                                row: row - 1,
                                col: col + 1
                            }, // Up-Right (Diagonal)
                            {
                                row: row + 1,
                                col: col - 1
                            }, // Down-Left (Diagonal)
                            {
                                row: row + 1,
                                col: col + 1
                            } // Down-Right (Diagonal)
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && elements[grid[r][c].element].electric
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 1) {
                            
                       
                                
                                cell.element = 'redlight';
                                cell.delay = 0;
                                
                            }
                        }
                    }
                    if(cell.element==='wire'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            }, // Right
                            {
                                row: row - 1,
                                col: col - 1
                            }, // Up-Left (Diagonal)
                            {
                                row: row - 1,
                                col: col + 1
                            }, // Up-Right (Diagonal)
                            {
                                row: row + 1,
                                col: col - 1
                            }, // Down-Left (Diagonal)
                            {
                                row: row + 1,
                                col: col + 1
                            } // Down-Right (Diagonal)
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element==='ewire'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 0) {
                            
                               if(Math.random() < 0.63){
                                
                                cell.element = 'ewire';
                                cell.delay = 0;
                               }
                                
                            }
                        }
                    }
                    if(cell.elevate === true){
                        cell.elevateage++;
                        if(cell.elevateage > 7){
                            cell.elevate = false;
                            cell.elevateage = 0;
                            cell.elevatedelay=0;
                        }
                    }
                    if(cell.elevate === true && row > 0){
                        cell.elevatedelay++;
                        if(cell.elevateage < 7){
                        if(grid[row-1][col].element==='empty'){
                            if(cell.elevatedelay > 3){
                                if(Math.random() < 0.5){
                                    grid[row-1][col].element = cell.element;
                                    grid[row-1][col].elevate = true;

                                    cell.element='empty';
                                    cell.elevatedelay=0;
                                    cell.elevateage=0;
                                    grid[row-1][col].elevateage = cell.elevateage;
                                }
                            }
                        }
                        }
                    }

                    
                    if(cell.element==='redlightoff'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            }, // Right
                            {
                                row: row - 1,
                                col: col - 1
                            }, // Up-Left (Diagonal)
                            {
                                row: row - 1,
                                col: col + 1
                            }, // Up-Right (Diagonal)
                            {
                                row: row + 1,
                                col: col - 1
                            }, // Down-Left (Diagonal)
                            {
                                row: row + 1,
                                col: col + 1
                            } // Down-Right (Diagonal)
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element==='ewire' 
                        );
                        const Adjacent2 = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element==='redlight' 
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            cell.delay++;
                            
 
                            
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 5) {
                            
                       
                                
                                cell.element = 'redlight';
                                cell.delay = 0;
                                
                            }
                        } 
                        if (Adjacent2) {
                            cell.delay++;
                            
 
                            
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 5) {
                            
                       
                                
                                cell.element = 'redlight';
                                cell.delay = 0;
                                
                            }
                        } 
                    
                    }

                    if(cell.element==='redlight'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            }, // Right
                            {
                                row: row - 1,
                                col: col - 1
                            }, // Up-Left (Diagonal)
                            {
                                row: row - 1,
                                col: col + 1
                            }, // Up-Right (Diagonal)
                            {
                                row: row + 1,
                                col: col - 1
                            }, // Down-Left (Diagonal)
                            {
                                row: row + 1,
                                col: col + 1
                            } // Down-Right (Diagonal)
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && elements[grid[r][c].element].electric 
                        );
                        const Adjacent2 = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element==='ewire' 
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            
                            cell.age=0;
 
                            
 
 
 
 
 
                          
                        } else  if (Adjacent2) {
                            
                            cell.age=0;
 
                            
 
 
 
 
 
                          
                        } else cell.age++;
                    }
                 
                    if(cell.element==='redlight'){
                        if(cell.age>=30){
                            cell.element='redlightoff';
                            cell.age=0;
                        }
                    }
                    if(cell.element === 'nabomb'){
                        if(row < rows - 1){
                       if(grid[row+1][col].element === 'empty' || grid[row+1][col].element === 'nfire' ){
                            grid[row+1][col] = structuredClone(grid[row][col]);
                            cell.element = 'empty';
                            cell.age = 0;

                       } else{ cell.element = 'naexplosion';}
                    } else { cell.element = 'naexplosion';}
                    }
                    
                    if(cell.element==='ewire'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            }, // Right
                            {
                                row: row - 1,
                                col: col - 1
                            }, // Up-Left (Diagonal)
                            {
                                row: row - 1,
                                col: col + 1
                            }, // Up-Right (Diagonal)
                            {
                                row: row + 1,
                                col: col - 1
                            }, // Down-Left (Diagonal)
                            {
                                row: row + 1,
                                col: col + 1
                            } // Down-Right (Diagonal)
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && elements[grid[r][c].element].electric 
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            
                            
 
 
 
 
 
 
 
                           
                        } else cell.age++; if(cell.age >= 1){if(Math.random() < 0.298){cell.element='wire'; cell.age=0; cell.delay=-4;}}
                    }
                    if(cell.element==='glue'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && elements[grid[r][c].element].type === 'solid'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                           
 
 
 
 
 
 
 
 
                            
                            
                       
                        
                                cell.glue=false;
                              
                            } else cell.glue = true;
                        
            }

            if(cell.element === 'paintball'){
                if(row < rows - 1){
                    if(grid[row+1][col].element === 'empty'){
                        grid[row+1][col] = structuredClone(grid[row][col]);
                        initializeCell(row, col, 'empty');

                    } else cell.element = 'painte';
                } else  cell.element = 'painte';
            }
              if(cell.element === 'staticbomb'){
                if(row < rows - 1){
                    if(grid[row+1][col].element === 'empty'){
                        grid[row+1][col] = structuredClone(grid[row][col]);
                        initializeCell(row, col, 'empty');

                    } else cell.element = 'statice';
                } else  cell.element = 'statice';
            }
            
            if(cell.element==='water'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacentbo = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && elements[grid[r][c].element].boil === true
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacentbo) {
                           
 
                            if(Math.random < 0.1){
                            cell.type = 'boiling';

                            
                            }
 
 
 
                            
                            
                       
                        
                                
                              
                            }
                        
            }

            if(cell.element==='steel'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacentbo = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element !== 'fire' && elements[grid[r][c].element].boil === true
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacentbo) {
                           
 
                           
                                
                            cell.element = 'hotsteel';
                            cell.delay=0;
                                
                            }

                            
 
 
 
 
                            
                            
                       
                        
                                
                              
                            }
                            if(cell.element==='hotsteel'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacentbo = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element !== 'fire' && elements[grid[r][c].element].boil === true
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacentbo) {
                           
 
                           
                                
                            cell.sage++;
                            
                                
                            } else cell.sage--; if(cell.sage < -2){
                                cell.element = 'steel';
                                cell.sage= 0;
                            }
                            

                            
 
 
 
 
                            
                            
                       
                        
                                
                              
                            }
                        
            
            if(cell.type === 'boiling'){
                cell.bdelay++;
                cell.bage++;
                if(grid[row-1][col].element === 'empty'){
                    if(cell.bdelay > 2){
                    if(Math.random() < 0.1){
                        if(Math.random() < 0.9){
                    grid[row-1][col].element = 'steam';
                    cell.bdelay=0;
                    } else{ 
                        cell.element = 'empty';
                        grid[row-1][col].element = cell.element;
                        grid[row-1][col].bage = cell.bage; 
                        cell.element = 'empty'; 
                    cell.bdelay=0;
                }

                }
            }
                }
            }
            if(cell.element){
                if(cell.bage>40){
                    if(Math.random() < 0.1){
                    cell.element='empty';
                    }
                    
                }
            }

                  
                    
                    if(cell.element==='mine' && row > 1){
                        if(grid[row-1][col].element!=='empty' && grid[row-1][col].element!=='mine'){
                            cell.element='Explosion';
                        }
                    }
                    if(cell.element==='molotov' && row < rows - 1){
                        if(grid[row+1][col].element==='empty' || grid[row+1][col].element==='fire' || grid[row+1][col].element==='smoke' ){
                            grid[row+1][col].element='molotov';
                            if(Math.random() < 0.3){
                            cell.element='fire';
                            } else cell.element='empty';
                        } else cell.element='mExplosion';

                    }
                    if(cell.element==='molotov'){
                       if(row > rows -2) cell.element='mExplosion';
                    }
                  
                    if(cell.element==='hmb'){
                        const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            }, // Right
                            {
                                row: row - 1,
                                col: col - 1
                            }, // Up-Left (Diagonal)
                            {
                                row: row - 1,
                                col: col + 1
                            }, // Up-Right (Diagonal)
                            {
                                row: row + 1,
                                col: col - 1
                            }, // Down-Left (Diagonal)
                            {
                                row: row + 1,
                                col: col + 1
                            } // Down-Right (Diagonal)
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'hm'
                        );
                            
 
                            if(Adjacent){
                                continue;
                            } else cell.element='empty';
 
 
 
 
                    }
                    if(cell.element==='fire'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'lava'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            cell.delay++;
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            if (cell.delay >= 0) {
                            
                       
                                cell.element='empty'
                                cell.delay = 0;
                                
                            }
                        }
                    }
                    if(cell.element==='grass' && row < rows -1){
                        if(grid[row+1][col].element==='dirt'){
                            const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element==='water'
                        );
                        if(Adjacent){
                        if(grid[row-1][col].element==='empty'){
                            cell.age++;
                            if(cell.age>=20){
                                if(Math.random() < 0.001){
                                    grid[row-1][col].element='grass';
                                    cell.age=0;
                                }
                            }
                        }
                    }
                        }
                    }
                   

 
                 
                
                    
                    
                
                 if(cell.element === 'flashbang'){
                    cell.age++;
                     if(cell.age>=10){
                        
                         cell.element='FExplosion';
                         cell.age=0;
                     }
                     
                 }
                    if(cell.element === 'flash'){
                        cell.age++;
                        if(cell.age>=5){
                            cell.age=0;
                            cell.element='empty';
                        }
                    }
                    if(cell.element === 'FExplosion'){
                        cell.age++;
                        if(cell.age>=5){
                            cell.age=0;
                            cell.element='empty';
                        }
                    }
                    if(cell.element==='flowerseed' && row < rows -1){
                        if(grid[row+1][col].element==='empty'){
                            grid[row+1][col].element='flowerseed';
                            cell.element='empty';
                            cell.age=0;
                        }
                    }
                    if(cell.element==='flowerstem' && row > 0){
                        if(cell.age === 50 && cell.delay === 5){
                                    if(grid[row-1][col].element === 'empty'){
                                        grid[row-1][col].element ='flowerbud';
                                    }
                                 }
                    }

                    if(cell.element === 'drill' && row < rows - 1){
                        if(grid[row+1][col].element === 'empty'){
                            grid[row+1][col] = structuredClone(grid[row][col]);
                            initializeCell(row, col, 'empty');
                        }
                    }
                  // Handle sand physics
                  if (cell.element === 'flowerstem' && row > 0) {
                       cell.age++;
                        cell.delay++;

                           let leftSpread = col > 0 && grid[row - 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row - 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.33){ leftSpread = false;
                               }else if(Math.random() < 0.66 && Math.random() > 0.33){ rightSpread = false; leftSpread = false; 
                                 }  else rightSpread = false;
                                
                           if(cell.age < 50){
                           if(cell.delay === 5){
                          
                               if (leftSpread) {
                               grid[row - 1][col - 1].element = 'flowerstem';
                               grid[row - 1][col - 1].age=cell.age;
                           } else if (rightSpread) {
                               grid[row - 1][col + 1].element = 'flowerstem';
                               grid[row - 1][col + 1].age = cell.age;
                           } else   if(grid[row-1][col].element==='empty'){
                                    
                                    grid[row-1][col].element='flowerstem';
                                    grid[row-1][col].age=cell.age;
                                }

                            
                        }
                    
                    }
                           }
                        }
                    
                    if(cell.element==='flowerseed' && row < rows - 1){
                        if(grid[row+1][col].element === 'dirt' ){
                            if(grid[row-1][col].element === 'empty'){
                                cell.age++;
                               if(cell.age > 20){
                                        grid[row-1][col].element='flowerstem';
                                    
                               }
                            }
                        }
                    }
                    
                 
                    if(cell.element==='ash'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'pwater'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            
                            
                       
                        
                                cell.element = 'empty';
                               
                            
                        }
                       
            }
           
        
            if(cell.element !=='ink' && cell.element !=='empty'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'ink'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            
 
 
 
 
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            
                            
                       
                        
                                cell.ink = true;
                               
                            
                        }
            }
            if(cell.element ==='fire'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacentfoa = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'foamo'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacentfoa) {
                            
 
 
 
 
 
 
 
 
                          cell.element='empty';
                          cell.age=0;
                          cell.delay=0;
                               
                            
                        }
            }
          
            if(cell.element==='cursorb'){
                cell.age++;
                if(cell.age > 1){
                    cell.element='empty';
                }
            }
           
          
          if(cell.element==='tornado2'){
            cell.age++;
            if(cell.age > 1){
                cell.element='empty';
                cell.age=0;
            }
          }
        
         



            if(cell.element === 'human'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'zombie'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            
                            cell.element='zombie';
 
 
 
 
 
                            
 
                        
                               
                            
                        } 
            }
            if(cell.element === 'human'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacentz = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'radiationo'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacentz) {
                            
                            cell.element='zombie';
 
 
 
 
 
                            
 
                        
                               
                            
                        } 
            }
         
            if(cell.element === 'wax'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'fire'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                            
 
 
 
 
 
                            cell.element='mwax'
 
 
                        
                               
                            
                        } 
            }

            if(cell.element === 'wax'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'mwax'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent) {
                                cell.age++;
 
 
 
 
                            if(cell.age>=10){
                            cell.element='mwax'
 
                            }
                        
                               
                            
                        } 
                    }
                 
           if(cell.element !== 'empty' && cell.element !== 'darkenergy'){
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent123 = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'darkenergy'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacent123) {
                              
                            if(Math.random() < 0.4){
                            teleportCell(row, col);
                            }
                           
                        
                               
                            
                        } 
            }
        
            
        
           
         
            
        
            
         


          
               
          












            if(cell.element==='mine'){
                if(row < rows - 1){
 
 
                
                
 
 
 
 
                            // Replace water with grass after delay of 30 frames
                            
                            if(grid[row+1][col].element !== 'empty' ){
                            cell.mineColor =  elements[grid[row+1][col].element].color || elements[grid[row+1][col].element].initialColor;
                               
                            
                            } else cell.mineColor = '#303030';} else cell.mineColor = '#303030';
            }
                    if (cell.element === 'flashbang' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                        
                           grid[row + 1][col].element = 'flashbang';
                          
                           cell.age = 0; cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'flashbang';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'flashbang';
                               cell.element = 'empty';
                           }
                       }
                   }
                  
                
                
                   if (cell.element === 'FExplosion') {
     const fexplosionRadius = 5; // Define the explosion radius
     const fstartRow = Math.max(0, row - fexplosionRadius);
     const fendRow = Math.min(rows - 1, row + fexplosionRadius);
     const fstartCol = Math.max(0, col - fexplosionRadius);
     const fendCol = Math.min(cols - 1, col + fexplosionRadius);
     playsfx("flashbang1");
     // Set the center of the explosion to fire
     cell.element = 'flash'; // Set the center cell to fire
      cell.age=0;
     for (let r = fstartRow; r <= fendRow; r++) {
         for (let c = fstartCol; c <= fendCol; c++) {
             const fdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (fdistance <= fexplosionRadius) {
                 // Check if the cell is TNT
                 if (grid[r][c] && grid[r][c].element === 'empty') {
                    
                    grid[r][c].element = 'flash'; // Ignite flammable material
                    grid[r][c].age = 0; // Initialize fire's age
                    
                }
             }
         }
     }
    
 }

 if(cell.element==='dirt'){
    const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            }, // Right
                            {
                                row: row - 1,
                                col: col - 1
                            }, // Up-Left (Diagonal)
                            {
                                row: row - 1,
                                col: col + 1
                            }, // Up-Right (Diagonal)
                            {
                                row: row + 1,
                                col: col - 1
                            }, // Down-Left (Diagonal)
                            {
                                row: row + 1,
                                col: col + 1
                            } // Down-Right (Diagonal)
                        ];
                        const Adjacentgr = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'grass'
                        );
 
 
 
 
 
 
 
 
                        // If water is adjacent to grass, start or increment the delay
                        if (Adjacentgr) {
                           
 
                           if(row > 0){
                             if(Math.random() < 0.01){
                                if(grid[row-1][col].element === 'empty'){
                            grid[row-1][col].element = 'grass';
                                } else  if(col > 0 && grid[row][col-1].element === 'empty'){
                                    grid[row][col-1].element = 'grass';
                             } else  if(col < cols - 1 && grid[row][col+1].element === 'empty'){
                                    grid[row][col+1].element = 'grass';
                             }
                            }
                            
                                
                            }

                            
 
 
 
 
                            
                            
                       
                        
                                
                              
                            }
                        }

 if(cell.element === 'sprucesapling' && row < rows - 1){
    if(grid[row+1][col].element === 'empty'){
        grid[row+1][col] = structuredClone(grid[row][col]);
        initializeCell(row, col, 'empty');
    }
 }

 if(cell.element === 'sprucesapling' && row < rows - 1 && row > 0){
    if(grid[row+1][col].element === 'dirt' || grid[row+1][col].element === 'grass' || grid[row+1][col].element === 'mud' ){
        if(grid[row-1][col].element === 'empty'){
            cell.age++;
            if(cell.age > 22){
                if(Math.random() < 0.08){
                    cell.age = 0;
                    cell.element = 'sprucelog';
                    let treegrowth = Math.floor(Math.random() * 5) + 5; // Random tree height between 5 and 9
                    grid[row][col].growth = treegrowth;// Random tree height between 5 and 9
                    grid[row][col].size = treegrowth;
                }
            }
        }
    }
 }

 if(cell.element === 'sprucelog' && row > 0){

    if(cell.growth > 0){
    if(grid[row-1][col].element === 'empty'){
        cell.age++;
        if(cell.age > 0){
            if(Math.random() < 0.05){
                grid[row-1][col].element = 'sprucelog';
                grid[row-1][col].growth = cell.growth - 1;
                grid[row-1][col].size = cell.size;
            }
        }
        }
    } else cell.element = 'spe';
 }
 if (cell.element === 'spe') {
    cell.element = 'spruceleaf';
    let height = Math.floor(cell.size * 0.8); // Reduced height for small tree
    let maxWidth = Math.max(1, Math.floor(cell.size / 4)); // Smaller leaf spread

    let centerRow = row + 4; // Moves the tree slightly down
    let centerCol = col;
    let top = centerRow - height - 1;

    for (let dy = -1; dy <= height; dy++) {
        // Taper more quickly to create a smaller shape
        let layerWidth = Math.max(1, maxWidth - Math.floor(dy / 3)); // Narrower layers

        // Full layer gaps (randomly decide whether to skip a layer completely)
        let hasLayerGap = Math.random() < 0.5; // 60% chance to skip the entire layer
        if (hasLayerGap) {
            for (let dx = -layerWidth; dx <= layerWidth; dx++) {
                let newCol = centerCol + dx;
                if (Math.abs(newCol - centerCol) === 1) {
                    // Don't skip cells next to the center
                    continue;
                }

                if (Math.abs(dx) > 1 && Math.random() < 1) {
                    continue; // Skip outer cells in this layer with 40% probability
                }
            }
        }
        for (let dx = -layerWidth; dx <= layerWidth; dx++) {
            let newRow = centerRow - dy;
            let newCol = centerCol + dx;

            if (newRow >= 0 && newRow < grid.length && newCol >= 0 && newCol < grid[0].length) {
                // Place leaves only if the cell is empty
                if (grid[newRow][newCol].element === 'empty' || grid[newRow][newCol].element === 'sprucelog') {
                    grid[newRow][newCol].element = 'spruceleaf';
                    grid[top][col].element = 'spruceleaf';
                }
            }
        }
    }

    // Remove 'spe' after explosion

}






 if (cell.element === 'bouncyball') {
    // Apply gravity
    cell.vy += 0.4; 

    // Accumulate velocity for smooth movement
    cell.vyAccum += cell.vy;
    let moveAmount = Math.floor(cell.vyAccum);

    // Define a minimum velocity threshold for stopping
    const velocityThreshold = 1.5;
    const sideMoveChance = 0.7; // 30% chance to move sideways when bouncing

    if (moveAmount !== 0) {
        let nextRow = row + moveAmount;
        nextRow = Math.min(Math.max(nextRow, 0), rows - 1);

        // Check if the next position is empty
        if (grid[nextRow][col].element === 'empty') {
            // Move the ball
            grid[nextRow][col].element = 'bouncyball';
            grid[nextRow][col].vy = cell.vy;
            grid[nextRow][col].vyAccum = cell.vyAccum - moveAmount;

            // Reset current cell
            cell.element = 'empty';
        } else {
            // **Bounce Logic**
            cell.vy = -cell.vy * 0.6; // Lose more energy per bounce
            cell.vyAccum = 0;

            // **Stop bouncing if velocity is too small**
            if (Math.abs(cell.vy) < velocityThreshold) {
                cell.vy = 0;
                cell.vyAccum = 0;
            } else{

            // **Sideways Movement with a 30% Chance**
            if (Math.random() < sideMoveChance && Math.abs(cell.vy) > velocityThreshold) {
                let sideDirection = Math.random() < 0.5 ? -1 : 1;
                let sideCol = col + sideDirection;

                if (sideCol >= 0 && sideCol < cols && grid[row][sideCol].element === 'empty') {
                    // Move sideways if possible
                    grid[row][sideCol].element = 'bouncyball';
                    grid[row][sideCol].vy = cell.vy;
                    grid[row][sideCol].vyAccum = cell.vyAccum;

                    cell.element = 'empty';
                }
            }
            }
        }
    }
}




 if(cell.element==='gallium'){
        const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            
                           
                        
                        ];
 
                        // Check for adjacent grass cells
                        let GMAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element !== 'empty' && grid[r][c].element !== 'gallium' 
                        );
                   
                  if(GMAdjacent){
                   
                    if(cell.delay>=1){
                    cell.element='liquidgallium';
                  } cell.delay++;} 
                }
              
                   
 
                   
                   
  
   // Move down if possible
   if(cell.element==='plasma'){
                   
                  
                   if(Math.random() < 0.1){
                       
                       initializeCell(row, col, 'empty');
                    } 
                   
               
              }
                   // Handle sand physics
                   if (elements[grid[row][col].element].powder === true && row < rows - 1) {
                      // Move down if possible
                      if(cell.element==='plasma'){
                   
                  
                   if(Math.random() < 0.1){
                       
                       initializeCell(row, col, 'empty');
                    } 
                   
               
              }
    if ( grid[row + 1][col].element === 'empty') {
        grid[row + 1][col] = structuredClone(grid[row][col]); // Move liquid down
        grid[row][col].element = 'empty';
        cell.ldelay = 0;
        cell.delay=0;
        
    } else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1] = structuredClone(grid[row][col]);
                               initializeCell(row, col, 'empty');
                           } else if (rightSpread) {
                               grid[row + 1][col + 1] = structuredClone(grid[row][col]);
                               initializeCell(row, col, 'empty');
                           }
                       }
                   }
                   if (elements[grid[row][col].element].type === 'co' && row < rows - 1) {
                      // Move down if possible
    if ( grid[row + 1][col].element === 'empty' || grid[row + 1][col].element === 'water') {
      
        grid[row + 1][col] = structuredClone(grid[row][col]); // Move liquid down
      
        grid[row][col].element = 'empty';
            
        
        cell.ldelay = 0;
        cell.delay=0;
        
    } else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty' ;
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1] = structuredClone(grid[row][col]);
                               initializeCell(row, col, 'empty');
                           } else if (rightSpread) {
                               grid[row + 1][col + 1] = structuredClone(grid[row][col]);
                               initializeCell(row, col, 'empty');
                           }
                       }
                   }

                    if (elements[grid[row][col].element].liquid === true && row < rows - 1) {
                      const liquiddelay = elements[cell.element]?.liquiddelay || 0;
                            
                        cell.delay++;
                        
    // Move down if possible
    if ( grid[row + 1][col].element === 'empty') {
        grid[row + 1][col] = structuredClone(grid[row][col]); // Move liquid down
        grid[row][col].element = 'empty';
        cell.ldelay = 0;
        cell.delay=0;
        
    } else {
        
        // If down is blocked, check left and right
        let leftEmpty = col > 0 && grid[row][col - 1].element === 'empty';
        let rightEmpty = col < cols - 1 && grid[row][col + 1].element === 'empty';

        if(cell.delay >= liquiddelay){
            
            cell.delay=0;
            
        if (Math.random() <= 0.5) {
    // Move 2 cells left instead of 1
    
    if (col > 1 && grid[row][col - 2].element === 'empty') {
        if(grid[row][col- 1].element === 'empty'){
        grid[row][col - 2] = structuredClone(grid[row][col], ['delay', 'ldelay']);
        grid[row][col].element = 'empty';
        cell.delay=0;
        }
    } else if (leftEmpty) {
        grid[row][col - 1] = structuredClone(grid[row][col], ['delay', 'ldelay']);
        grid[row][col].element = 'empty';
        cell.delay=0;
    }
} else {
    // Move 2 cells right instead of 1
    if (col < cols - 2 && grid[row][col + 2].element === 'empty') {
        if(grid[row][col+1].element === 'empty'){
        grid[row][col + 2] = structuredClone(grid[row][col], ['delay', 'ldelay']);
        grid[row][col].element = 'empty';
        cell.delay=0;
        }
    } else if (rightEmpty) {
        grid[row][col + 1] = structuredClone(grid[row][col], ['delay', 'ldelay']);
        grid[row][col].element = 'empty';
        cell.delay=0;
    }
}
}
        

    }
}

                 
if (grid[row][col].element === 'tar' && row < rows - 1) {
                      const liquiddelay = elements[cell.element]?.liquiddelay || 0;
                            
                        cell.delay++;
                        if(cell.tarmove === true){
    // Move down if possible
    if ( grid[row + 1][col].element === 'empty') {
        grid[row + 1][col] = structuredClone(grid[row][col]); // Move liquid down
        grid[row][col].element = 'empty';
        cell.ldelay = 0;
        cell.delay=0;
        
    } else {
        
        // If down is blocked, check left and right
        let leftEmpty = col > 0 && grid[row][col - 1].element === 'empty';
        let rightEmpty = col < cols - 1 && grid[row][col + 1].element === 'empty';

        if(cell.delay >= liquiddelay){
            
            cell.delay=0;
            
        if (Math.random() <= 0.5) {
    // Move 2 cells left instead of 1
    
    if (col > 1 && grid[row][col - 2].element === 'empty') {
        if(grid[row][col- 1].element === 'empty'){
        grid[row][col - 2] = structuredClone(grid[row][col], ['delay', 'ldelay']);
        grid[row][col].element = 'empty';
        cell.delay=0;
        }
    } else if (leftEmpty) {
        grid[row][col - 1] = structuredClone(grid[row][col], ['delay', 'ldelay']);
        grid[row][col].element = 'empty';
        cell.delay=0;
    }
} else {
    // Move 2 cells right instead of 1
    if (col < cols - 2 && grid[row][col + 2].element === 'empty') {
        if(grid[row][col+1].element === 'empty'){
        grid[row][col + 2] = structuredClone(grid[row][col], ['delay', 'ldelay']);
        grid[row][col].element = 'empty';
        cell.delay=0;
        }
    } else if (rightEmpty) {
        grid[row][col + 1] = structuredClone(grid[row][col], ['delay', 'ldelay']);
        grid[row][col].element = 'empty';
        cell.delay=0;
    }
}
}
    }
        

    }
}
if(cell.element === 'tar' && row > 0){
    if(grid[row-1][col].element === 'empty'){
    if(Math.random() < 0.02){
        grid[row-1][col].element = 'fire';
    }

    }
}







                    if(cell.element==='glue' && row < rows - 1){
                        if(grid[row+1][col].element==='empty'){
                            if(cell.glue === true){
                            grid[row+1][col].element='glue';
                            cell.element='empty';
                            }
                            if(grid[row-1][col].element === 'glue'){
                                grid[row + 1][col].element = 'glue';
                                cell.element='empty';
                            }
                        }
                    }
                   
                    
                    if(cell.element!== 'cb' && cell.element!== 'empty' && row < rows - 1 && col < cols - 1 && col > 0 && row > 0){
                        

                        if(cell.cbdelay >= 3){
                         if(grid[row][col-1].element === 'cb'){
                            if(grid[row-1][col-1].element === 'cb'){
                                if(grid[row-1][col].element === 'empty'){
                                    grid[row-1][col].element = cell.element;
                                    cell.element='empty';
                                    cell.cbdelay = 0;
                                }
                            }   else if(grid[row-1][col-1].element === 'empty'){
                                grid[row-1][col-1].element = cell.element;
                                cell.element='empty';
                                cell.cbdelay = 0;
                            }
                        } else if(grid[row+1][col-1].element === 'cb'){
                            if(grid[row][col-1].element === 'empty'){
                            grid[row][col-1].element = cell.element;
                            cell.element='empty';
                            cell.cbdelay = 0;
                            }
                        } else 
                            if(grid[row+1][col].element === 'cb'){
                              
                                if(grid[row+1][col-1].element === 'empty'){
                                  
                            grid[row+1][col-1].element = cell.element;
                            cell.element='empty';
                            cell.cbdelay = 0;
                                    }
                            
                        } else if(grid[row][col+1].element === 'cb'){

                            if(grid[row+1][col+1].element === 'empty'){
                                grid[row+1][col+1].element = cell.element;
                                cell.element='empty';
                                cell.cbdelay = 0;
                            }else if(grid[row+1][col].element === 'empty'){
                                    grid[row+1][col].element = cell.element;
                                    cell.element='empty'; 
                                    cell.cbdelay = 0;  
                                }
                            
                        } else     if(grid[row-1][col].element === 'cb'){
                            if(grid[row-1][col+1].element === 'cb'){
                            if(grid[row][col+1].element === 'empty'){

                                grid[row][col+1].element = cell.element;
                                cell.element='empty';  
                                cell.cbdelay = 0;
                            }
                        } else if(grid[row-1][col+1].element === 'empty'){
                            grid[row-1][col+1].element = cell.element;
                            cell.element='empty';
                            cell.cbdelay = 0;
                            }
                        } 


                       
                    }
                    }
                     // Handle water physics
  if (cell.element === 'moltengold' && row < rows - 1) {
                     
                        
                        if (grid[row + 1][col].element === 'empty') {
                         
                            
                            grid[row + 1][col].element = 'moltengold';
                            cell.element = 'empty';
                        
                        }  else {
                            let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
                            
                             
                            if (leftSpread && rightSpread) {
                                if (Math.random() < 0.5){     rightSpread = false;
                                }
                              
                                leftSpread = false;
                            }
                           
                            if (leftSpread) {
                                grid[row][col - 1].element = 'moltengold';
                                cell.element = 'empty';
                            } else if (rightSpread) {
                                grid[row][col + 1].element = 'moltengold';
                                cell.element = 'empty';
                            }
                         }
                     
                    }
               
                     
                  
                 
              
                  
                    
                      // Handle water physics
  if (cell.element === 'ink' && row < rows - 1) {
                    
                   
                        
                        if (grid[row + 1][col].element === 'empty') {
                         
                            
                            grid[row + 1][col].element = 'ink';
                            cell.element = 'empty';
                        
                        }  else {
                            let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
                            
                             
                            if (leftSpread && rightSpread) {
                                if (Math.random() < 0.5){     rightSpread = false;
                                }
                              
                                leftSpread = false;
                            }
                           
                            if (leftSpread) {
                                grid[row][col - 1].element = 'ink';
                                cell.element = 'empty';
                            } else if (rightSpread) {
                                grid[row][col + 1].element = 'ink';
                                cell.element = 'empty';
                            }
                         }
                     
                    }
                   
                
                    


                  
                    
                    if(cell.element==='hail'){
                        if(row < rows - 1){
                            if(grid[row+1][col].element === 'empty' || grid[row+1][col].element==='hail'){
                                grid[row+1][col].element = 'hail';
                                cell.element='empty';
                            } else{ 
                                cell.element ='empty';
                                grid[row+1][col].element='empty';
                            }
                        } else cell.element='empty';
                    }
                    
                    if(cell.element==='flea' && row > 0){
                        if(row < rows - 1){
                            

                           if(grid[row+1][col].element!=='empty'){
                            cell.age++;
                          
                            if(cell.age > 2){
                                if(grid[row-1][col].element==='empty'){
                            grid[row-1][col].element='flea';
                            cell.element='empty';
                            cell.age=0;
                                }
                            }
                            
                         }else{
                           cell.age++;
                            if(cell.age>= 2){
                            grid[row+1][col].element='flea';
                            cell.element='empty';
                            cell.age=0;
                           
                           }
                        }
                        } else if(grid[row-1][col].element==='empty'){
                            cell.age++;
                            if(cell.age > 2){
                               
                            grid[row-1][col].element='flea';
                            cell.element='empty';
                            cell.age=0;
                                
                            }
                        }
                    }
                    
                    
                    if(cell.element==='fireball'){
                        if(row < rows - 2){
                            if(grid[row+1][col].element==='empty' || grid[row+1][col].element==='fire' || grid[row+1][col].element==='smoke' ){
                                if(grid[row+2][col].element==='empty' || grid[row+2][col].element==='fire' || grid[row+2][col].element==='smoke' ){
                                grid[row+2][col].element='fireball';
                                
                               
                                cell.delay=0;
                                cell.age=0;
                                if(Math.random() <= 0.5){
                                cell.element='fire';
                                } else cell.element = 'empty';
                                }
                            } else if(grid[row+1][col].element !== 'fireball') cell.element='fireballe';
                        } else cell.element='fireballe';
                    }
                    if(cell.element==='flea'){
                        cell.delay++;
                        let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
                            
                             
                            if (leftSpread && rightSpread) {
                                if (Math.random() <= 0.5){     rightSpread = false;
                                }
                              
                                leftSpread = false;
                            }
                            if(cell.delay>=2){
                            if (leftSpread) {
                                grid[row][col - 1].element = 'flea';
                                cell.element = 'empty';
                            } else if (rightSpread) {
                                grid[row][col + 1].element = 'flea';
                                cell.element = 'empty';
                            }
                            cell.delay=0;
                        }
                         }
                    
                  
                    if (cell.element === 'tsunami' && row < rows - 1) {
                  
                   
                        
                        if (grid[row + 1][col].element === 'empty') {
                         
                            
                            grid[row + 1][col].element = 'tsunami';
                            
                        
                        }  
                     
                    }
                    if(cell.element==='tsunami' && row < rows-1){
                        let leftSpread = col > 0 && grid[row][col - 1].element === 'empty';
                            let rightSpread = col < cols - 1 && grid[row][col + 1].element === 'empty';
 
                            
                             
                            if (leftSpread && rightSpread) {
                                if (Math.random() < 0.5){     rightSpread = false;
                                } else leftSpread = false;
                            }
                           
                            if (leftSpread) {
                                grid[row][col - 1].element = 'tsunami';
                               
                            } else if (rightSpread) {
                                grid[row][col + 1].element = 'tsunami';
                                
                            }
                         }
                  



                   
                    
                    if(cell.element==='soda'){
                        if(grid[row-1][col].element==='empty'){
                            cell.age++;
                            if(cell.age>20){
                                if(Math.random() < 0.01){
                                    grid[row-1][col].element='foam';
                                    cell.age=0;
                                }
                            }
                        }
                    }
                   

                 
                 
                   
                    
                  
                
                 if(cell.element==='bubble' && row > 0){
                    cell.age++;
                    if(grid[row-1][col].element==='bubbleo' && cell.age >= 4){
                        cell.age = 0;
                        if(Math.random() < 0.5){
                            grid[row-1][col].element='bubble';
                            cell.element='empty';
                        }
                    }
                 }
                 if(cell.element==='radiation' && row > 0){
                    cell.age++;
                    if(grid[row-1][col].element==='radiationo' && cell.age >= 4){
                        cell.age = 0;
                        if(Math.random() < 0.5){
                            grid[row-1][col].element='radiation';
                            cell.element='empty';
                        }
                    }
                 }
                 if(cell.element==='soap' && row > 0){
                    cell.delay++;
                    if(grid[row-1][col].element==='empty' && cell.delay>=40){
                        if(Math.random() < 0.01){
                            grid[row-1][col].element='bubble';
                            cell.delay=0;
                        }
                    }
                 }
                  
                    
                   
                  
                 
                  
                   if (cell.element==='dirt'){
                     const adjacentCellsd = [
                         { row: row + 1,
                                col: col
                            }, // down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        let dirtAdjacent = adjacentCellsd.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water');
                        if (dirtAdjacent) {
                            grid[row][col].element = 'mud';
 
                           
                        }
                   }
                   
                   if(cell.element==='clay'){
                    cell.age++;
                    
                    if(cell.age>=200){
                             if (Math.random() < 0.08) {
                             cell.element='solidclay';
                             }
                         }
                   }
                   if (cell.element==='sand'){
                     const adjacentCellssa = [
                         { row: row + 1,
                                col: col
                            }, // down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        let sandwAdjacent = adjacentCellssa.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water');
                        if (sandwAdjacent) {
                            grid[row][col].element = 'wetsand';
 
                           
                        }
                   }
                
                  
                    // Handle sand physics
                    if (cell.element === 'darkenergy' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'darkenergy';
                          
                           cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'darkenergy';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'darkenergy';
                               cell.element = 'empty';
                           }
                       }
                   }
                   if(cell.element === 'darkenergy'){
                    if(Math.random() < 0.07){
                        initializeCell(row, col, 'empty');
                    }
                   }

     
                 
                   if(cell.element==='lasercannon'){
                    if( row < rows -2 ){
                    if(grid[row+2][col].element==='empty' || grid[row+2][col].element==='smoke' || grid[row+2][col].element==='fire' || grid[row+2][col].element==='plasma'){
                        grid[row+2][col].element='lasercannon';
                        cell.element='empty';
                    } else if(grid[row+2][col].element!=='lasercannon') cell.element='le';} else cell.element='le';
                   }
                    // Handle sand physics
                 
                   if(cell.element==='sodium'){
                    cell.age++;
                    if(cell.age >= 20){
                        if(Math.random() < 0.001){
                            cell.element='empty';
                            cell.age=0;
                        }
                    }
                   }
                    // Handle sand physics
               
                   if(cell.element==='oxygen'){
                        const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'hydrogen' 
                        );
                            
 
                            if(Adjacent){
                               cell.element = 'h2oe'
                            }
 
 
 
 
                    }
                
                
                   if(cell.element==='sappling' && row < rows -1){
                    if(grid[row+1][col].element === 'empty'){
                        grid[row+1][col].element='sappling';
                        cell.element='empty';
                    }
                   }
                  
                   if(cell.element==='mushroomseed' && row < rows-1){
                    if(grid[row+1][col].element !== 'empty'){
                        cell.delay++;
                        if(cell.delay === 10){
                            if(grid[row-1][col].element==='empty'){
                                grid[row-1][col].element='mushroomstem';
                                
                            }
                        }
                    }
                   }

                   if(cell.element==='sappling' && row < rows-1){
                    if(grid[row+1][col].element === 'dirt' || grid[row+1][col].element === 'mud' || grid[row+1][col].element === 'grass'){
                        cell.delay++;
                        if(cell.delay === 10){
                            if(grid[row-1][col].element==='empty'){
                                grid[row-1][col].element='log';
                              cell.element='log';  
                            } else cell.delay =0;
                            
                        }
                    }
                   }
                   if(cell.element==='mushroomstem' && row > 0){
                    if(cell.age === 75){
                        if(grid[row-1][col].element==='empty'){
                            grid[row-1][col].element='me';
                        }
                    }
                   }
                   if(cell.element==='log' && row > 0){
                    if(cell.age > 60){
                        if(Math.random() < 0.05){
                        if(grid[row-1][col].element==='empty'){
                            grid[row-1][col].element='tl';
                        }
                    }
                    }
                   }
                   if(cell.element==='mushroomstem' && row < rows-1 && row > 0){
                    cell.age++;
                    if(grid[row+1][col].element !== 'empty'){
                        cell.delay++;
                        if(cell.age < 75){
                        if(cell.delay === 10){
                            if(grid[row-1][col].element==='empty'){
                                grid[row-1][col].element='mushroomstem';
                                grid[row-1][col].age=cell.age;
                            }
                        }
                    }
                    }
                   }
                   if(cell.element==='log' && row < rows-1 && row > 0){
                    cell.age++;
                    if(grid[row+1][col].element !== 'empty'){
                        cell.delay++;
                      
                        if(cell.delay === 10){
                            if(grid[row-1][col].element==='empty'){
                                grid[row-1][col].element='log';
                                grid[row-1][col].age=cell.age;
                            }
                        }
                    
                    }
                   }
                   if(cell.element==='dirt'){
                    if(grid[row-1][col].element==='log'){
                        cell.element='root';
                    }
                   }
                 if(cell.element==='mushroomseed' && row < rows-1){
                    if(grid[row+1][col].element === 'empty'){
                        grid[row+1][col].element ='mushroomseed';
                        cell.age=0;
                        cell.element='empty';
                    }
                 }
                    // Handle sand physics
                    if (cell.element === 'c4' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'c4';
                           cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'c4';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'c4';
                               cell.element = 'empty';
                           }
                       }
                   }
                
                    
           





                    if(cell.element==='wax' && row < rows - 1){
                        if(grid[row+1][col].element==='empty'){
                            grid[row+1][col].element='wax';
                            cell.element='empty';
                        }
                    }
                    if(cell.element==='firework'){
                        if(cell.age>=50){
                            cell.element='fireworke';
                        }
                    }
                   
                    // Handle sand physics
                    if (cell.element === 'firework') {
                        if(cell.firework === false){
                       if(row < rows - 1){

                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'firework';
                           cell.element = 'empty'; }}} else {
                            cell.age++;
                            cell.delay++;
                            if(row > 0){
                                if(cell.delay>=2){
    if(grid[row-1][col].element==='empty'){
        grid[row-1][col].element='firework';
        cell.element='fire';
        grid[row-1][col].age=cell.age;
        grid[row-1][col].firework = true
        cell.age=0;
        cell.delay=0;
        cell.firework=false;
    }}
    }
    
                           }
                      
                        
                       
                   }
                     // Handle sand physics
                     if (cell.element === 'antimatter' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'antimatter';
                           cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'antimatter';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'antimatter';
                               cell.element = 'empty';
                           }
                       }
                   }

               
                  
                   
                 
                   if (cell.element === 'fire' && row < rows - 1) {
                      if(cell.firemove === true){
                       
                        if(Math.random() < 0.3){
                            
                        
                            if(Math.random() < 0.7){
                                if(row > 2){
                                if (grid[row - 1][col].element === 'empty' ) {
                        
                             

                                grid[row - 1][col].element = 'fire';
                           grid[row - 1][col].age = cell.age;
                           cell.age=0;
                           cell.element = 'empty';}}
                            } else{
                            if (grid[row + 1][col].element === 'empty') {
                        
                           grid[row + 1][col].element = 'fire';
                           grid[row + 1][col].age = cell.age;
                           cell.age=0;
                           cell.element = 'empty'; 
                            }}
                           }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'fire';
                               cell.element = 'empty';
                               grid[row + 1][col - 1].age=cell.age;
                               cell.age=0;
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'fire';
                               cell.element = 'empty';
                               grid[row + 1][col + 1].age = cell.age;
                               cell.age=0;
                           }
                        }
                    }
                }
                      
                
                    // Handle sand physics
                   // Handle sand physics
                   if (cell.element === 'nfire' && row < rows - 1) {
                      if(cell.firemove === true){
                       
                        if(Math.random() < 0.3){
                            
                        
                            if(Math.random() < 0.7){
                                if(row > 2){
                                if (grid[row - 1][col].element === 'empty' ) {
                        
                             

                                grid[row - 1][col].element = 'nfire';
                           grid[row - 1][col].age = cell.age;
                           cell.age=0;
                           cell.element = 'empty';}}
                            } else{
                            if (grid[row + 1][col].element === 'empty') {
                        
                           grid[row + 1][col].element = 'nfire';
                           grid[row + 1][col].age = cell.age;
                           cell.age=0;
                           cell.element = 'empty'; 
                            }}
                           }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'nfire';
                               cell.element = 'empty';
                               grid[row + 1][col - 1].age=cell.age;
                               cell.age=0;
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'nfire';
                               cell.element = 'empty';
                               grid[row + 1][col + 1].age = cell.age;
                               cell.age=0;
                           }
                       }
                    }
                   }
                   if(cell.element === 'nfire'){
                    cell.age++;
                    if(cell.age>10){
                        if(Math.random() < 0.02){
                            cell.element = 'empty';
                            cell.firemove = false;
                        }
                    }
                   }
               
                
                   
                  
                        // Handle sand physics
                        if (cell.element === 'cloner' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'cloner';
                           cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'cloner';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'cloner';
                               cell.element = 'empty';
                           }
                       }
                   }
 
                     // Handle sand physics
                     if (cell.element === 'sand' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'sand';
                           cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'sand';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'sand';
                               cell.element = 'empty';
                           }
                       }
                   }
                  
                    if (cell.element === 'grenade' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'grenade';
                           cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'grenade';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'grenade';
                               cell.element = 'empty';
                           }
                       }
                   }
                   
                 
              
           
                  if(cell.element==='mine' && row < rows -1){
                    if(grid[row+1][col].element==='empty'){
                        grid[row+1][col].element='mine';
                        cell.element='empty';
                    }
                  }
                   if (cell.element === 'empgrenade' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'empgrenade';
                           cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'empgrenade';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'empgrenade';
                               cell.element = 'empty';
                           }
                       }
                   }
                   
                
                    if (cell.element === 'smokeBomb' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'smokeBomb';
                           cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'smokeBomb';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'smokeBomb';
                               cell.element = 'empty';
                           }
                       }
                   }
                 
                    if (cell.element === 'smokeBomb' && row < rows - 1) {
                       
                       if (grid[row + 1][col].element === 'empty') {
                           grid[row + 1][col].element = 'smokeBomb';
                           cell.element = 'empty'; }
                      
                        else {
                           let leftSpread = col > 0 && grid[row + 1][col - 1].element === 'empty';
                           let rightSpread = col < cols - 1 && grid[row + 1][col + 1].element === 'empty';
                           if (leftSpread && rightSpread) {
                               if (Math.random() < 0.5) leftSpread = false;
                               else rightSpread = false;
                           }
                           if (leftSpread) {
                               grid[row + 1][col - 1].element = 'smokeBomb';
                               cell.element = 'empty';
                           } else if (rightSpread) {
                               grid[row + 1][col + 1].element = 'smokeBomb';
                               cell.element = 'empty';
                           }
                       }
                   }
                      if(cell.element === 'cockroach2'){
    cell.delay++;
    if(row < rows - 1 && grid[row+1][col].element === 'empty'){
        
    grid[row+1][col] = structuredClone(grid[row][col]);
    initializeCell(row, col, 'empty');
        
    } else {
        let left = col > 0 && grid[row][col - 1].element === 'empty';
        let right = col < cols - 1 && grid[row][col + 1].element === 'empty';
    
 
       
   let newCol = Math.random() < 0.5 ? col - 1 : col + 1;
   if(Math.random() < 0.1){
            if(newCol > 0 && newCol < cols - 1){
                if(grid[row][newCol].element === 'empty'){
                    grid[row][newCol] = structuredClone(grid[row][col], ['delay']);
                    initializeCell(row, col, 'empty');
                } else{
                   
                        newRow = row - 1
                    if(newRow > 0 && newRow < rows - 1){
                        if(grid[newRow][newCol].element === 'empty'){
                            grid[newRow][newCol] = structuredClone(grid[row][col],  ['delay']);
                            initializeCell(row, col, 'empty');
                        }
                    }
                }
            }
        }
        
    }
}
 if (cell.element === 'wormhead') {
    cell.delay = (cell.delay || 0) + 1; // Ensure delay is defined
    cell.tail = cell.tail || [{ row, col }]; // Initialize tail with the head position

    let newRow = row;
    let newCol = col;

    // Move head
    if (row < rows - 1 && grid[row + 1][col].element === 'empty') {
        newRow = row + 1; // Move down
    } else {
        let left = col > 0 && grid[row][col - 1].element === 'empty';
        let right = col < cols - 1 && grid[row][col + 1].element === 'empty';

        let randomDir = Math.random() < 0.5 ? -1 : 1;
        newCol = col + randomDir;
        
        if (Math.random() < 0.1 && newCol > 0 && newCol < cols - 1) {
            if (grid[row][newCol].element !== 'empty') {
                newRow = row - 1; // Try to move up
            }
        }
    }

    // Update head position
    if (newRow > 0 && newRow < rows && newCol > 0 && newCol < cols && grid[newRow][newCol].element === 'empty') {
        grid[newRow][newCol] = structuredClone(grid[row][col]);
        grid[newRow][newCol].tail = [...cell.tail];

        // Add current head position to the tail list
        grid[newRow][newCol].tail.unshift({ row, col });

        // Limit tail to 5 segments
        if (grid[newRow][newCol].tail.length > 5) {
            let { row: oldRow, col: oldCol } = grid[newRow][newCol].tail.pop();
            if (grid[oldRow][oldCol].element === 'wormtail') {
                initializeCell(oldRow, oldCol, 'empty'); // Remove the last tail segment
            }
        }

        initializeCell(row, col, 'wormtail');
    }
}if (cell.element === 'snakegame') {
    snakegame();
    // Setup
    cell.delay = (cell.delay || 0) + 1;
    cell.tail2 = cell.tail2 || [{ row, col }];
    cell.length = cell.length || 5;
    cell.moveDelay = cell.moveDelay || 5;
    cell.tickCounter = (cell.tickCounter || 0) + 1;
    cell.direction = cell.direction || { row: 0, col: 1 };

   
        document.addEventListener('keydown', (e) => {
            if (cell.element !== 'snakegame') return;
            if (e.key === 'ArrowUp' && cell.direction.row !== 1) cell.direction = { row: -1, col: 0 };
            else if (e.key === 'ArrowDown' && cell.direction.row !== -1) cell.direction = { row: 1, col: 0 };
            else if (e.key === 'ArrowLeft' && cell.direction.col !== 1) cell.direction = { row: 0, col: -1 };
            else if (e.key === 'ArrowRight' && cell.direction.col !== -1) cell.direction = { row: 0, col: 1 };
        });
        

    // Move with delay
    if (cell.tickCounter >= cell.moveDelay) {
        cell.tickCounter = 0;

        const newRow = row + cell.direction.row;
        const newCol = col + cell.direction.col;

        // Check for out of bounds or blocked
        if (
            newRow < 0 || newRow >= rows ||
            newCol < 0 || newCol >= cols ||
            (grid[newRow][newCol].element !== 'empty' &&
             grid[newRow][newCol].element !== 'apple' &&
             grid[newRow][newCol].element !== 'snaketail')
        ) {
            // Clear head
            initializeCell(row, col, 'empty');

            // Clear tail
            for (let segment of cell.tail2) {
                initializeCell(segment.row, segment.col, 'empty');
            }

            return; // Stop processing this tick
        }

        const target = grid[newRow][newCol];

        // Eat food
        if (target.element === 'apple') {
            cell.length += 1;
        }

        // Move snake forward
        grid[newRow][newCol] = structuredClone(grid[row][col]);
        grid[newRow][newCol].tail2 = [...cell.tail2];
        grid[newRow][newCol].tail2.unshift({ row, col });

        if (grid[newRow][newCol].tail2.length > cell.length) {
            const tailEnd = grid[newRow][newCol].tail2.pop();
            if (grid[tailEnd.row][tailEnd.col].element === 'snakegametail') {
                initializeCell(tailEnd.row, tailEnd.col, 'empty');
            }
        }

        // Make current cell into tail
        initializeCell(row, col, 'snakegametail');
    }
}

// Tail movement physics
if (cell.element === 'wormtail') {
    let tailIndex = grid[row][col].tail ? grid[row][col].tail.indexOf({ row, col }) : -1;
    if (tailIndex > 0) {
        let prevSegment = grid[row][col].tail[tailIndex - 1];
        let dx = prevSegment.col - col;
        let dy = prevSegment.row - row;

        // Move towards the previous tail segment
        if (Math.abs(dx) > Math.abs(dy)) {
            col += Math.sign(dx);
        } else {
            row += Math.sign(dy);
        }

        // Swap positions
        if (grid[row][col].element === 'empty') {
            grid[row][col] = structuredClone(grid[prevSegment.row][prevSegment.col]);
            initializeCell(prevSegment.row, prevSegment.col, 'empty');
        }
    }
}



   // Handle sand physics
   
 
                      if (cell.element==='concrete'){
                         cell.delay++;
                        
                        
                        
                         if(cell.delay>=200){
                             if (Math.random() < 0.08) {
                             cell.element='stone';
                             }
                         }
                      }
        
                  
                    
                      // Handle sand physics
                    if (cell.element === 'tornado' && col < cols - 1 && col > 0 && row > 0) {
                       
                  
                    
                  
                         let leftSpread = col > 1 && grid[row - 1][col - 1].element === 'empty' ||  grid[row - 1][col - 1].element === 'tornado2';
                         let rightSpread = col < cols - 2 && grid[row - 1][col + 1].element === 'empty' ||  grid[row - 1][col + 1].element === 'tornado2';
                         if (leftSpread && rightSpread) {
                             if (Math.random() <= 0.5) leftSpread = false;
                             else rightSpread = false;
                         }
                         if(row > rows -2 || grid[row+1][col].element !== 'empty'){
                          
                                if(Math.random() < 0.3){
                         if (leftSpread) {
                            cell.element = 'empty';
                            cell.delay=0;
                            if(grid[row][col - 1].element === 'empty'){
                             grid[row][col - 1].element = 'tornado';
                             
                      
                            } else grid[row-1][col - 1].element = 'tornado';
                         } else if (col < cols - 1 && rightSpread) {
                        
                            cell.element = 'empty';
                            cell.delay=0;
                            if(grid[row][col + 1].element === 'empty'){
                             grid[row][col + 1].element = 'tornado';
                             
                            } else grid[row-1][col + 1].element = 'tornado';
                        
                         }
                        }
                    }
                        
                     
                  }  
              if(cell.element === 'pumpkinseed' && row < rows - 1){
                if(grid[row+1][col].element === 'empty'){
                    grid[row+1][col].element = 'pumpkinseed';
                    initializeCell(row, col, 'empty');
                }
              }
              if(cell.element === 'pumpkinseed' && row < rows - 1){
                if(grid[row+1][col].element === 'dirt' || grid[row+1][col].element === 'grass' || grid[row+1][col].element === 'mud' ){
                    cell.age++;
                    if(cell.age > 10){
                        if(Math.random() < 0.1){
                            initializeCell(row, col, 'pumpkinsprout');
                        }
                    }
                }
              }
            
              if(cell.element === 'pumpkinsprout' && row < rows - 1){
                if(grid[row+1][col].element === 'dirt' || grid[row+1][col].element === 'grass' || grid[row+1][col].element === 'mud' ){
                    cell.age++;
                    if(row > 0 && grid[row-1][col].element === 'empty'){
                    if(cell.age > 10){
                        if(Math.random() < 0.05){
                            grid[row-1][col].element = 'pumpkin';
                            if(Math.random() < 0.6){
                                cell.element = 'pumpkinvine';
                                grid[row-1][col].went = true;
                                if(Math.random() < 0.5){
                                if(row > 2 && col > 0 && grid[row-2][col-1].element === 'empty'){ 
                grid[row-2][col-1].element = 'pumpkinstem';
            }
        } else    if(row > 2 && col < cols - 1 && grid[row-2][col+1].element === 'empty'){ 
                grid[row-2][col+1].element = 'pumpkinstem';
            }
                            } else grid[row-1][col].went = false;
                             
                        }
                          
                        }
                    }
                }
              }

              if(cell.element === 'pumpkinvine'){
                cell.delay++;
                cell.age++;
                if(row > 0 && grid[row-1][col].element === 'empty'){
                    if(cell.age < 500){
                        if(Math.random() < 0.00005){
                            grid[row-1][col].element = 'pumpkin';
                            
                            if(Math.random() < 0.6){

grid[row-1][col].went = true;
if(Math.random() < 0.5){
if(row > 2 && col > 0 && grid[row-2][col-1].element === 'empty'){ 
grid[row-2][col-1].element = 'pumpkinstem';
}
} else    if(row > 2 && col < cols - 1 && grid[row-2][col+1].element === 'empty'){ 
grid[row-2][col+1].element = 'pumpkinstem';
}
} else grid[row-1][col].went = false;

                        }
                    }
                }
              }
              if(cell.element === 'pumpkin' && row < rows - 1){
                if(grid[row+1][col].element === 'empty'){
                    grid[row+1][col].element = 'pumpkinvine';
                }
              }
           
              if (cell.element === 'pumpkin') {
    const adjacentCells = [
        { row: -1, col: 0 }, // Up
        { row: 1, col: 0 }, // Up
        { row: 0, col: -1 }, // Left
        { row: 0, col: 1 }, // Right
        { row: -1, col: -1 }, // Up-Left (Diagonal)
        { row: -1, col: 1 }, // Up-Right (Diagonal)
        { row: 1, col: -1 }, // Down-Left (Diagonal)
        { row: 1, col: 1 } // Down-Right (Diagonal)
    ];

    cell.age++;
    cell.delay++;
 
 
    if (cell.delay > 30) {
        if (Math.random() < 0.1) {
      
            if(cell.went === false){
     
            for (const { row: rOffset, col: cOffset } of adjacentCells) {
                const r = row + rOffset;
                const c = col + cOffset;

                // Check if the adjacent cell is valid
                if (grid[r] && grid[r][c]) {
                    if (grid[r][c].element === 'empty' || grid[r][c].element === 'pumpkinsprout') {
                        grid[r][c].element = 'pumpkin';
                        grid[r][c].age = cell.age;
                        cell.delay = 0;
                        grid[r][c].went = true;
                        cell.went= true;
                        if(row > 2 && grid[row-2][col].element === 'empty'){
                            grid[row-2][col].element = 'pumpkinstem';
                            if(Math.random() < 0.5){
                            if(row > 3 && col < cols - 1 && grid[row-3][col+1].element === 'empty'){
                                grid[row-3][col+1].element = 'pumpkinstem';
                            }
                            } else    if(row > 3 && col > 0 && grid[row-3][col-1].element === 'empty'){
                                grid[row-3][col-1].element = 'pumpkinstem';
                            }
                        }

                    
                           
                        
                    }
                }
                
            }
            }
            }
        
    } 
}



              if(cell.element === 'pumpkinvine'){
            if(cell.went === false){

               
                
                    if(Math.random() < 0.5){
         newCol = col + 1;
        } else { newCol = col - 1;}
        if(Math.random() < 0.85){
        if(Math.random() < 0.01){newRow = row;}else newRow = row + 1;
        } else {   if(Math.random() < 0.01){newRow = row;}else newRow = row - 1;}
        if(cell.delay > 10){
            if(Math.random() < 0.05){
        if(cell.age < 250){

        if(newCol > 0 && newCol < cols - 1){

            if(newRow > 0 && newRow < rows){

            if(grid[newRow][newCol].element === 'empty'){
            
                 grid[newRow][newCol].age = cell.age;
                grid[newRow][newCol].element = 'pumpkinvine';
                if(Math.random() < 0.1){} else cell.went = true;
            
             
               
            } else{
                if(Math.random() < 0.5){
         newCol = col + 1;
        } else { newCol = col - 1;}
        if(Math.random() < 0.6){
         newRow = row + 1;
        } else { newRow = row - 1;}
            } 
        }
        }
        }
            }
        }
        } 
              }
             
                
                
 
 
 
                     if (cell.element==='human' && row < rows - 1){
                         if (grid[row + 1][col].element === 'oil') {
                            grid[row + 1][col].element = 'human';
                            cell.element = 'empty';
                            // Push water up
                            if (row > 0 && grid[row - 1][col].element === 'empty') {
                                grid[row - 1][col].element = 'oil';
                            }
                        
                        } 
                     }
 
                     if (cell.element==='human' && row < rows - 1){
                         if (grid[row + 1][col].element === 'syrup') {
                            grid[row + 1][col].element = 'human';
                            cell.element = 'empty';
                            // Push water up
                            if (row > 0 && grid[row - 1][col].element === 'empty') {
                                grid[row - 1][col].element = 'syrup';
                            }
                        
                        } 
                     }
                     if (cell.element==='human' && row < rows - 1){
                         if (grid[row + 1][col].element === 'water') {
                            grid[row + 1][col].element = 'human';
                            cell.element = 'empty';
                            // Push water up
                            if (row > 0 && grid[row - 1][col].element === 'empty') {
                                grid[row - 1][col].element = 'water';
                            }
                        
                        } 
                     }
 
                    // Handle sand physics
                    if (cell.element === 'sand' && row < rows - 1 ) {
                        const adjacentCellss = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        let SandAdjacent = adjacentCellss.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'lava');
                        if (SandAdjacent) {
                            grid[row][col].element = 'moltensand';
                        }
                       
                        
                    }
                  
                 
                    if (cell.element === 'sugar' && row < rows - 1) {
                     const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        // Check for adjacent water
                        let sAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
                        // Transform dark lava into stone if adjacent to water
                        if (sAdjacent) {
                            grid[row][col].element = 'syrup';
                        }
                       
                    }

                

                    if (cell.element === 'salt' ) {
                     const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        // Check for adjacent water
                        let saltAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
                        // Transform dark lava into stone if adjacent to water
                        if (saltAdjacent) {
                            grid[row][col].element = 'saltwater';
                        }}

                        if (cell.element === 'water' ) {
                     const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        // Check for adjacent water
                        let pwAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'ash' 
                        );
                        // Transform dark lava into stone if adjacent to water
                        if (pwAdjacent) {
                            grid[row][col].element = 'pwater';
                        }}
                      
                 
                    if (cell.element === 'uranium') {
     
     const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        // Check for adjacent water
                        let pwAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water' 
                        );
                        // Transform dark lava into stone if adjacent to water
                        if (pwAdjacent) {
                           
                        } else cell.age++;
     if (cell.age < 100) {
         cell.uraniumColor = `rgba(0, 204, 0, ${1 - cell.age / 100})`;
     } else if (cell.age === 100) {
         cell.element = 'UExplosion';
       
         cell.uraniumColor = '#BC5800';
     }
 }
 if(cell.element === 'hotsteel'){
    if (cell.sage < 20) {
    // Cold steel (gray)
    cell.hotsteelColor = `rgb(169, 169, 169)`; // Dark gray, cold steel
} else if (cell.sage < 22) {
    // Slightly warm steel (light gray with a hint of orange)
    cell.hotsteelColor = `rgb(180, 160, 140)`; // Light gray with a subtle orange tint
} else if (cell.sage < 24) {
    // Mildly warm steel (gray with more orange)
    cell.hotsteelColor = `rgb(190, 140, 110)`; // More orange, still a bit grayish
} else if (cell.sage < 26) {
    // Warm steel (orange hint)
    cell.hotsteelColor = `rgb(200, 120, 80)`;  // Light orange
} else if (cell.sage < 28) {
    // Warmer steel (bright orange)
    cell.hotsteelColor = `rgb(220, 90, 50)`;   // Brighter orange
} else if (cell.sage < 30) {
    // Hot steel (deep orange)
    cell.hotsteelColor = `rgb(240, 60, 20)`;   // Deep orange, glowing more
} else if (cell.sage < 32) {
    // Very hot steel (orange-red)
    cell.hotsteelColor = `rgb(250, 30, 0)`;    // Orange-red, nearing bright red
} else if (cell.sage < 34) {
    // Extremely hot steel (red-orange)
    cell.hotsteelColor = `#FF5700`;     // Bright red at max heat

} else if (cell.sage < 36) {
    // Max heat (bright red)
    cell.hotsteelColor = `#FF5700`;     // Bright red at max heat
}



 }
 
 if (cell.element === 'brick') {
     
     const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        // Check for adjacent water
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'empty' 
                        );
                        // Transform dark lava into stone if adjacent to water
                        if (Adjacent) {
                           cell.brickColor = '#D4D4D4';
                        } else cell.brickColor = '#D12A2A';
   
 }
 
 if (cell.element === 'faucet') {
    updateFaucet(row, col);
            }
                    // Update Lava Cooling Process
                    if (cell.element === 'lava') {
                        cell.age++;
                        if (cell.age > 500) {} else if (row < rows - 1 && grid[row + 1][col].element === 'empty') {}
                    } else if (cell.element === 'darkLava') {
                        const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        // Check for adjacent water
                        let waterAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
                        // Transform dark lava into stone if adjacent to water
                        if (waterAdjacent) {
                            grid[row][col].element = 'stone';
                        }
                    }
                    if (cell.age > 2050) {} else // Additional Steam Behavior
                        if (cell.element === 'magma') {
                      
                            const adjacentCells = [{
                                    row: row - 1,
                                    col: col
                                }, // Up
                                {
                                    row: row + 1,
                                    col: col
                                }, // Down
                                {
                                    row: row,
                                    col: col - 1
                                }, // Left
                                {
                                    row: row,
                                    col: col + 1
                                } // Right
                            ];
                         
                            // Check for adjacent water cells
                            let waterAdjacent = adjacentCells.some(({
                                    row: r,
                                    col: c
                                }) =>
                                grid[r] && grid[r][c] && grid[r][c].element === 'water'
                            );
                            if (waterAdjacent) {
                                // Transform adjacent water into steam
                                adjacentCells.forEach(({
                                    row: r,
                                    col: c
                                }) => {
                                    if (grid[r] && grid[r][c] && grid[r][c].element === 'water') {
                                        grid[r][c].element = 'steam';
                                        cell.element = 'obsidian'
                                        grid[r][c].age = 0; // Initialize age for steam
                                    }
                                });
                            }
                        }
                        if(cell.element==='cactus' && row < rows -1 ){
 
                         if (grid[row + 1][col].element === 'empty') {
                            grid[row + 1][col].element = 'cactus';
                            cell.element = 'empty'; 
                         }
 
                        }
                    // Handle Steam Physics
                    if (cell.element === 'Explosion') {
     const explosionRadius = 5; // Define the explosion radius
     const startRow = Math.max(0, row - explosionRadius);
     const endRow = Math.min(rows - 1, row + explosionRadius);
     const startCol = Math.max(0, col - explosionRadius);
     const endCol = Math.min(cols - 1, col + explosionRadius);
 
     // Set the center of the explosion to fire
     cell.element = 'fire'; // Set the center cell to fire
     if(Math.random() < 0.5){
     playsfx("explosion1");
     } else{
        playsfx("explosion2");
     }
      cell.age=0;
     for (let r = startRow; r <= endRow; r++) {
         for (let c = startCol; c <= endCol; c++) {
             const distance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (distance <= explosionRadius) {
                 // Check if the cell is TNT
                 if (grid[r][c] && grid[r][c].element === 'uranium') {
                     grid[r][c].element = 'uranium'; // Change TNT to Explosion
                     grid[r][c].element = 'UExplosion'; // Change TNT to Explosion
                 } else  if (grid[r][c] && grid[r][c].element === 'gunpowder') {
                    
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                 } else if (grid[r][c] && grid[r][c].element === 'tnt') {
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                  
                 
                 } else if (grid[r][c] && grid[r][c].element === 'c4') {
                            grid[r][c].element = 'Explosion';
                            grid[r][c].age = 0;

                 } else if (grid[r][c] && elements[grid[r][c].element]) {
                     grid[r][c].element = 'fire'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                     grid[r][c].firemove = false;
                 }
             }
         }
     }
    
 }

  // Handle Steam Physics
  if (cell.element === 'fireballe') {
    if(Math.random() < 0.5){
     playsfx("explosion1");
     } else{
        playsfx("explosion2");
     }
     const explosionRadius = 5; // Define the explosion radius
     const startRow = Math.max(0, row - explosionRadius);
     const endRow = Math.min(rows - 1, row + explosionRadius);
     const startCol = Math.max(0, col - explosionRadius);
     const endCol = Math.min(cols - 1, col + explosionRadius);
 
     // Set the center of the explosion to fire
     cell.element = 'fire'; // Set the center cell to fire
      cell.age=0;
     for (let r = startRow; r <= endRow; r++) {
         for (let c = startCol; c <= endCol; c++) {
             const distance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (distance <= explosionRadius) {
                 // Check if the cell is TNT
                 if (grid[r][c] && grid[r][c].element === 'uranium') {
                     grid[r][c].element = 'uranium'; // Change TNT to Explosion
                     grid[r][c].element = 'UExplosion'; // Change TNT to Explosion
                 } else  if (grid[r][c] && grid[r][c].element === 'gunpowder') {
                    
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                 } else if (grid[r][c] && grid[r][c].element === 'tnt') {
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                  
                 
                 } else if (grid[r][c] && grid[r][c].element === 'fireball') {
                            grid[r][c].element = 'fireball';
                            grid[r][c].age = 0;

                 } else if (grid[r][c] && elements[grid[r][c].element]) {
                     grid[r][c].element = 'fire'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                     grid[r][c].firemove = true;
                 }
             }
         }
     }
 }
  // Handle Steam Physics
  if (cell.element === 'le') {
     const explosionRadius = 10; // Define the explosion radius
     const startRow = Math.max(0, row - explosionRadius);
     const endRow = Math.min(rows - 1, row + explosionRadius);
     const startCol = Math.max(0, col - explosionRadius);
     const endCol = Math.min(cols - 1, col + explosionRadius);
 
     // Set the center of the explosion to fire
     cell.element = 'fire'; // Set the center cell to fire
      cell.age=0;
     for (let r = startRow; r <= endRow; r++) {
         for (let c = startCol; c <= endCol; c++) {
             const distance = Math.sqrt((r - row) ** 3 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (distance <= explosionRadius) {
                if (grid[r][c] && elements[grid[r][c].element === 'lasercannon']) {
                     grid[r][c].element = 'lasercannon'; // Ignite flammable material
                    
                 }else  if (grid[r][c] && elements[grid[r][c].element === 'le']) {
                     grid[r][c].element = 'le'; // Ignite flammable material
                    
                 }else if (grid[r][c] && elements[grid[r][c].element]) {
                    if(Math.random() < 0.5){
                     grid[r][c].element = 'fire'; // Ignite flammable material
                     grid[r][c].firemove = false;
                        cell.age=20;
                    } else grid[r][c].element = 'plasma'; grid[r][c].age = -20; // Initialize fire's age
                    
                     
                 }
             }
         }
     }
     cell.element = 'empty'; // Remove the explosion after it has done its effect
 }
  // Handle Steam Physics

 // Handle Steam Physics
 if (cell.element === 'tl') {
     const explosionRadius = 3; // Define the explosion radius
     const startRow = Math.max(0, row - explosionRadius);
     const endRow = Math.min(rows - 1, row + explosionRadius);
     const startCol = Math.max(0, col - explosionRadius);
     const endCol = Math.min(cols - 1, col + explosionRadius);
 
     
      cell.age=0;
     for (let r = startRow; r <= endRow; r++) {
         for (let c = startCol; c <= endCol; c++) {
             const distance = Math.sqrt((r - row) ** -1.2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (distance <= explosionRadius) {
                if (grid[r][c] && elements[grid[r][c].element]) {
                  grid[r][c].element='Leaf'
                     
                 }
             }
         }
     }
     cell.element = 'Leaf'; // Remove the explosion after it has done its effect
 }
 
 
   // Handle Steam Physics
   if (cell.element === 'fireworke') {
     const explosionRadius = 5; // Define the explosion radius
     const startRow = Math.max(0, row - explosionRadius);
     const endRow = Math.min(rows - 1, row + explosionRadius);
     const startCol = Math.max(0, col - explosionRadius);
     const endCol = Math.min(cols - 1, col + explosionRadius);
    
     // Set the center of the explosion to fire
     cell.element = 'fireworkf'; // Set the center cell to fire
      cell.age=0;

     for (let r = startRow; r <= endRow; r++) {
         for (let c = startCol; c <= endCol; c++) {
             const distance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (distance <= explosionRadius) {
                 // Check if the cell is TNT
                 if (grid[r][c] && grid[r][c].element === 'uranium') {
                     grid[r][c].element = 'uranium'; // Change TNT to Explosion
                     grid[r][c].element = 'UExplosion'; // Change TNT to Explosion
                 } else  if (grid[r][c] && grid[r][c].element === 'gunpowder') {
                    
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                 } else
                 if (grid[r][c] && grid[r][c].element === 'tnt') {
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                  
                 
                 } else
                 if (grid[r][c] && grid[r][c].element === 'firework') {
                     grid[r][c].element = 'firework'; // Change TNT to Explosion
                  
                 
                 } else if (grid[r][c] && grid[r][c].element === 'empty') {
                     grid[r][c].element = 'fireworkf'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                    
                 }
             }
         } 
     }
     cell.element = 'empty'; // Remove the explosion after it has done its effect
 }
 if(cell.element==='fireworkf'){
    cell.age++;
    if(cell.age >= 3){
        cell.element='empty';
    }
 }
 if (cell.element === 'mExplosion') {
    if(Math.random() < 0.5){
     playsfx("explosion1");
     } else{
        playsfx("explosion2");
     }
     const explosionRadius = 4; // Define the explosion radius
     const startRow = Math.max(0, row - explosionRadius);
     const endRow = Math.min(rows - 3, row + explosionRadius);
     const startCol = Math.max(0, col - explosionRadius);
     const endCol = Math.min(cols - 1, col + explosionRadius);
 
     // Set the center of the explosion to fire
     cell.element = 'fire'; // Set the center cell to fire
      cell.age=0;
     for (let r = startRow; r <= endRow; r++) {
         for (let c = startCol; c <= endCol; c++) {
             const distance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (distance <= explosionRadius) {
                 // Check if the cell is TNT
                 if (grid[r][c] && grid[r][c].element === 'uranium') {
                     grid[r][c].element = 'uranium'; // Change TNT to Explosion
                     grid[r][c].element = 'UExplosion'; // Change TNT to Explosion
                 } else  if (grid[r][c] && grid[r][c].element === 'gunpowder') {
                    
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                 } else
                 if (grid[r][c] && grid[r][c].element === 'tnt') {
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                  
                 
                 } else if (grid[r][c] && grid[r][c].element === 'empty') {
                   
                        grid[r][c].element = 'fire'; // Ignite flammable material

                  
                    
                     
                     grid[r][c].age = 0; // Initialize fire's age
                   
                 }
             }
         }
     }
     cell.element = 'empty'; // Remove the explosion after it has done its effect
 }

 if (cell.element === 'naexplosion') {
    if(Math.random() < 0.5){
     playsfx("explosion1");
     } else{
        playsfx("explosion2");
     }
     const explosionRadius = 20; // Define the explosion radius
     const startRow = Math.max(0, row - explosionRadius);
     const endRow = Math.min(rows - 3, row + explosionRadius);
     const startCol = Math.max(0, col - explosionRadius);
     const endCol = Math.min(cols - 1, col + explosionRadius);
 
     // Set the center of the explosion to fire
     cell.element = 'nfire'; // Set the center cell to fire
      cell.age=0;
     for (let r = startRow; r <= endRow; r++) {
         for (let c = startCol; c <= endCol; c++) {
             const distance = Math.sqrt((r - row) ** 2 + (c - col) ** 3); // Calculate the distance from the explosion center
             if (distance <= explosionRadius) {
               
                 // Check if the cell is TNT
                 if (grid[r][c] && grid[r][c].element === 'uranium') {
                     grid[r][c].element = 'uranium'; // Change TNT to Explosion
                     grid[r][c].element = 'UExplosion'; // Change TNT to Explosion
                 } else  if (grid[r][c] && grid[r][c].element === 'gunpowder') {
                    
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                 } else
                 if (grid[r][c] && grid[r][c].element === 'tnt') {
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                  
                 
                 } else if (grid[r][c] && grid[r][c].element === 'empty') {
                   if(Math.random() < 0.3){
                        grid[r][c].element = 'nfire'; // Ignite flammable material
                        
                   } else cell.element = 'empty';
                  
                    
                     
                     grid[r][c].age = 0; // Initialize fire's age
                   
                 }
             }
         }
     }
 }

 if (cell.element === 'cexplosion') {
     const explosionRadius = 15; // Define the explosion radius
     const startRow = Math.max(0, row - explosionRadius);
     const endRow = Math.min(rows - 3, row + explosionRadius);
     const startCol = Math.max(0, col - explosionRadius);
     const endCol = Math.min(cols - 1, col + explosionRadius);
 
     cell.element = 'empty';
      cell.age=0;
     for (let r = startRow; r <= endRow; r++) {
         for (let c = startCol; c <= endCol; c++) {
             const distance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (distance <= explosionRadius) {
                 // Check if the cell is TNT
                 if (grid[r][c] && grid[r][c].element === 'uranium') {
                     grid[r][c].element = 'uranium'; // Change TNT to Explosion
                     grid[r][c].element = 'UExplosion'; // Change TNT to Explosion
                 } else  if (grid[r][c] && grid[r][c].element === 'gunpowder') {
                    
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                 } else
                 if (grid[r][c] && grid[r][c].element === 'tnt') {
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                  
                 
                 } else if (grid[r][c] && grid[r][c].element === 'empty') {
                   if(Math.random() < 0.07){
                        grid[r][c].element = 'bomb'; // Ignite flammable material
                        
                   } else cell.element = 'empty';
                  
                    
                     
                     grid[r][c].age = 0; // Initialize fire's age
                   
                 }
             }
         }
     }
 }
 if (cell.element === 'nb') {
    if(Math.random() < 0.5){
     playsfx("explosion1");
     } else{
        playsfx("explosion2");
     }
     const nexplosionRadius = 5; // Define the explosion radius
     const nstartRow = Math.max(0, row - nexplosionRadius);
     const nendRow = Math.min(rows - 1, row + nexplosionRadius);
     const nstartCol = Math.max(0, col - nexplosionRadius);
     const nendCol = Math.min(cols - 1, col + nexplosionRadius);
 
     // Set the center of the explosion to fire
     cell.element = 'fire'; // Set the center cell to fire
      cell.age=0;
     for (let r = nstartRow; r <= nendRow; r++) {
         for (let c = nstartCol; c <= nendCol; c++) {
             const ndistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (ndistance <= nexplosionRadius) {
                 // Check if the cell is TNT
                 if (grid[r][c] && grid[r][c].element === 'uranium') {
                     grid[r][c].element = 'uranium'; // Change TNT to Explosion
                     grid[r][c].element = 'UExplosion'; // Change TNT to Explosion
                 } else  if (grid[r][c] && grid[r][c].element === 'gunpowder') {
                    
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                 } else
                 if (grid[r][c] && grid[r][c].element === 'tnt') {
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                  
                 
                 } else
                 if (grid[r][c] && grid[r][c].element === 'nitro') {
                     grid[r][c].element = 'nb'; // Change TNT to Explosion
                  
                 
                 }else if (grid[r][c] && elements[grid[r][c].element]) {
                     grid[r][c].element = 'fire'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                     grid[r][c].firemove = false;
                 }
             }
         }
     }
     cell.element = 'empty'; // Remove the explosion after it has done its effect
 }       
                 
 if (cell.element === 'UExplosion') {
     const UexplosionRadius = 15; // Define the explosion radius
     const ustartRow = Math.max(0, row - UexplosionRadius);
     const uendRow = Math.min(rows - 1, row + UexplosionRadius);
     const ustartCol = Math.max(0, col - UexplosionRadius);
     const uendCol = Math.min(cols - 1, col + UexplosionRadius);
 
     // Set the center of the explosion to fire
     cell.element = 'fire'; // Set the center cell to fire
      cell.age=0;
      if(Math.random() < 0.5){
     playsfx("explosion1");
     } else{
        playsfx("explosion2");
     }
     for (let r = ustartRow; r <= uendRow; r++) {
         for (let c = ustartCol; c <= uendCol; c++) {
             const udistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (udistance <= UexplosionRadius) {
                 // Check if the cell is TNT
                 if (grid[r][c] && grid[r][c].element === 'uranium') {
                     grid[r][c].element = 'uranium'; // Change TNT to Explosion
                     grid[r][c].element = 'UExplosion'; // Change TNT to Explosion
                 } else
                 if (grid[r][c] && grid[r][c].element === 'tnt') {
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                  
                 
                 } else if (grid[r][c] && elements[grid[r][c].element]) {
                     grid[r][c].element = 'fire'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                     grid[r][c].firemove = false;
                 } 
             }
         }
     }
  
    
 }
  if (cell.element === 'painte') {
     const UexplosionRadius = 7; // Define the explosion radius
     const ustartRow = Math.max(0, row - UexplosionRadius);
     const uendRow = Math.min(rows - 1, row + UexplosionRadius);
     const ustartCol = Math.max(0, col - UexplosionRadius);
     const uendCol = Math.min(cols - 1, col + UexplosionRadius);
 
     // Set the center of the explosion to fire
    
      cell.age=0;
     for (let r = ustartRow; r <= uendRow; r++) {
         for (let c = ustartCol; c <= uendCol; c++) {
             const udistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (udistance <= UexplosionRadius) {
                if (grid[r][c] && grid[r][c].element === 'empty') {
                  if(Math.random() < 0.2){   grid[r][c].element = 'paint'; // Ignite flammable material
                     grid[r][c].customcolor = cell.customcolor;
                     cell.element = 'empty';
                }

                
                 } 
             }
         }
     }
  
 }
 if (cell.element === 'statice') {
    const UexplosionRadius = 7; // Define the explosion radius
    const ustartRow = Math.max(0, row - UexplosionRadius);
    const uendRow = Math.min(rows - 1, row + UexplosionRadius);
    const ustartCol = Math.max(0, col - UexplosionRadius);
    const uendCol = Math.min(cols - 1, col + UexplosionRadius);

    // Set the center of the explosion to fire
    cell.age = 0;
    
    for (let r = ustartRow; r <= uendRow; r++) {
        for (let c = ustartCol; c <= uendCol; c++) {
            const udistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
            if (udistance <= UexplosionRadius) {
                if (grid[r][c]) {
                    if (Math.random() < 0.7) {
                        // Make sure to store the last state of the cell before changing it
                        grid[r][c].lastelement = structuredClone(grid[r][c]); // Store a clone of the current state

                        // Change the current state of the cell
                        grid[r][c].element = 'static';
                        // Mark the current cell as empty after the change
                        cell.element = 'empty';
                    }
                }
            }
        }
    }
}

 if (cell.element === 'nuexplosion') {
   playsfx("nuke1");
    const explosionRadius = 40;
    const destructionRadius = 50;

    const ustartRow = Math.max(0, row - explosionRadius);
    const uendRow = Math.min(rows - 1, row + explosionRadius);
    const ustartCol = Math.max(0, col - explosionRadius);
    const uendCol = Math.min(cols - 1, col + explosionRadius);
    const ustartRow2 = Math.max(0, row - destructionRadius);
    const uendRow2 = Math.min(rows - 1, row + destructionRadius);
    const ustartCol2 = Math.max(0, col - destructionRadius);
    const uendCol2 = Math.min(cols - 1, col + destructionRadius);

    cell.element = 'fire';
    cell.age = 0;

    const stemHeight = 20;
    const baseRadius = 20;

    for (let r = row; r >= Math.max(0, row - stemHeight); r--) {
        const stemRadius = baseRadius;
        for (let c = ustartCol; c <= uendCol; c++) {
            const udistance = Math.sqrt((r - row) ** 2 + (c - col) ** 6);
            if (udistance <= stemRadius) {
                 if (!['unbreakable'].includes(elements[grid[r][c].element].type)) {
                grid[r][c].element = 'fire';
                grid[r][c].age = 0;
                if (Math.random() < 0.1) {
                    grid[r][c].firemove = false;
                }
                }
            }
        }
    }

    const cloudTop = Math.max(0, row - stemHeight);
    const cloudHeight = 30;

    for (let r = Math.max(0, cloudTop - cloudHeight); r < cloudTop; r++) {
        const cloudRadius = explosionRadius * (1 - Math.abs(r - cloudTop) / cloudHeight);
        for (let c = ustartCol; c <= uendCol; c++) {
            const udistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2);
            if (udistance <= cloudRadius) {
                grid[r][c].element = Math.random() < 0.005 ? 'radiation' : 'fire';
                grid[r][c].age = 0;
                if (Math.random() < 0.1) {
                    grid[r][c].firemove = false;
                }
            }
        }
    }

    for (let r = ustartRow; r <= uendRow; r++) {
        for (let c = ustartCol; c <= uendCol; c++) {
            const udistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2);
            if (udistance > explosionRadius * 0.8 && udistance <= explosionRadius && Math.random() < 0.2) {
                grid[r][c].element = 'smoke';
                grid[r][c].age = 0;
            }
        }
    }

    for (let r = ustartRow2; r <= uendRow2; r++) {
        for (let c = ustartCol2; c <= uendCol2; c++) {
            const udistance2 = Math.sqrt((r - row) ** 2 + (c - col) ** 2);
            if (udistance2 <= destructionRadius) {
                if (!['empty', 'fire', 'smoke', 'radiation', 'nuke', 'nuexplosion'].includes(grid[r][c].element)) {
                     if (!['unbreakable'].includes(elements[grid[r][c].element].type)) {
                    if (Math.random() < 0.8) {
                        initializeCell(r, c, 'empty');
                    } else {
                        grid[r][c].element = Math.random() < 0.3 ? 'radiation' : 'fire';
                        grid[r][c].firemove = true;
                        grid[r][c].age = 10;
                    }
                }
            }
            }
        }
    }

    const shockwaveRadius = explosionRadius * 1.2;
    const shockwaveHeight = explosionRadius * 0.05;

    for (let r = Math.max(0, row - shockwaveHeight); r <= Math.min(rows - 1, row + shockwaveHeight); r++) {
        for (let c = ustartCol; c <= uendCol; c++) {
            const udistance = Math.sqrt(((r - row) ** 2) * 0.5 + (c - col) ** 2);
            if (udistance <= shockwaveRadius && Math.random() < 0.8) {
                grid[r][c].element = Math.random() < 0.3 ? 'fire' : 'smoke';
                grid[r][c].age = 0;
            }
        }
    }

}




 if (cell.element === 'blackhole') {
     const bexplosionRadius = 2; // Define the explosion radius
     const bstartRow = Math.max(0, row - bexplosionRadius);
     const bendRow = Math.min(rows - 1, row + bexplosionRadius);
     const bstartCol = Math.max(0, col - bexplosionRadius);
     const bendCol = Math.min(cols - 1, col + bexplosionRadius);
 
     // Set the center of the explosion to fire
    
    
     for (let r = bstartRow; r <= bendRow; r++) {
         for (let c = bstartCol; c <= bendCol; c++) {
             const bdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (bdistance <= bexplosionRadius) {
                 // Check if the cell is TNT
              
                 cell.element='blackhole';
                 if (grid[r][c] && grid[r][c].element !== 'blackhole' && grid[r][c].element !== 'empty' && grid[r][c].type !== 'unbreakable') {
                    grid[r][c].element = 'empty';
                   
                     grid[r][c].age = 0; // Initialize fire's age
                 }
             }
         }
     }
    
 }
 
 if(cell.element==='tinder' && row < rows -1){
    if(grid[row+1][col].element==='empty'){
        grid[row+1][col].element='tinder';
        cell.element='empty';
    }
 }
 
 if(cell.element==='grenade'){
     cell.delay++;
     if(cell.delay>=30){
         cell.element='Gexplosion';
         cell.delay=0;
     }
 }
 if(cell.element==='empgrenade'){
     cell.delay++;
     if(cell.delay>=20){
         cell.element='emp';
         cell.delay=0;
     }
 }
 if (cell.element === 'Gexplosion') {
    if(Math.random() < 0.5){
     playsfx("explosion1");
     } else{
        playsfx("explosion2");
     }
     const GexplosionRadius = 3; // Define the explosion radius
     const GstartRow = Math.max(0, row - GexplosionRadius);
     const GendRow = Math.min(rows - 1, row + GexplosionRadius);
     const GstartCol = Math.max(0, col - GexplosionRadius);
     const GendCol = Math.min(cols - 1, col + GexplosionRadius);
 
     // Set the center of the explosion to fire
     cell.element = 'fire'; // Set the center cell to fire
      cell.age=0;
     for (let r = GstartRow; r <= GendRow; r++) {
         for (let c = GstartCol; c <= GendCol; c++) {
             const Gdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (Gdistance <= GexplosionRadius) {
                 // Check if the cell is TNT
                 if (grid[r][c] && grid[r][c].element === 'uranium') {
                     grid[r][c].element = 'uranium'; // Change TNT to Explosion
                     grid[r][c].element = 'UExplosion'; // Change TNT to Explosion
                 } else
                 if (grid[r][c] && grid[r][c].element === 'tnt') {
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                  
                 
                 } else  if (grid[r][c] && grid[r][c].element === 'gunpowder') {
                    
                    grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                } else if (grid[r][c] && grid[r][c].element === 'human') {
                     grid[r][c].element = 'ash'; // Change TNT to Explosion
                  
                 
                 } else if (grid[r][c] && elements[grid[r][c].element]) {
                     grid[r][c].element = 'fire'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                     grid[r][c].firemove=false;
                     
                 }
             }
         }
     }
    
 }
 if(cell.element === 'glitchbomb' || cell.element === 'glitchc4'){
    cell.age++;
    if(cell.element === 'glitchbomb'){
    if(cell.age > 100){
        cell.element = 'glitche';
        cell.age = 0;
    }
} else   if(cell.age > 30){
        cell.element = 'glitche';
        cell.age = 0;
    }
 }
 if(cell.element === 'glitchbomb' && row < rows - 1){
    if(grid[row+1][col].element === 'empty'){
        grid[row+1][col] = structuredClone(grid[row][col]);
        initializeCell(row, col, 'empty');
    }
 }

 if (cell.element === 'glitche') {
    const GexplosionRadius = 5; 
    const teleportRadius = 10; // Define the teleport range
    const GstartRow = Math.max(0, row - GexplosionRadius);
    const GendRow = Math.min(rows - 1, row + GexplosionRadius);
    const GstartCol = Math.max(0, col - GexplosionRadius);
    const GendCol = Math.min(cols - 1, col + GexplosionRadius);

    cell.age = 0;

    for (let r = GstartRow; r <= GendRow; r++) {
        for (let c = GstartCol; c <= GendCol; c++) {
            const Gdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2);
            if (Gdistance <= GexplosionRadius) {
                if (grid[r][c] && grid[r][c].element === 'uranium') {
                    grid[r][c].element = 'UExplosion';
                } else if (grid[r][c] && grid[r][c].element === 'tnt') {
                    grid[r][c].element = 'Explosion';
                } else if (grid[r][c] && grid[r][c].element === 'gunpowder') {
                    grid[r][c].element = 'Explosion';
                } else if (grid[r][c] && grid[r][c].element === 'human') {
                    grid[r][c].element = 'ash';
                } else if (grid[r][c] && grid[r][c].element !== 'empty') {
                    teleportWithinRange(r, c, teleportRadius);
                }
            }
        }
    }
    cell.element = 'empty'; // Remove 'glitche' after explosion
}
  if (cell.element !== 'empty' && cell.element !== 'paint') {
    const GexplosionRadius = 1;

    // Calculate the bounds for the square area
    const GstartRow = Math.max(0, row - GexplosionRadius);
    const GendRow = Math.min(rows - 1, row + GexplosionRadius);
    const GstartCol = Math.max(0, col - GexplosionRadius);
    const GendCol = Math.min(cols - 1, col + GexplosionRadius);

    // Loop over the square grid defined by the explosion radius
    for (let r = GstartRow; r <= GendRow; r++) {
        for (let c = GstartCol; c <= GendCol; c++) {
            // Check if the neighboring cell has paint
            if (grid[r][c] && grid[r][c].element === 'paint') {
                // If paint is near, apply changes to the current cell
                cell.customcolor = grid[r][c].customcolor;  // Change color based on nearby paint
                cell.paint = true;  // Mark the current cell as painted

                
            }
        }
    }
}

if (cell.element === 'drill') {
    const GexplosionRadius = 1;
  const teleportRadius = 4; // Define the teleport range
    const GstartRow = Math.max(0, row);
    const GendRow = Math.min(rows - 1, row + GexplosionRadius);
    const GstartCol = Math.max(0, col - GexplosionRadius);
    const GendCol = Math.min(cols - 1, col + GexplosionRadius);

    cell.age = 0;

    if (Math.random() < 0.3) {
        for (let r = GstartRow; r <= GendRow; r++) {
            for (let c = GstartCol; c <= GendCol; c++) {
                // Triangular condition: distance along row must be >= distance along column
                if ((r - row) >= Math.abs(c - col)) {
                    if (grid[r][c] && grid[r][c].element !== 'empty' && grid[r][c].element !== 'drill') {
                       
                        if(Math.random() < 0.5){
   teleportWithinRange2(r, c, teleportRadius);
                        } else  grid[r][c].element = 'empty';
                    }
                }
            }
        }
    }
}

if (cell.element === 'tornado') {
    const GexplosionRadius = 3; 
    const teleportRadius = 6; // Define the teleport range
    const GstartRow = Math.max(0, row - GexplosionRadius);
    const GendRow = Math.min(rows - 1, row + GexplosionRadius);
    const GstartCol = Math.max(0, col - GexplosionRadius);
    const GendCol = Math.min(cols - 1, col + GexplosionRadius);

    

    for (let r = GstartRow; r <= GendRow; r++) {
        for (let c = GstartCol; c <= GendCol; c++) {
            const Gdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2);
            if (Gdistance <= GexplosionRadius) {
                if (grid[r][c] && grid[r][c].element === 'uranium') {
                    grid[r][c].element = 'UExplosion';
                } else if (grid[r][c] && grid[r][c].element === 'tnt') {
                    grid[r][c].element = 'Explosion';
                } else if (grid[r][c] && grid[r][c].element === 'gunpowder') {
                    grid[r][c].element = 'Explosion';
                } else if (grid[r][c] && grid[r][c].element === 'human') {
                    grid[r][c].element = 'ash';
                } else if (grid[r] && grid[r][c] && grid[r][c].element !== 'empty' && grid[r][c].element !== 'tornado2' && grid[r][c].element !== 'tornado') {
                    if(Math.random() < 0.01){
                        grid[r][c].element = 'empty';
                    } else 
                    if(Math.random() < 0.5){
                    teleportWithinRange2(r, c, teleportRadius);
                    } 
                }
            }
        }
    }
   
}
if (cell.element === 'tornado2') {
    const GexplosionRadius = 2; 
    const teleportRadius = 2; // Define the teleport range
    const GstartRow = Math.max(0, row - GexplosionRadius);
    const GendRow = Math.min(rows - 1, row + GexplosionRadius);
    const GstartCol = Math.max(0, col - GexplosionRadius);
    const GendCol = Math.min(cols - 1, col + GexplosionRadius);

    

    for (let r = GstartRow; r <= GendRow; r++) {
        for (let c = GstartCol; c <= GendCol; c++) {
            const Gdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2);
            if (Gdistance <= GexplosionRadius) {
                if (grid[r][c] && grid[r][c].element === 'uranium') {
                    grid[r][c].element = 'UExplosion';
                } else if (grid[r][c] && grid[r][c].element === 'tnt') {
                    grid[r][c].element = 'Explosion';
                } else if (grid[r][c] && grid[r][c].element === 'gunpowder') {
                    grid[r][c].element = 'Explosion';
                } else if (grid[r][c] && grid[r][c].element === 'human') {
                    grid[r][c].element = 'ash';
                } else if (grid[r] && grid[r][c] && grid[r][c].element !== 'empty' && grid[r][c].element !== 'tornado2' && grid[r][c].element !== 'tornado') {
                    
                    if(Math.random() < 0.005){
                        grid[r][c].element = 'empty';
                    } else 
                    if(Math.random() < 0.5){
                    teleportWithinRange2(r, c, teleportRadius);
                    } 
                }
            }
        }
    }
   
}
 if (cell.element === 'bExplosion') {
    if(Math.random() < 0.5){
     playsfx("explosion1");
     } else{
        playsfx("explosion2");
     }
     const GexplosionRadius = 4; // Define the explosion radius
     const GstartRow = Math.max(0, row - GexplosionRadius);
     const GendRow = Math.min(rows - 1, row + GexplosionRadius);
     const GstartCol = Math.max(0, col - GexplosionRadius);
     const GendCol = Math.min(cols - 1, col + GexplosionRadius);
 
     // Set the center of the explosion to fire
     cell.element = 'fire'; // Set the center cell to fire
      cell.age=0;
     for (let r = GstartRow; r <= GendRow; r++) {
         for (let c = GstartCol; c <= GendCol; c++) {
             const Gdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (Gdistance <= GexplosionRadius) {
                 // Check if the cell is TNT
                 if (grid[r][c] && grid[r][c].element === 'uranium') {
                     grid[r][c].element = 'uranium'; // Change TNT to Explosion
                     grid[r][c].element = 'UExplosion'; // Change TNT to Explosion
                 } else
                 if (grid[r][c] && grid[r][c].element === 'tnt') {
                     grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                  
                 
                 } else  if (grid[r][c] && grid[r][c].element === 'gunpowder') {
                    
                    grid[r][c].element = 'Explosion'; // Change TNT to Explosion
                } else  if (grid[r][c] && grid[r][c].element === 'bomb') {
                    
                    grid[r][c].element = 'bomb'; // Change TNT to Explosion
                } else if (grid[r][c] && grid[r][c].element === 'human') {
                     grid[r][c].element = 'ash'; // Change TNT to Explosion
                  
                 
                 } else if (grid[r][c] && elements[grid[r][c].element]) {
                    cell.element='fire';
                     grid[r][c].element = 'fire'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                     grid[r][c].firemove=false;
                     
                 }
             }
         }
     }
     cell.element = 'empty'; // Remove the explosion after it has done its effect
 }
 if (cell.element === 'lexplosion') {
     const GexplosionRadius = 4; // Define the explosion radius
     const GstartRow = Math.max(0, row+1);
     const GendRow = Math.min(rows - 1, row + GexplosionRadius);
     
     const GstartCol = Math.max(0, col - GexplosionRadius);
     const GendCol = Math.min(cols - 1, col + GexplosionRadius);
 
     // Set the center of the explosion to fire
     cell.element = 'lexplosion2'; // Set the center cell to fire
      cell.age=0;
     for (let r = GstartRow; r <= GendRow; r++) {
       
         for (let c = GstartCol; c <= GendCol; c++) {
             const Gdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (Gdistance <= GexplosionRadius) {
                if (grid[r][c] && grid[r][c].element !== 'empty') {
                    grid[r][c].age = 0; // Initialize fire's age
                    
                    if(Math.random() < 0.5){
                     grid[r][c].element = 'empty'; // Ignite flammable material
                    } else  grid[r][c].element = 'plasma';
                    
                 }
                
                
             }
         }
       
     }
    
   
 }
 if (cell.element === 'lexplosion2') {
     const GexplosionRadius = 4; // Define the explosion radius
     const GstartRow = Math.max(0, row - GexplosionRadius);
     const GendRow = Math.min(rows - 1, row);
     
     const GstartCol = Math.max(0, col - GexplosionRadius);
     const GendCol = Math.min(cols - 1, col + GexplosionRadius);
 
    
      cell.age=0;
     for (let r = GstartRow; r <= GendRow; r++) {
       
         for (let c = GstartCol; c <= GendCol; c++) {
             const Gdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (Gdistance <= GexplosionRadius) {
                if (grid[r][c] && grid[r][c].element) {
                    cell.element='empty';
                    grid[r][c].age = 0; // Initialize fire's age
                    
                    if(Math.random() < 0.5){
                     grid[r][c].element = 'flash'; // Ignite flammable material
                    } else  grid[r][c].element = 'empty';
                    
                 }
                
                
             }
         }
      
     }

   
 }
 if (cell.element === 'emp') {
     const GexplosionRadius = 10; // Define the explosion radius
     const GstartRow = Math.max(0, row - GexplosionRadius);
     const GendRow = Math.min(rows - 1, row + GexplosionRadius);
     const GstartCol = Math.max(0, col - GexplosionRadius);
     const GendCol = Math.min(cols - 1, col + GexplosionRadius);
 
     
      cell.age=0;
     for (let r = GstartRow; r <= GendRow; r++) {
         for (let c = GstartCol; c <= GendCol; c++) {
             const Gdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (Gdistance <= GexplosionRadius) {
                 // Check if the cell is TNT
                if (grid[r][c] && grid[r][c].element === 'wire') {
                  
                     grid[r][c].element = 'ewire'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                     
                     
                 } else  if (grid[r][c] && grid[r][c].element === 'redlightoff') {
                  
                  grid[r][c].element = 'redlight'; // Ignite flammable material
                  grid[r][c].age = 0; // Initialize fire's age
                 
                  
                  
              } else  if (grid[r][c] && grid[r][c].element === 'missilehead') {
                  
                  grid[r][c].element = 'shock'; // Ignite flammable material
                  grid[r][c].age = 0; // Initialize fire's age
                  grid[r][c].delay = -10; // Initialize fire's age
                  
                  
              } else if (grid[r][c] && grid[r][c].element === 'empty') {
                  
                  grid[r][c].element = 'shock'; // Ignite flammable material
                  
                  
                  
                  
              } 
             }
         }
     }
     cell.element = 'empty'; // Remove the explosion after it has done its effect
 }
 
 if(cell.element !== 'empty' && row > 0){
    if(cell.e===true){
        cell.edelay++;
        if(cell.edelay > 1){
            if(Math.random() < 0.1){
            if(grid[row-1][col].element === 'empty')
        grid[row-1][col].element=cell.element;
        cell.element='empty';
        cell.edelay=0;
        cell.e=false;
            }
        }
    }
 }
 
 if (cell.element === 'earthquake') {
     const GexplosionRadius = 10; // Define the explosion radius
     const GstartRow = Math.max(0, row - GexplosionRadius);
     const GendRow = Math.min(rows - 1, row + GexplosionRadius);
     const GstartCol = Math.max(0, col - GexplosionRadius);
     const GendCol = Math.min(cols - 1, col + GexplosionRadius);
 
     
      
     for (let r = GstartRow; r <= GendRow; r++) {
         for (let c = GstartCol; c <= GendCol; c++) {
             const Gdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (Gdistance <= GexplosionRadius) {
                 if (grid[r][c] && grid[r][c].element) {
                  
                  grid[r][c].e=true; // Ignite flammable material
                  
                  
                  
                  
              } 
             }
         }
     }
     cell.element = 'empty'; // Remove the explosion after it has done its effect
 }

 if (cell.element === 'h2oe') {
     const GexplosionRadius = 5; // Define the explosion radius
     const GstartRow = Math.max(0, row - GexplosionRadius);
     const GendRow = Math.min(rows - 1, row + GexplosionRadius);
     const GstartCol = Math.max(0, col - GexplosionRadius);
     const GendCol = Math.min(cols - 1, col + GexplosionRadius);
 
     
      
     for (let r = GstartRow; r <= GendRow; r++) {
         for (let c = GstartCol; c <= GendCol; c++) {
             const Gdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (Gdistance <= GexplosionRadius) {
                 if (grid[r][c] && grid[r][c].element === 'empty' || elements[grid[r][c].element].flammable === true) {
                  
                  if(Math.random() < 0.1){
                    initializeCell(r, c, 'water');
                  } else    initializeCell(r, c, 'fire');
                  
                  
                  
              } else if(grid[r][c] && grid[r][c].element === 'oxygen' || grid[r][c].element === 'hydrogen'){
                initializeCell(r, c, 'h2oe');
              } 
             }
         }
     }
     initializeCell(row, col, 'empty');
 }
 if (cell.element === 'teslacoil') {
    cell.age++;
     const explosionRadius = 5; // Define the explosion radius
     const startRow = Math.max(0, row - explosionRadius);
     const endRow = Math.min(rows - 1, row + explosionRadius);
     const startCol = Math.max(0, col - explosionRadius);
     const endCol = Math.min(cols - 1, col + explosionRadius);
 
     
     
     for (let r = startRow; r <= endRow; r++) {
         for (let c = startCol; c <= endCol; c++) {
             const distance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (distance <= explosionRadius && cell.age>=0) {
                if (Math.random() < 0.01) {
                cell.age=0;
                 // Check if the cell is TNT
                if (grid[r][c] && grid[r][c].element === 'wire') {
                  
                     grid[r][c].element = 'ewire'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                     
                     
                 } else  if (grid[r][c] && grid[r][c].element === 'redlightoff') {
                  
                  grid[r][c].element = 'redlight'; // Ignite flammable material
                  grid[r][c].age = 0; // Initialize fire's age
                 
                  
                  
              } else  if (grid[r][c] && grid[r][c].element === 'missilehead') {
                  
                  grid[r][c].element = 'shock'; // Ignite flammable material
                  grid[r][c].age = 0; // Initialize fire's age
                  grid[r][c].delay = -10; // Initialize fire's age
                  
                  
              } else if (grid[r][c] && grid[r][c].element === 'empty') {
                  
                  grid[r][c].element = 'shock'; // Ignite flammable material
                  grid[r][c].age =0;
                  
                  
                  
                  
              } 
             }
            }
         }
     }
    
 }

 if (cell.element === 'acid') {
                 // Increment the delay for acid
                 cell.delay++;
 
                 // Check adjacent cells
                 const adjacentCells = [
                     { row: row - 1, col: col }, // Up
                     { row: row + 1, col: col }, // Down
                     { row: row, col: col - 1 }, // Left
                     { row: row, col: col + 1 }  // Right
                 ];
 
                 // If delay reaches a certain threshold, destroy adjacent elements
                 if (cell.delay >= 15) { // Adjust this number for delay (60 frames = 1 second at 60fps)
                     adjacentCells.forEach(({ row: r, col: c }) => {
                         if (grid[r] && grid[r][c] && grid[r][c].element !== 'acid') {
                             grid[r][c].element = 'empty'; // Destroy the material
                         }
                     });
                     cell.delay = 0; // Reset the delay after destruction
                 }
             }

 if (cell.element === 'sa') {
                 // Increment the delay for acid
                 cell.delay++;
 
                 // Check adjacent cells
                 const adjacentCells = [
                     { row: row - 1, col: col }, // Up
                     { row: row + 1, col: col }, // Down
                     { row: row, col: col - 1 }, // Left
                     { row: row, col: col + 1 }  // Right
                 ];
 
                 // If delay reaches a certain threshold, destroy adjacent elements
                 if (cell.delay >= 25) { // Adjust this number for delay (60 frames = 1 second at 60fps)
                     adjacentCells.forEach(({ row: r, col: c }) => {
                         if (grid[r] && grid[r][c] && grid[r][c].element !== 'sa') {
                             grid[r][c].element = 'empty'; // Destroy the material
                         }
                     });
                     cell.delay = 0; // Reset the delay after destruction
                 }
             }
             if(cell.element==='missilehead' && col > 0){
              
                grid[row][col-1].element = 'missilebody';
                
             }
             
           
             if(cell.element==='bomb'){
                if(row < rows - 1){
                if(grid[row+1][col].element==='empty' || grid[row+1][col].element==='fire' || grid[row+1][col].element==='smoke' || grid[row+1][col].element==='bomb'){
                    grid[row+1][col].element='bomb';
                    cell.element='empty';
                } else  cell.element='bExplosion';} else{
                    cell.element='bExplosion';
                }
             }
            
             
             
            
             if(cell.element==='missilebody'){
                
                if( grid[row][col+1].element !== 'missilehead'){
                    cell.element='empty';
                
            }
             }
             if(cell.element==='missilehead' && col < cols - 1){
                cell.delay++;
                if(cell.delay>=5){
                if(grid[row][col+1].element==='empty'){
                    grid[row][col+1].element = 'missilehead';
                    cell.element='empty';
                    cell.delay=0;

                }
            }
             }
             if(cell.element==='bullet'){
                cell.delay++;
                if(col < cols - 1){
                if(cell.delay>=2){
                    
                if(grid[row][col+1].element==='empty'){
                    grid[row][col+1].element = 'bullet';
                    cell.element='empty';
                    cell.delay=0;

                } else grid[row][col+1].element='empty'; cell.element='empty';
            }
            } else cell.element='empty';
             }
         
             if(cell.element === 'wind'){
                cell.age++;
                if(cell.age > 20){
                    cell.element = 'empty';
                }
             }
           if(cell.element === 'wind' && col < cols - 1){
          
            if(grid[row][col+1].element === 'empty'){
                cell.delay++;
                if(cell.delay >= 2){
                grid[row][col+1].element = 'wind';
                grid[row][col+1].age = cell.age;
                cell.element = 'empty';
                
                cell.delay=0;
                grid[row][col].age = 0;
                
                }
            } else {
                cell.element = 'empty';
                grid[row][col+1].wind = true;
           
        } 
           }
           if(cell.wind === true && col < cols - 1){
            
            if(grid[row][col+1].element === 'empty'){
                cell.delay++;
                if(cell.delay >= 2){
                    grid[row][col + 1].element = cell.element;
                cell.element = 'empty';
                cell.wind = false;
                cell.delay = 0;
                cell.age=0;
                grid[row][col].age = 0;

                
                }
            } else {
                grid[row][col+1].wind = true;
            }
           }
             if(cell.element==='missilehead'){
                if(col > cols - 2){
                    cell.element='Explosion';
                }
             }
             if(cell.element==='missilehead'){
                if(grid[row][col+1].element!=='empty'){
                    cell.element='Explosion';
                }
             }
             

 if (cell.element === 'smokeBomb') {
     cell.delay++;
 
     const sexplosionRadius = 5; // Define the explosion radius
     const sstartRow = Math.max(0, row - sexplosionRadius);
     const sendRow = Math.min(rows - 1, row + sexplosionRadius);
     const sstartCol = Math.max(0, col - sexplosionRadius);
     const sendCol = Math.min(cols - 1, col + sexplosionRadius);
 
     // Set the center of the explosion to fire
     if(cell.delay>=20){
     cell.element = 'smoke'; // Set the center cell to fire
      cell.age=0;
     
     for (let r = sstartRow; r <= sendRow; r++) {
         for (let c = sstartCol; c <= sendCol; c++) {
             const sdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (sdistance <= sexplosionRadius) {
                 // Check if the cell is TNT
                 
                  if (grid[r][c] && grid[r][c].element === 'empty') {
                    
                     grid[r][c].element = 'smoke'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                     
                 }
             }
         }
     }
     cell.element = 'empty'; // Remove the explosion after it has done its effect
 }
 }

 if(cell.element==='antimatterbomb' && row < rows - 1){
    if(grid[row+1][col].element==='empty'){
        grid[row+1][col].element='antimatterbomb';
        cell.element='empty';
        cell.age=0;
        cell.delay=0;
        grid[row+1][col].delay = cell.delay;
        grid[row+1][col].age = cell.age;
    }
 }

 if (cell.element === 'antimatterbomb') {
     cell.delay++;
 
     const sexplosionRadius = 5; // Define the explosion radius
     const sstartRow = Math.max(0, row - sexplosionRadius);
     const sendRow = Math.min(rows - 1, row + sexplosionRadius);
     const sstartCol = Math.max(0, col - sexplosionRadius);
     const sendCol = Math.min(cols - 1, col + sexplosionRadius);
 
     // Set the center of the explosion to fire
     if(cell.delay>=15){
     cell.element = 'antimatter'; // Set the center cell to fire
      cell.age=0;
      cell.delay=0;
     
     for (let r = sstartRow; r <= sendRow; r++) {
         for (let c = sstartCol; c <= sendCol; c++) {
             const sdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (sdistance <= sexplosionRadius) {
                 // Check if the cell is TNT
                 
                  if (grid[r][c] && grid[r][c].element) {
                    
                     grid[r][c].element = 'antimatter'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                     
                 }
             }
         }
     }
    
 }
 }

 if (cell.element === 'lavabomb') {
     cell.delay++;
 
     const sexplosionRadius = 5; // Define the explosion radius
     const sstartRow = Math.max(0, row - sexplosionRadius);
     const sendRow = Math.min(rows - 1, row + sexplosionRadius);
     const sstartCol = Math.max(0, col - sexplosionRadius);
     const sendCol = Math.min(cols - 1, col + sexplosionRadius);
 
     // Set the center of the explosion to fire
     if(cell.delay>=15){
     cell.element = 'lava'; // Set the center cell to fire
      cell.age=0;
      cell.delay=0;
     
     for (let r = sstartRow; r <= sendRow; r++) {
         for (let c = sstartCol; c <= sendCol; c++) {
             const sdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (sdistance <= sexplosionRadius) {
                 // Check if the cell is TNT
                 
                  if (grid[r][c] && grid[r][c].element) {
                    
                     if(Math.random() < 0.3) {grid[r][c].element = 'lava'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                  }
                     
                 }
             }
         }
     }
    
 }
 }

 if (cell.element === 'flowerbud') {
    
     const sexplosionRadius = 3; // Define the explosion radius
     const sstartRow = Math.max(0, row - sexplosionRadius);
     const sendRow = Math.min(rows - 1, row + sexplosionRadius);
     const sstartCol = Math.max(0, col - sexplosionRadius);
     const sendCol = Math.min(cols - 1, col + sexplosionRadius);
 
    
    
         // List of possible elements to replace the virus
                
         const possibleElements = Object.keys(elements).filter(el => elements[el].type === 'fp');
                 const randomElement = possibleElements[Math.floor(Math.random() * possibleElements.length)];
 
                 // Replace virus with a random element
                 cell.element = randomElement;
     
     for (let r = sstartRow; r <= sendRow; r++) {
         for (let c = sstartCol; c <= sendCol; c++) {
             const sdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (sdistance <= sexplosionRadius) {
                 // Check if the cell is TNT
                 
                  if (grid[r][c] && grid[r][c].element) {
                    
                     grid[r][c].element = randomElement;
                     grid[r][c].age = 0; // Initialize fire's age
                     grid[r][c].fpmove = false;
                     
                 }
             }
         }
     }
    
 
 }

 if(cell.element==='me' && col > 0 && col < cols -2 && row < rows -1 && row > 0){
    grid[row][col-1].element='mushroomtop';
    grid[row][col+1].element='mushroomtop';
    grid[row][col].element='mushroomtop';
 }

 if (cell.element === 'partypopper') {
    
 
     const sexplosionRadius = 10; // Define the explosion radius
     const sstartRow = Math.max(0, row - sexplosionRadius);
     const sendRow = Math.min(rows - 1, row + sexplosionRadius);
     const sstartCol = Math.max(0, col - sexplosionRadius);
     const sendCol = Math.min(cols - 1, col + sexplosionRadius);
 
     // Set the center of the explosion to fire
     if(row < rows -1){
     if(grid[row+1][col].element==='empty'){
        grid[row+1][col].element = 'partypopper';
        cell.element='empty';
     } else cell.age++;
    } else cell.age++;
    if(cell.age > 0){
     for (let r = sstartRow; r <= sendRow; r++) {
         for (let c = sstartCol; c <= sendCol; c++) {
             const sdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
             if (sdistance <= sexplosionRadius) {
                 // Check if the cell is TNT
                 
                  if (grid[r][c] && grid[r][c].element === 'empty') {
                    if(Math.random() <0.2){
                     grid[r][c].element = 'cf'; // Ignite flammable material
                     grid[r][c].age = 0; // Initialize fire's age
                    }
                     
                 }
             }
         }
     }
    }
     cell.element = 'empty'; // Remove the explosion after it has done its effect
 
 }
 



 if(cell.element==='foam' && row > 0){
    if(grid[row-1][col].element === 'mentos'){
        cell.element='mentos';
        grid[row-1][col].element = 'empty';
    }
}
if(cell.element==='foamo' && row > 0){
    if(grid[row-1][col].element === 'mentos'){
        cell.element='mentos';
        grid[row-1][col].element = 'empty';
    }
}
 if (cell.element === 'mentos') {
    
 
    const sexplosionRadius = 10; // Define the explosion radius
    const sstartRow = Math.max(0, row - sexplosionRadius);
    const sendRow = Math.min(rows - 1, row + sexplosionRadius);
    const sstartCol = Math.max(0, col - sexplosionRadius);
    const sendCol = Math.min(cols - 1, col + sexplosionRadius);
    const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                        const Adjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'soda'
                        );
 
 if(Adjacent){
    
    for (let r = sstartRow; r <= sendRow; r++) {
        for (let c = sstartCol; c <= sendCol; c++) {
            const sdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
            if (sdistance <= sexplosionRadius) {
                // Check if the cell is TNT
                
                 if (grid[r][c] && grid[r][c].element === 'empty') {
                   if(Math.random() <0.2){
                    cell.element = 'empty';
                    grid[r][c].element = 'foam'; // Ignite flammable material
                    grid[r][c].age = 0; // Initialize fire's age
                   }
                    
                }
            }
        }
    }
}
    

}

if (cell.element === 'supernova') {
    cell.delay++;

    const spexplosionRadius = 50; // Much bigger explosion
    const spstartRow = Math.max(0, row - spexplosionRadius);
    const spendRow = Math.min(rows - 1, row + spexplosionRadius);
    const spstartCol = Math.max(0, col - spexplosionRadius);
    const spendCol = Math.min(cols - 1, col + spexplosionRadius);

    if (cell.delay >= 5) {
        for (let r = spstartRow; r <= spendRow; r++) {
            for (let c = spstartCol; c <= spendCol; c++) {
                const spdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Distance from center
                
                if (spdistance <= spexplosionRadius) {
                    grid[r][c].element = 'empty';
                    if (spdistance < spexplosionRadius * 0.2) {

                        grid[r][c].element = 'plasma'; // Inner core fully turns into plasma
                    } else if (spdistance < spexplosionRadius * 0.5) {
                        if(Math.random() < 0.5){
                        grid[r][c].element = 'fire'; // Middle region catches fire
                        }
                    } else if (spdistance < spexplosionRadius * 0.7) {
                        if(Math.random() < 0.3){
                        grid[r][c].element = 'smoke'; // Outer shockwave effect
                        }
                    } else {
                        if(Math.random() < 0.1){
                        grid[r][c].element = 'radiation'; // Radiation lingering at the edges
                        }
                    }
                    grid[r][c].age = 0; // Reset age
                }
            }
        }
        cell.element = 'empty'; // Remove the supernova core
    }
}

 if (cell.element === 'snap') {
    const spexplosionRadius = 1000; // Define the explosion radius
    const spstartRow = Math.max(0, row - spexplosionRadius);
    const spendRow = Math.min(rows - 1, row + spexplosionRadius);
    const spstartCol = Math.max(0, col - spexplosionRadius);
    const spendCol = Math.min(cols - 1, col + spexplosionRadius);

    let affectedCells = [];

    // Collect all valid cells in the explosion radius
    for (let r = spstartRow; r <= spendRow; r++) {
        for (let c = spstartCol; c <= spendCol; c++) {
            const spdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2);
            if (spdistance <= spexplosionRadius && grid[r][c].element !== 'empty' && grid[r][c].element !== 'snap' && grid[r][c].element !== 'dust') {
                affectedCells.push({ r, c });
            }
        }
    }

    // Shuffle the array (Fisher-Yates shuffle)
    for (let i = affectedCells.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [affectedCells[i], affectedCells[j]] = [affectedCells[j], affectedCells[i]];
    }

    // Apply effect to half of the affected cells
    const halfCount = Math.floor(affectedCells.length / 2);
    for (let i = 0; i < halfCount; i++) {
        const { r, c } = affectedCells[i];
        grid[r][c].snap = true;
    }

    cell.element = 'empty'; // Remove the explosion after it has done its effect
}
if(cell.element === 'cactusexplosion'){
    cactus(row, col);
}
if (cell.element === 'bushe') {
    const bushs = {
        bushlong: {
            name: "bushlong",
            bush: [
                ['empty', 'empty', 'empty'],
                ['empty', 'bushleaf', 'empty'],
                ['bushleaf', 'bushleaf', 'bushleaf']
            ]
        },
        bushsmall1: {
            name: "bushsmall1",
            bush: [
                ['empty', 'empty', 'empty'],
                ['empty', 'bushleaf', 'empty'],
                ['bushleaf', 'bushleaf', 'empty']
            ]
        },
        bushsmall2: {
            name: "bushsmall2",
            bush: [
                ['empty', 'empty', 'empty'],
                ['empty', 'bushleaf', 'empty'],
                ['empty', 'bushleaf', 'bushleaf']
            ]
        },
        bushtiny: {
            name: "bushtiny",
            bush: [
                ['empty', 'empty', 'empty'],
                ['empty', 'empty', 'empty'],
                ['empty', 'bushleaf', 'empty']
            ]
        }
    };

    const bushOptions = Object.values(bushs);
    const bush = bushOptions[Math.floor(Math.random() * bushOptions.length)];
    const bushused = bush.bush;
    const bushused2 = bush.name;


    console.log(`bush: ${bushused2}`);
    cell.element = 'empty';
    placeShape(row-2, col-1, bushused, true);
}
if (cell.element === 'rocke') {
    const boulders = {
        boulderlarge: {
            name: "boulderlarge",
            shape: [
                ['empty', 'empty', 'empty'],
                ['empty', 'stone', 'stone'],
                ['stone', 'stone', 'stone']
            ]
        },
        bouldermedium: {
            name: "bouldermedium",
            shape: [
                ['empty', 'empty', 'empty'],
                ['empty', 'stone', 'stone'],
                ['stone', 'stone', 'empty']
            ]
        },
        bouldersmall: {
            name: "bouldersmall",
            shape: [
                ['empty', 'empty', 'empty'],
                ['empty', 'empty', 'stone'],
                ['empty', 'stone', 'empty']
            ]
        },
        bouldertiny: {
            name: "bouldertiny",
            shape: [
                ['empty', 'empty', 'empty'],
                ['empty', 'empty', 'empty'],
                ['empty', 'stone', 'empty']
            ]
        },
        boulderhuge: {
            name: "boulderhuge",
            shape: [
                ['empty', 'stone', 'stone', 'stone', 'stone'],
                ['stone', 'stone', 'stone', 'stone', 'stone'],
                ['stone', 'stone', 'stone', 'stone', 'stone'],
                ['stone', 'stone', 'stone', 'stone', 'empty'],
                ['empty', 'stone', 'stone', 'stone', 'empty']
            ]
        },
        bouldermidhuge: {
            name: "bouldermidhuge",
            shape: [
                ['empty', 'stone', 'stone', 'stone'],
                ['stone', 'stone', 'stone', 'stone'],
                ['stone', 'stone', 'stone', 'empty']
            ]
        },
        bouldertinyhuge: {
            name: "bouldertinyhuge",
            shape: [
                ['empty', 'stone', 'stone'],
                ['stone', 'stone', 'stone'],
                ['stone', 'empty', 'empty']
            ]
        },
        boulderbigsmall: {
            name: "boulderbigsmall",
            shape: [
                ['empty', 'empty', 'empty', 'empty'],
                ['empty', 'stone', 'stone', 'stone'],
                ['stone', 'stone', 'stone', 'empty'],
                ['empty', 'stone', 'stone', 'empty']
            ]
        },
        boulderbigsmallmoss: {
            name: "boulderbigsmallmoss",
            shape: [
                ['empty', 'grass', 'empty', 'empty'],
                ['grass', 'stone', 'grass', 'stone'],
                ['stone', 'stone', 'stone', 'empty'],
                ['empty', 'stone', 'stone', 'empty']
            ]
        }
    };

    const rotations = [
        (shape) => shape, // 0° rotation (original)
        (shape) => shape[0].map((_, i) => shape.map(row => row[i])).reverse(), // 90° rotation
        (shape) => shape.reverse().map(row => row.reverse()), // 180° rotation
        (shape) => shape[0].map((_, i) => shape.map(row => row[i])).reverse().reverse() // 270° rotation
    ];

    const boulderOptions = Object.values(boulders);
    const boulder = boulderOptions[Math.floor(Math.random() * boulderOptions.length)];
    const boulderName = boulder.name;
    let boulderShape = boulder.shape;

    // Randomly rotate the boulder shape
    const rotationIndex = Math.floor(Math.random() * rotations.length);
    boulderShape = rotations[rotationIndex](boulderShape);

    // Get boulder's dimensions (height and width)
    const boulderHeight = boulderShape.length;
    const boulderWidth = boulderShape[0].length;

    // Adjust row and column to center the boulder
    const adjustedRow = row - Math.floor(boulderHeight / 2);
    const adjustedCol = col - Math.floor(boulderWidth / 2);

    console.log(`boulder: ${boulderName} with rotation ${rotationIndex * 90}°`);
    cell.element = 'empty';

    // Place the boulder in the adjusted position
    placeShape(adjustedRow, adjustedCol, boulderShape, true);
}


 if (cell.element === 'snapnm') {
    
 
    const spexplosionRadius = 1000; // Define the explosion radius
    const spstartRow = Math.max(0, row - spexplosionRadius);
    const spendRow = Math.min(rows - 1, row + spexplosionRadius);
    const spstartCol = Math.max(0, col - spexplosionRadius);
    const spendCol = Math.min(cols - 1, col + spexplosionRadius);

    // Set the center of the explosion to fire
    
    
    for (let r = spstartRow; r <= spendRow; r++) {
        for (let c = spstartCol; c <= spendCol; c++) {
            const spdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
            if (spdistance <= spexplosionRadius) {
                // Check if the cell is TNT
                if(grid[r][c].element !== 'empty'){
                
                   
                    grid[r][c].snapnm = true; // Ignite flammable material
                   
                    
                
            }
        }
        
    }
    cell.element = 'empty'; // Remove the explosion after it has done its effect
   }
}

 if (cell.element === 'speaker') {
    
 
    const spexplosionRadius = 1000; // Define the explosion radius
    const spstartRow = Math.max(0, row - spexplosionRadius);
    const spendRow = Math.min(rows - 1, row + spexplosionRadius);
    const spstartCol = Math.max(0, col - spexplosionRadius);
    const spendCol = Math.min(cols - 1, col + spexplosionRadius);

    // Set the center of the explosion to fire
    
    
    for (let r = spstartRow; r <= spendRow; r++) {
        for (let c = spstartCol; c <= spendCol; c++) {
            const spdistance = Math.sqrt((r - row) ** 2 + (c - col) ** 2); // Calculate the distance from the explosion center
            if (spdistance <= spexplosionRadius) {
                // Check if the cell is TNT
                if(grid[r][c].element !== 'empty' && grid[r][c].element !== 'speaker'){
                
                   
                    grid[r][c].sound = true; // Ignite flammable material
                   
                    
                
            }
        }
        
    }
   }
}

if(cell.element === 'dust'){
    cell.age++;
    if(cell.age > 9){
        cell.element = 'empty';
        cell.age=0;
    }
}
 if (cell.element === 'magma') {
                      
                      const adjacentCells = [{
                              row: row - 1,
                              col: col
                          }, // Up
                          {
                              row: row + 1,
                              col: col
                          }, // Down
                          {
                              row: row,
                              col: col - 1
                          }, // Left
                          {
                              row: row,
                              col: col + 1
                          } // Right
                      ];
                          adjacentCells.forEach(({ row: r, col: c }) => {
         if (grid[r] && grid[r][c] && elements[grid[r][c].element].flammable) {
             grid[r][c].element = 'fire'; // Ignite flammable material
             grid[r][c].age = 0; // Initialize fire's age
         }
     });
    }
                      if (cell.element === 'stone') {
                      
                      const adjacentCells = [{
                              row: row - 1,
                              col: col
                          }, // Up
                          {
                              row: row + 1,
                              col: col
                          }, // Down
                          {
                              row: row,
                              col: col - 1
                          }, // Left
                          {
                              row: row,
                              col: col + 1
                          } // Right
                      ];
                    
                      // Check for adjacent water cells
                      let lavaAdjacents = adjacentCells.some(({
                              row: r,
                              col: c
                          }) =>
                          grid[r] && grid[r][c] && grid[r][c].element === 'lava'
                      );
                     
                      if (lavaAdjacents) {
                          // Transform adjacent water into steam
                          adjacentCells.forEach(({
                              row: r,
                              col: c
                          }) => {
                             
                              if (grid[r] && grid[r][c] && grid[r][c].element === 'lava') {
                                 cell.age++;
                                 if (cell.age >= 1000){
                                 
                                  cell.element = 'lowheatrock'
                                  } 
                              
                             }
 
                          });
                      }else{if (cell.age>0){cell.age--;}}}
                      if (cell.element === 'lowheatrock') {
                      
                      const adjacentCells = [{
                              row: row - 1,
                              col: col
                          }, // Up
                          {
                              row: row + 1,
                              col: col
                          }, // Down
                          {
                              row: row,
                              col: col - 1
                          }, // Left
                          {
                              row: row,
                              col: col + 1
                          } // Right
                      ];
                   
                      // Check for adjacent water cells
                      let lavaAdjacents = adjacentCells.some(({
                              row: r,
                              col: c
                              
                          }) =>
                          grid[r] && grid[r][c] && grid[r][c].element === 'lava'
                      );
                      if (lavaAdjacents) {
                       
                          // Transform adjacent water into steam
                          adjacentCells.forEach(({
                              row: r,
                              col: c
                          }) => {
                            
                              if (grid[r] && grid[r][c] && grid[r][c].element === 'lava') {
                                 
                                 cell.age++;
                                 
                              if(cell.age>=2000){
                                 cell.element='mediumheatrock';
                              }
                              
                             } 
                          });
                      } else{ if (cell.age>=0){cell.age--;;}}if (cell.age < 500 ){cell.element='stone'} }
                      if (cell.element === 'mediumheatrock') {
                      
                      const adjacentCells = [{
                              row: row - 1,
                              col: col
                          }, // Up
                          {
                              row: row + 1,
                              col: col
                          }, // Down
                          {
                              row: row,
                              col: col - 1
                          }, // Left
                          {
                              row: row,
                              col: col + 1
                          } // Right
                      ];
                          adjacentCells.forEach(({ row: r, col: c }) => {
         if (grid[r] && grid[r][c] && elements[grid[r][c].element].flammable) {
             grid[r][c].element = 'fire'; // Ignite flammable material
             grid[r][c].age = 0; // Initialize fire's age
         }
     });
                      // Check for adjacent water cells
                      let lavaAdjacents = adjacentCells.some(({
                              row: r,
                              col: c
                              
                          }) =>
                          grid[r] && grid[r][c] && grid[r][c].element === 'lava'
                      );
                      if (lavaAdjacents) {
                       
                          // Transform adjacent water into steam
                          adjacentCells.forEach(({
                              row: r,
                              col: c
                          }) => {
                            
                              if (grid[r] && grid[r][c] && grid[r][c].element === 'lava') {
                                 
                                 cell.age++;
                                 
                              
                              
                             } 
                          });
                      } else{ if (cell.age>=0){cell.age--;;}}if (cell.age < 2000 ){cell.element='lowheatrock'} }
   if (cell.element === 'cloner') {
                 // Check adjacent cells
                 const adjacentCells = [
                     { row: row - 1, col: col }, // Up
                     { row: row + 1, col: col }, // Down
                     { row: row, col: col - 1 }, // Left
                     { row: row, col: col + 1 }  // Right
                 ];
 
                 // Look for a non-empty adjacent element
                 
                 for (const { row: r, col: c } of adjacentCells) {
                     if (grid[r] && grid[r][c] && grid[r][c].element !== 'empty'&& grid[r][c].element !== 'cloner') {
                         cell.delay++;
                         if(cell.delay===10){
                         // Change the cloner to the element of the adjacent cell
                         cell.element = grid[r][c].element; // Clone the adjacent element
                         cell.age = 0; // Reset age when transformed
                         break; // Exit loop after transforming
                         }
                     }
                 }
             }
           
             if (cell.element === 'solidcloner') {
                 // Check adjacent cells
                 const adjacentCells = [
                     { row: row - 1, col: col }, // Up
                     { row: row + 1, col: col }, // Down
                     { row: row, col: col - 1 }, // Left
                     { row: row, col: col + 1 }  // Right
                 ];
 
                 // Look for a non-empty adjacent element
                 
                 for (const { row: r, col: c } of adjacentCells) {
                     if (grid[r] && grid[r][c] && grid[r][c].element !== 'empty'&& grid[r][c].element !== 'solidcloner') {
                         cell.delay++;
                         if(cell.delay===10){
                         // Change the cloner to the element of the adjacent cell
                         cell.element = grid[r][c].element; // Clone the adjacent element
                         cell.age = 0; // Reset age when transformed
                         break; // Exit loop after transforming
                         }
                     }
                 }
             }
            
 // Handle Steam Physics
 if (cell.element === 'steam') {
     cell.age++;
 
     // Check if there's a material above
     const aboveCell = grid[row - 1] && grid[row - 1][col];
     
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (aboveCell && aboveCell.element === 'empty') {
         directions.push({ row: -1, col: 0 }); // Up
     }
 
     // Randomly choose a direction (horizontal or up if possible)
     const randomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + randomDirection.row;
     const newCol = col + randomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'steam';
         grid[newRow][newCol].age = cell.age;
         cell.element = 'empty';
     }
 
     // Steam dissipates after 2 minutes (approximately 2400 frames)
     if (cell.age >= 2000) {
         if (Math.random() < 0.003) { // Adjust the probability as needed (0.01 = 1%)
                     cell.element = 'water'; // Change steam to water
                     continue; // Skip further processing for this cell
                 }
        else{ cell.element = 'empty';}
     }
 }
        
 // Handle Steam Physics
 if (elements[grid[row][col].element].type === 'balloon') {
     cell.age++;
 
     // Check if there's a material above
     const aboveCell = grid[row - 1] && grid[row - 1][col];
     
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (aboveCell && aboveCell.element === 'empty') {
         directions.push({ row: -1, col: 0 }); // Up
     }
 
     // Randomly choose a direction (horizontal or up if possible)
     const randomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + randomDirection.row;
     const newCol = col + randomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol] = structuredClone(grid[row][col]);
         initializeCell(row, col, 'empty');
       
     }
 
    
     
 }

 if(cell.element === 'frog' && row < rows - 1){
    cell.delay++;
   if(grid[row+1][col].element === 'empty'){
            if(cell.delay > 0){
            grid[row+1][col].element = 'frog';

            
            grid[row][col].element = 'empty';
            cell.delay=0;
            }
   }
        
 }
       if(cell.element === 'frog'){
   
        if(row < rows - 1){
            if(grid[row+1][col].element !== 'empty'){
            if(Math.random() < 0.01) frogjump(cell, row, col);
            }
        } else if(Math.random() < 0.01) frogjump(cell, row, col);
   
       }    
 // Handle Steam Physics
 if (cell.element === 'oxygen') {
     cell.age++;
 
     // Check if there's a material above
     const aboveCell = grid[row - 1] && grid[row - 1][col];
     
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (aboveCell && aboveCell.element === 'empty') {
         directions.push({ row: -1, col: 0 }); // Up
     }
 
     // Randomly choose a direction (horizontal or up if possible)
     const randomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + randomDirection.row;
     const newCol = col + randomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'oxygen';
         grid[newRow][newCol].age = cell.age;
         initializeCell(row, col, 'empty');
     }
 
     // Steam dissipates after 2 minutes (approximately 2400 frames)
     if (cell.age >= 2000) {
        initializeCell(row, col, 'empty');
     }
 }

 // Handle Steam Physics
 if (cell.element === 'hydrogen') {
     cell.age++;
 
     // Check if there's a material above
     const aboveCell = grid[row - 1] && grid[row - 1][col];
     
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (aboveCell && aboveCell.element === 'empty') {
         directions.push({ row: -1, col: 0 }); // Up
     }
 
     // Randomly choose a direction (horizontal or up if possible)
     const randomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + randomDirection.row;
     const newCol = col + randomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'hydrogen';
         grid[newRow][newCol].age = cell.age;
         initializeCell(row, col, 'empty');
     }
 
     // Steam dissipates after 2 minutes (approximately 2400 frames)
     if (cell.age >= 2000) {
         cell.element = 'empty';
     }
 }

 
 if(cell.element==='human' && row < rows - 1){
    if(grid[row+1][col].element==='empty'){
        grid[row+1][col].element='human';
        cell.element='humantop';
        cell.delay=0;
    }
 } 
 if(cell.element==='zombie' && row < rows - 1){
    if(grid[row+1][col].element==='empty'){
        grid[row+1][col].element='zombie';
        cell.element='zombietop';
        cell.delay=0;
    }
 } 
 if (cell.element === 'human' && row > 0) {
    cell.delay = (cell.delay || 0) + 1;
    cell.fear = (cell.fear || 0); // Initialize fear level

    const moveDelay = 2; // Normal movement delay
    const detectionRange = 4; // How far humans detect danger
    const fearDecay = 0.6; // How quickly fear reduces when safe
    const maxFear = 10; // Maximum fear level (low = calm, high = scared)

    let directions = [];
    if (col > 0 && grid[row-1][col - 1].element === 'empty') directions.push([-1, 0]); // Left
    if (col < cols - 1 && grid[row-1][col + 1].element === 'empty') directions.push([1, 0]); // Right
    if (row > 0 && grid[row - 1][col].element === 'empty') directions.push([0, -1]); // Up
    if (row < rows - 1 && grid[row + 1][col].element === 'empty') directions.push([0, 1]); // Down

    let moveDirection = null;
    let safeDirections = [];
    let unsafeNearby = false;

    // **Check for unsafe elements within detectionRange**
    for (let dy = -detectionRange; dy <= detectionRange; dy++) {
        for (let dx = -detectionRange; dx <= detectionRange; dx++) {
            let checkRow = row + dy;
            let checkCol = col + dx;
            if (checkRow >= 0 && checkRow < rows && checkCol >= 0 && checkCol < cols) {
                let nearbyCell = grid[checkRow][checkCol];
                if (nearbyCell.element !== 'empty' && elements[nearbyCell.element]?.unsafe) {
                    unsafeNearby = true;
                }
            }
        }
    }

    // **Increase fear level if unsafe elements detected**
    if (unsafeNearby) {
        cell.fear = Math.min(maxFear, cell.fear + 2); // Increase fear but cap it

        for (let [dx, dy] of directions) {
            let newRow = row + dy;
            let newCol = col + dx;

            let isSafe = true;
            // Check if the new position is away from unsafe elements
            for (let y = -1; y <= 1; y++) {
                for (let x = -1; x <= 1; x++) {
                    let checkRow = newRow + y;
                    let checkCol = newCol + x;
                    if (checkRow >= 1 && checkRow < rows - 1 && checkCol >= 1 && checkCol < cols - 1) {
                        let nearbyCell = grid[checkRow][checkCol];
                        if (nearbyCell.element !== 'empty' && elements[nearbyCell.element]?.unsafe) {
                            isSafe = false;
                            break;
                        }
                    }
                }
            }

            if (isSafe) {
                safeDirections.push([dx, dy]);
            }
        }

        if (safeDirections.length > 0) {
            moveDirection = safeDirections[Math.floor(Math.random() * safeDirections.length)];
        }
    }
    // **If no danger, gradually reduce fear**
    else {
        cell.fear = Math.max(0, cell.fear - fearDecay); // Slowly return to calm
    }

    // **Modify movement delay based on fear level**
    let adjustedMoveDelay = Math.max(1, moveDelay - Math.floor(cell.fear / 2));

    // **If no danger and delay is met, move randomly**
    if (!unsafeNearby && cell.delay >= adjustedMoveDelay) {
        if(Math.random() < 0.05){
        if (directions.length > 0) {
            moveDirection = directions[Math.floor(Math.random() * directions.length)];
            
        }
        cell.delay = 0; // Reset delay after moving
    }
    }

    // **Move human if a valid direction was found**
    if (moveDirection) {
        let [dx, dy] = moveDirection;
        let newRow = row + dy;
        let newCol = col + dx;
        if(grid[newRow][newCol].element === 'empty'){
        grid[newRow][newCol].element = 'human';
        grid[newRow-1][newCol].element = 'humantop';
        cell.element = 'empty';
        } else { grid[newRow-1][newCol].element = 'human';
        grid[newRow-2][newCol].element = 'humantop';
        cell.element = 'empty';
    }
    }
}
 if(cell.element === 'rat'){
    cell.delay++;
    if(row < rows - 1 && grid[row+1][col].element === 'empty'){
    grid[row+1][col] = structuredClone(grid[row][col]);
    initializeCell(row, col, 'empty');
    } else {
        let left = col > 0 && grid[row][col - 1].element === 'empty';
        let right = col < cols - 1 && grid[row][col + 1].element === 'empty';
    
 
       
   let newCol = Math.random() < 0.5 ? col - 1 : col + 1;
   if(cell.delay > 3){
            if(newCol > 0 && newCol < cols - 1){
                if(grid[row][newCol].element === 'empty'){
                    grid[row][newCol] = structuredClone(grid[row][col], ['delay']);
                    initializeCell(row, col, 'empty');
                } else{
                   
                        newRow = row - 1
                    if(newRow > 0 && newRow < rows - 1){
                        if(grid[newRow][newCol].element === 'empty'){
                            grid[newRow][newCol] = structuredClone(grid[row][col],  ['delay']);
                            initializeCell(row, col, 'empty');
                        }
                    }
                }
            }
        }
        
    }
}


if (cell.element === 'zombie' && row > 0) {
    cell.delay = (cell.delay || 0) + 1;
  

    const moveDelay = 2; // Normal movement delay
    const detectionRange = 10; // How far humans detect danger
  

    let directions = [];
    if (col > 0 && grid[row-1][col - 1].element === 'empty') directions.push([-1, 0]); // Left
    if (col < cols - 1 && grid[row-1][col + 1].element === 'empty') directions.push([1, 0]); // Right
    if (row > 0 && grid[row - 1][col].element === 'empty') directions.push([0, -1]); // Up
    if (row < rows - 1 && grid[row + 1][col].element === 'empty') directions.push([0, 1]); // Down

    let moveDirection = null;
    let safeDirections = [];
    let unsafeNearby = false;

    // **Check for unsafe elements within detectionRange**
    for (let dy = -detectionRange; dy <= detectionRange; dy++) {
        for (let dx = -detectionRange; dx <= detectionRange; dx++) {
            let checkRow = row + dy;
            let checkCol = col + dx;
            if (checkRow >= 0 && checkRow < rows && checkCol >= 0 && checkCol < cols) {
                let nearbyCell = grid[checkRow][checkCol];
                if (nearbyCell.element !== 'empty' && elements[nearbyCell.element]?.element === 'human') {
                    unsafeNearby = true;
                }
            }
        }
    }

    // **Increase fear level if unsafe elements detected**
    if (unsafeNearby) {
     

        for (let [dx, dy] of directions) {
            let newRow = row + dy;
            let newCol = col + dx;

            let isSafe = true;
            // Check if the new position is away from unsafe elements
            for (let y = -1; y <= 1; y++) {
                for (let x = -1; x <= 1; x++) {
                    let checkRow = newRow + y;
                    let checkCol = newCol + x;
                    if (checkRow >= 0 && checkRow < rows && checkCol >= 0 && checkCol < cols) {
                        let nearbyCell = grid[checkRow][checkCol];
                        if (nearbyCell.element !== 'empty' && elements[nearbyCell.element]?.element === 'human') {
                            isSafe = false;
                            break;
                        }
                    }
                }
            }

            if (isSafe) {
                safeDirections.push([dx, dy]);
            }
        }

        if (safeDirections.length > 0) {
            moveDirection = safeDirections[Math.floor(Math.random() * safeDirections.length * -1)];
        }
    }
   

 
    // **If no danger and delay is met, move randomly**
    if (!unsafeNearby && cell.delay >= moveDelay) {
        if(Math.random() < 0.05){
        if (directions.length > 0) {
            moveDirection = directions[Math.floor(Math.random() * directions.length)];
            
        }
        cell.delay = 0; // Reset delay after moving
    }
    }

    // **Move human if a valid direction was found**
    if (moveDirection) {
        let [dx, dy] = moveDirection;
        let newRow = row + dy;
        let newCol = col + dx;
        if(grid[newRow][newCol].element === 'empty'){
        grid[newRow][newCol].element = 'zombie';
        grid[newRow-1][newCol].element = 'zombietop';
        cell.element = 'empty';
        } else { grid[newRow-1][newCol].element = 'zombie';
        grid[newRow-2][newCol].element = 'zombietop';
        cell.element = 'empty';
    }
    }
}



 if(cell.element==='humantop' && row < rows - 1){
    if(grid[row+1][col].element !== 'human'){
        cell.element='empty';
        
    }
 }

 if(cell.element==='zombietop' && row < rows -1){
    if(grid[row+1][col].element !== 'zombie'){
        cell.element='empty';
        
    }
 }
 if(cell.element==='human' && row > 0){
    if(grid[row-1][col].element==='empty'){
        grid[row-1][col].element='humantop';
        
    }
 }
 if(cell.element==='zombie' && row > 0){
    if(grid[row-1][col].element==='empty'){
        grid[row-1][col].element='zombietop';
        
    }
 }
             if (cell.element === 'pig') {
                 handlepigMovement(cell, row, col);
 
             }
             
 // Handle Steam Physics
 if (cell.element === 'snow' && row < rows - 1) {
     cell.age++;
     cell.delay++;
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'empty') {
         directions.push({ row: +1, col: 0 }); // Up
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const srandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + srandomDirection.row;
     const newCol = col + srandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'snow';
         grid[newRow][newCol].age = cell.age;
         
         cell.element = 'empty';
     }
     }
   
 }    
 // Handle Steam Physics
 if (cell.element === 'snow2' && row < rows - 1) {
     
     cell.delay++;
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'empty') {
         directions.push({ row: +1, col: 0 }); // Up
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const srandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + srandomDirection.row;
     const newCol = col + srandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'snow2';
         grid[newRow][newCol].age = cell.age;
         
         cell.element = 'empty';
     }
     }
   
 }     
 if(cell.element === 'snow2'){
    cell.age++;
    if(cell.age>20){
        if(Math.random() < 0.004){
        cell.element = 'empty';
        }
    }
 }
 if (cell.element === 'pollen' && row < rows - 1) {
     cell.age++;
     cell.delay++;
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'empty') {
         directions.push({ row: +1, col: 0 }); // Up
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const prandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + prandomDirection.row;
     const newCol = col + prandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'pollen';
         grid[newRow][newCol].age = cell.age;
         
         cell.element = 'empty';
     }
     }
   
 }  
 if (cell.element === 'dust' && row < rows - 1) {
     
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'empty') {
         directions.push({ row: -1, col: 0 }); // Up
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const prandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + prandomDirection.row;
     const newCol = col + prandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'dust';
         grid[newRow][newCol].age = cell.age;
         
         cell.element = 'empty';
     }
     }
   
 } 

  
       
 if (elements[grid[row][col].element].type === 'cf' && row < rows - 1) {
     
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'empty') {
         directions.push({ row: +1, col: 0 }); // Up
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const prandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + prandomDirection.row;
     const newCol = col + prandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = cell.element;
         grid[newRow][newCol].age = cell.age;
         
         cell.element = 'empty';
     }
     }
   
 }    
 if (elements[grid[row][col].element].type === 'fp' && row < rows - 1) {
     
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
    if(cell.fpmove){
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'empty') {
         directions.push({ row: +1, col: 0 }); // Up
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const prandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + prandomDirection.row;
     const newCol = col + prandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = cell.element;
         grid[newRow][newCol].age = cell.age;
         
         cell.element = 'empty';
     }
     }
    }
    } 
 if (cell.element === 'feather' && row < rows - 1) {
    
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'empty') {
         directions.push({ row: +1, col: 0 }); // Up
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const prandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + prandomDirection.row;
     const newCol = col + prandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
        if(Math.random() < 0.3){
         grid[newRow][newCol].element = 'feather';
         grid[newRow][newCol].age = cell.age;
         
         cell.element = 'empty';
        }
     }
     }
   
 }     
 if(cell.element==='foam'){
    cell.age++;
    if(cell.age>= 20){
        if(Math.random() < 0.01){
            cell.element='empty';
        }
    }
 }
 if (cell.element === 'foam' && row < rows - 1) {
     
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'foamo') {
         directions.push({ row: +1, col: 0 }); // Up
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const prandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + prandomDirection.row;
     const newCol = col + prandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'foamo') {
         grid[newRow][newCol].element = 'foam';
         grid[newRow][newCol].age = cell.age;
         cell.age=0;
         cell.delay=0;
         
         cell.element = 'empty';
     }
     }
   
 } 
 
 
 if(cell.element === 'bee' && row < rows -1 ){
    if(grid[row+1][col].element === 'empty'){
        if(Math.random() < 0.01){
            grid[row+1][col].element='pollen';
        }
    }
 }
 if (cell.element === 'blackhole') {
     
     for (let r = -blackHoleRadius; r <= blackHoleRadius; r++) {
         for (let c = -blackHoleRadius; c <= blackHoleRadius; c++) {
             const targetRow = row + r;
             const targetCol = col + c;
             const distance = Math.sqrt(r * r + c * c); // Calculate distance from the black hole

             // Check if the target cell is within bounds and not the black hole itself
             if (grid[targetRow] && grid[targetRow][targetCol] && (targetRow !== row || targetCol !== col)) {
                 // If the distance is within the radius of influence
                 if (distance <= blackHoleRadius) {
                     const targetElement = grid[targetRow][targetCol];

                     // Move the target cell towards the black hole gradually
                     if (targetElement.element !== 'empty'&& targetElement.element !== 'blackhole' && elements[targetElement.element].type !== 'unbreakable') {
                         // Calculate the direction vector toward the black hole
                         const dx = (row - targetRow) * pullSpeed;
                         const dy = (col - targetCol) * pullSpeed;

                         // Calculate new position
                         const newRow = targetRow + (dx > 0 ? Math.ceil(dx) : Math.floor(dx));
                         const newCol = targetCol + (dy > 0 ? Math.ceil(dy) : Math.floor(dy));

                         // Check if the new position is valid and empty
                         if (grid[newRow] && grid[newRow][newCol].element === 'empty') {
                             // Move the element to the new position
                             grid[newRow][newCol].element = targetElement.element; // Move the element
                             targetElement.element = 'empty'; // Set the original cell to empty
                             }
                         
                     }
                 }
             }
         }
     }

 }
 
 





             if(cell.element==='hm'){
                if(row > rows -2){
                    cell.element='Explosion';
                }
             }
             if(cell.element==='hm'){
                if(col > cols -2){
                    cell.element='Explosion';
                }
             }
             if (cell.element === 'hm') {
                
    // Check if hmrow and hmcol are globally defined
    if (typeof hmrow !== "undefined" && typeof hmcol !== "undefined") {
        // Calculate the direction vector toward the global target
        const dx = hmrow - row;
        const dy = hmcol - col;

        // Normalize the direction vector
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > 0) {
            const stepRow = Math.round(dx / distance); // Move one step toward the target row
            const stepCol = Math.round(dy / distance); // Move one step toward the target col

            const newRow = row + stepRow;
            const newCol = col + stepCol;
            if(newRow < rows - 1 && newRow > 0 && newCol > 0 && newCol < cols - 1){
            // Check if the new position is valid and empty
            if (grid[newRow] && grid[newRow][newCol].element === 'empty' || grid[newRow][newCol].element === 'hmb') {
                cell.delay++;
                if(cell.delay >=2){
                // Move the homing missile to the new position
                grid[newRow][newCol].element = 'hm';
                cell.delay=0;
                // Clear the current position
                cell.element = 'hmb';
                } 

            } else if(grid[newRow][newCol].element !== 'hm') cell.element='Explosion';
        } else cell.element='Explosion';
    }
    }

}
if(elements[grid[row][col].element].type === 'ushape'){
    cell.delay++;
    if(cell.delay > 2){
        cell.element = 'empty';
    }

}


if (cell.element === 'cursor' ) {
   
                // Check if hmrow and hmcol are globally defined
                if (typeof hmrow !== "undefined" && typeof hmcol !== "undefined") {
                    // Calculate the direction vector toward the global target
                    const dx = hmrow - row;
                    const dy = hmcol - col;
            
                    // Normalize the direction vector
                    const distance = Math.sqrt(dx * dx + dy * dy);
            
                    if (distance > 0) {
                        const stepRow = Math.round(dx / distance); // Move one step toward the target row
                        const stepCol = Math.round(dy / distance); // Move one step toward the target col
            
                        const newRow = row + stepRow;
                        const newCol = col + stepCol;
                     
                        // Check if the new position is valid and empty
                        if(newRow < rows - 1 && newRow > 0 && newCol > 0 && newCol < cols - 1){
                        if (grid[newRow] && grid[newRow][newCol].element === 'empty' || grid[newRow][newCol].element === 'cursorb') {
                            
                            cell.delay++;
                            if(cell.delay >=2){
                            // Move the homing missile to the new position
                            grid[newRow][newCol].element = 'cursor';
                            cell.delay=0;
                            cell.element='empty';
                            
                            } 
            
                        } else{
                            grid[newRow][newCol].lage++;
                            if(grid[newRow][newCol].lage > 3){
                                grid[newRow][newCol].lage = 0;
                                grid[newRow][newCol].element = 'empty';
                            }
                        }
                    }
                    }
                }
            }
            if(cell.grab===true){
                cell.grabage++;
                if(cell.grabage>15){
                    cell.grab=false;
                    cell.grabage=0;
                }
            }
           
            if(cell.push === true){
                cell.pushage++;
                if(cell.pushage>15){
                    cell.push=false;
                    cell.pushage=0;
                }
            }
            if(cell.grab === true) {
   
   // Check if hmrow and hmcol are globally defined
   if (typeof hmrow !== "undefined" && typeof hmcol !== "undefined") {
       // Calculate the direction vector toward the global target
       const dx = hmrow - row;
       const dy = hmcol - col;

       // Normalize the direction vector
       const distance = Math.sqrt(dx * dx + dy * dy);

       if (distance > 0) {
           const stepRow = Math.round(dx / distance); // Move one step toward the target row
           const stepCol = Math.round(dy / distance); // Move one step toward the target col

           const newRow = row + stepRow;
           const newCol = col + stepCol;
        
           // Check if the new position is valid and empty
           if(newRow < rows - 1 && newRow > 0 && newCol > 0 && newCol < cols - 1){
           if (grid[newRow] && grid[newRow][newCol].element === 'empty') {
               
               cell.grabdelay++;
               if(cell.grabdelay >=2){
               // Move the homing missile to the new position
               grid[newRow][newCol].element = cell.element;
               
               cell.delay=0;
               cell.grabdelay=0;
               cell.grab = false;
               grid[newRow][newCol].grab = true;
               cell.element='empty';
               grid[newRow][newCol].grabage = cell.grabage;
               cell.grabage = 0;
               
               } 

           }
       }
       }
   }
}

if (cell.push === true) {
   
   // Check if hmrow and hmcol are globally defined
   if (typeof hmrow !== "undefined" && typeof hmcol !== "undefined") {
       // Calculate the direction vector toward the global target
       const dx = hmrow - row;
       const dy = hmcol - col;

       // Normalize the direction vector
       const distance = Math.sqrt(dx * dx + dy * dy);

       if (distance > 0) {
           const stepRow = Math.round(dx / distance); // Move one step toward the target row
           const stepCol = Math.round(dy / distance); // Move one step toward the target col

           const newRow = row - stepRow;
           const newCol = col - stepCol;
        
           // Check if the new position is valid and empty
           if(newRow < rows - 1 && newRow > 0 && newCol > 0 && newCol < cols - 1){
           if (grid[newRow] && grid[newRow][newCol].element === 'empty') {
               
               cell.pushdelay++;
               if(cell.pushdelay >=2){
               // Move the homing missile to the new position
               grid[newRow][newCol].element = cell.element;
               
               cell.delay=0;
               cell.pushdelay=0;
               cell.push = false;
               grid[newRow][newCol].push = true;
               cell.element='empty';
               grid[newRow][newCol].pushage = cell.pushage;
               cell.pushage = 0;
               
               } 

           }
       }
       }
   }
}





            
             if (cell.element === 'star') {
     
     for (let r = -starRadius; r <= starRadius; r++) {
         for (let c = -starRadius; c <= starRadius; c++) {
             const targetRow = row + r;
             const targetCol = col + c;
             const distance = Math.sqrt(r * r + c * c); // Calculate distance from the black hole

             // Check if the target cell is within bounds and not the black hole itself
             if (grid[targetRow] && grid[targetRow][targetCol] && (targetRow !== row || targetCol !== col)) {
                 // If the distance is within the radius of influence
                 if (distance <= starRadius) {
                     const targetElement = grid[targetRow][targetCol];

                     // Move the target cell towards the black hole gradually
                     if (targetElement.element !== 'empty'&& targetElement.element !== 'star' && targetElement.element !== 'fire' && targetElement.element !== 'smoke') {
                         // Calculate the direction vector toward the black hole
                         const dx = (row - targetRow) * starpullSpeed;
                         const dy = (col - targetCol) * starpullSpeed;

                         // Calculate new position
                         const newRow = targetRow + (dx > 0 ? Math.ceil(dx) : Math.floor(dx));
                         const newCol = targetCol + (dy > 0 ? Math.ceil(dy) : Math.floor(dy));

                         // Check if the new position is valid and empty
                         if (grid[newRow] && grid[newRow][newCol].element === 'empty') {
                             // Move the element to the new position
                             grid[newRow][newCol].element = targetElement.element; // Move the element
                             targetElement.element = 'empty'; // Set the original cell to empty
                             }
                         
                     }
                 }
             }
         }
     }

 }
 

 // Handle Steam Physics
 if (cell.element === 'ash' && row < rows - 1) {
     cell.age++;
     cell.delay++;
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'empty') {
         directions.push({ row: +1, col: 0 }); // Up
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const arandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + arandomDirection.row;
     const newCol = col + arandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'ash';
         grid[newRow][newCol].age = cell.age;
         
         cell.element = 'empty';
     }
     }
   
 }
 
   
 if (cell.element === 'fly' && row < rows - 1) {
     cell.age++;
     cell.delay++;
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 },   // Right
         {row:1, col: 0},
         {row: -1, col: 0}
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'empty') {
        
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const frandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + frandomDirection.row;
     const newCol = col + frandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if(cell.delay>=10){
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'fly';
         grid[newRow][newCol].age = cell.age;
         cell.delay=0;
         cell.element = 'empty';
     }
     }
 }
   
 } 
 if (cell.sound === true && row < rows - 1 && row > 1 && col > 0 && col < cols - 1) {
     
 cell.soage++;
 cell.sodelay++;
 if(cell.soage > 5){
    if(Math.random() < 0.3){
    cell.sound=false;
    }
 }
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }
     ];
 
    
        
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const frandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + frandomDirection.row;
     const newCol = col + frandomDirection.col;
    
  
        if(Math.random() < 0.5){
    
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = cell.element;
         grid[newRow][newCol].age = cell.age;
         grid[newRow][newCol].sound  = true;
         cell.sound = false;
        cell.sodelay = 0;
        grid[newRow][newCol].soage = cell.soage;
        cell.soage= 0;
         cell.element = 'empty';
     }
     
    
}
   
 } 

 if (cell.element === 'bee' && row < rows - 1) {
     
     cell.delay++;
 
     // Check if there's a material above
   
     
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 },   // Right
         {row:1, col: 0},
         {row: -1, col: 0}
     ];
 
   
        
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const frandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + frandomDirection.row;
     const newCol = col + frandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if(cell.delay>=1){
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'bee';
         grid[newRow][newCol].age = cell.age;
         cell.delay=0;
         cell.element = 'empty';
     }
     }
 
   
 }  
 if (cell.element === 'bird' && row < rows - 1) {
     
     cell.delay++;
 
     // Check if there's a material above
   
     
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }
     ];
 
   
        
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const frandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + frandomDirection.row;
     const newCol = col + frandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if(cell.delay>=1){
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'bird';
         grid[newRow][newCol].age = cell.age;
         cell.delay=0;
         cell.element = 'empty';
     }
     }
 
   
 }   
 
 
 if (cell.element === 'nanobug' && row < rows - 1) {
    
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 },   // Right
         {row:1, col: 0},
         {row: -1, col: 0}
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element) {
        
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const frandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + frandomDirection.row;
     const newCol = col + frandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element) {
         grid[newRow][newCol].element = 'nanobug';
         grid[newRow][newCol].age = cell.age;
         cell.delay=0;
         cell.element='empty';
     }
     
 }
   
 }    
 
 if (cell.element === 'firefly' && row < rows - 1) {
    
     cell.delay++;
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 },   // Right
         {row:1, col: 0},
         {row: -1, col: 0}
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'empty' || belowCell.element === 'fireflyb') {
        
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const frandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + frandomDirection.row;
     const newCol = col + frandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if(cell.delay>=10){
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty' || grid[newRow][newCol].element === 'fireflyb') {
         grid[newRow][newCol].element = 'firefly';
         grid[newRow][newCol].age = cell.age;
         cell.delay=0;
         cell.element = 'fireflyb';
     }
     }
 }
   
 }    
 
   
 
 if (cell.element === 'shock' && row < rows - 1) {
     
     cell.delay++;
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     const directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 },   // Right
         {row:1, col: 0},
         {row: -1, col: 0}
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'empty') {
        
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const frandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + frandomDirection.row;
     const newCol = col + frandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if(cell.delay>=3){
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'shock';
         grid[newRow][newCol].age = cell.age;
         cell.delay=0;
         
     }
     }
 }
   
 }

 if (cell.element === 'root' && row < rows - 1) {
     
     cell.delay++;
 
     // Check if there's a material above
   
    
     // Horizontal movement directions (left and right)
     const directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 },   // Right
         {row:1, col: 0},
         {row: -1, col: 0}
     ];
 
     // If the cell above is empty, add upward movement as an option
    
        
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const frandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + frandomDirection.row;
     const newCol = col + frandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if(cell.delay>10 && cell.delay<14){
        if(Math.random() < 0.5){
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'dirt') {
         grid[newRow][newCol].element = 'root';
         grid[newRow][newCol].age = cell.age;
       
         
     
    }
     }
 }
   
 }
 if (cell.element === 'bubble' && row < rows - 1) {
     
     cell.delay++;
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     const directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 },   // Right
         {row:1, col: 0},
         {row: -1, col: 0}
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'bubbleo') {
        
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const frandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + frandomDirection.row;
     const newCol = col + frandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if(cell.delay>=5){
        if(Math.random()< 0.5){
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'bubbleo') {
         grid[newRow][newCol].element = 'bubble';
         cell.element='empty';
        
         cell.delay=0;
         cell.age=0;
         
     }
    }
     }
 }
   
 }
 
 
 if (cell.element === 'radiation' && row < rows - 1) {
     
     cell.delay++;
 
     // Check if there's a material above
   
     const belowCell = grid[row + 1] && grid[row + 1][col];  
     // Horizontal movement directions (left and right)
     const directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 },   // Right
         {row:1, col: 0},
         {row: -1, col: 0}
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (belowCell && belowCell.element === 'ratiationo') {
        
        
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const frandomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + frandomDirection.row;
     const newCol = col + frandomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if(cell.delay>=5){
        if(Math.random()< 0.5){
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'radiationo') {
         grid[newRow][newCol].element = 'radiation';
         cell.element='empty';
        
         cell.delay=0;
         cell.age=0;
         
     }
    }
     }
 }
   
 }

 if (cell.element === 'wetsponge') {
     cell.age++;
                        if (!cell.delay) cell.delay = 0; // Initialize delay counter if undefined
                        const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
 
 
                        let SAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
 
 
               if(cell.age===1){
                        adjacentCells.forEach(({ row: r, col: c }) => {
         if (grid[r] && grid[r][c] && elements[grid[r][c].element].water) {
           cell.element='wetsponge'; 
             return grid[r][c].element = 'empty'; grid[r][c].age = 0;
            
             
         }
     });
 }
 }
  // Handle lava physics with delay
  if (cell.element === 'sponge') {
                        if (!cell.delay) cell.delay = 0; // Initialize delay counter if undefined
                        const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
 
 
                        let SAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                        adjacentCells.forEach(({ row: r, col: c }) => {
         if (grid[r] && grid[r][c] && elements[grid[r][c].element].water) {
           cell.element='wetsponge'; 
             return grid[r][c].element = 'empty'; grid[r][c].age = 0;
            
             
         }
     });
 }
                    // Handle lava physics with delay
                    if (cell.element === 'lava') {
                        if (!cell.delay) cell.delay = 0; // Initialize delay counter if undefined
                        const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
 
 
                        let waterAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
 
 
 
 
 
 
 
 
 
 
 
 
 
                        if (waterAdjacent) {
                            grid[row][col].element = 'stone'; // Turn lava into stone
                          
                        }
 
 
 
 
 
 
                        adjacentCells.forEach(({ row: r, col: c }) => {
         if (grid[r] && grid[r][c] && elements[grid[r][c].element].flammable) {
             grid[r][c].element = 'fire'; // Ignite flammable material
             grid[r][c].age = 0; // Initialize fire's age
         }
     });
 
                      
                    }
 
                    // Handle lava physics with delay
                    if (cell.element === 'moltensand') {
                        cell.age++
                        if (cell.age > 500) {
                            cell.element = 'glass';
                        }
                        if (!cell.delay) cell.delay = 0; // Initialize delay counter if undefined
                        const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
 
 
                        let waterAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                        if (waterAdjacent) {
                            grid[row][col].element = 'glass'; // Turn lava into stone
                          
                        }
 
 
 
 
 
 
 
 
                       
                    }
                  
                    if (cell.element === 'human') {
                       
                       
                        // Define adjacent cells (up, down, left, right, diagonals)
                        const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            }, // Right
                            {
                                row: row - 1,
                                col: col - 1
                            }, // Up-Left (Diagonal)
                            {
                                row: row - 1,
                                col: col + 1
                            }, // Up-Right (Diagonal)
                            {
                                row: row + 1,
                                col: col - 1
                            }, // Down-Left (Diagonal)
                            {
                                row: row + 1,
                                col: col + 1
                            } // Down-Right (Diagonal)
                        ];
 
 
 
 
                
 
 
 
                        // Check for adjacent fire cells
                        let mAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'magma'
                        );
 
 
 
 
 
 
 
 
                        // Ignite oil if adjacent to fire, then skip movement logic
                        if (mAdjacent) {
                         cell.age++;
                         if(cell.age>=10){
                            cell.element = 'ash';
                            cell.age = 0; // Reset age when transformed to fire
                         }
                        }
 
 
                     }
                     if(cell.element==='liquidN'){
                        cell.age++;
                          // Handle smoke and transformation logic as before...
                          if (row > 0 && grid[row - 1][col].element === 'empty') {
                            if (cell.age >= 50) {
                                
                                grid[row - 1][col].element = 'steam';
                                cell.age=0; 
                            }
                        }
                     }
                     if(cell.element==='chlorine'){
                        cell.age++;
                          // Handle smoke and transformation logic as before...
                          if (row > 0 && grid[row - 1][col].element === 'empty') {
                            if (cell.age >= 50) {
                                
                                grid[row - 1][col].element = 'chlorinegas';
                                cell.age=0; 
                            }
                        }
                     }
                     if(cell.element==='bromine'){
                        cell.age++;
                          // Handle smoke and transformation logic as before...
                          if (row > 0 && grid[row - 1][col].element === 'empty') {
                            if (cell.age >= 30) {
                                
                                grid[row - 1][col].element = 'brominegas';
                                cell.age=0; 
                            }
                        }
                     }
                    if (cell.element === 'oil') {
                        cell.age++;
                       
                        // Define adjacent cells (up, down, left, right, diagonals)
                        const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            }, // Right
                            {
                                row: row - 1,
                                col: col - 1
                            }, // Up-Left (Diagonal)
                            {
                                row: row - 1,
                                col: col + 1
                            }, // Up-Right (Diagonal)
                            {
                                row: row + 1,
                                col: col - 1
                            }, // Down-Left (Diagonal)
                            {
                                row: row + 1,
                                col: col + 1
                            } // Down-Right (Diagonal)
                        ];
 
 
 
 
                
 
 
 
                        // Check for adjacent fire cells
                        let fireAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'fire'
                        );
 
 
 
 
 
 
 
 
                        // Ignite oil if adjacent to fire, then skip movement logic
                        if (fireAdjacent) {
                            cell.element = 'fire';
                            cell.age = 0; // Reset age when transformed to fire
                            
                        }
 
 
 
 
 
 
                       
                    }
                   
 
 
                   // Handle Steam Physics
 if (cell.element === 'smoke') {
     cell.age++;
 
     // Check if there's a material above
     const aboveCell = grid[row - 1] && grid[row - 1][col];
     
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (aboveCell && aboveCell.element === 'empty') {
         directions.push({ row: -1, col: 0 }); // Up
     }
 
     // Randomly choose a direction (horizontal or up if possible)
     const randomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + randomDirection.row;
     const newCol = col + randomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'smoke';
         grid[newRow][newCol].age = cell.age;
         cell.element = 'empty';
     }
 
     // Steam dissipates after 2 minutes (approximately 2400 frames)
     if (cell.age >= 400) {
         cell.element = 'empty';
     }
 }
   // Handle Steam Physics
   if (cell.element === 'chlorinegas') {
     cell.age++;
 
     // Check if there's a material above
     const aboveCell = grid[row - 1] && grid[row - 1][col];
     
     // Horizontal movement directions (left and right)
     const directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (aboveCell && aboveCell.element === 'empty') {
         directions.push({ row: -1, col: 0 }); // Up
     }
 
     // Randomly choose a direction (horizontal or up if possible)
     const randomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + randomDirection.row;
     const newCol = col + randomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'chlorinegas';
         grid[newRow][newCol].age = cell.age;
         cell.element = 'empty';
     }
 
     // Steam dissipates after 2 minutes (approximately 2400 frames)
     if (cell.age >= 400) {
         cell.element = 'empty';
     }
 }



  // Handle Steam Physics
  if (cell.element === 'brominegas') {
     cell.age++;
 
     // Check if there's a material above
     const aboveCell = grid[row - 1] && grid[row - 1][col];
     
     // Horizontal movement directions (left and right)
     const directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     if (aboveCell && aboveCell.element === 'empty') {
         directions.push({ row: -1, col: 0 }); // Up
     }
 
     // Randomly choose a direction (horizontal or up if possible)
     const randomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + randomDirection.row;
     const newCol = col + randomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         grid[newRow][newCol].element = 'brominegas';
         grid[newRow][newCol].age = cell.age;
         cell.element = 'empty';
     }
 
     // Steam dissipates after 2 minutes (approximately 2400 frames)
     if (cell.age >= 400) {
         cell.element = 'empty';
     }
 }
  // Handle Steam Physics
  if (cell.element === 'fog') {
     cell.age++;
     cell.delay++;
     // Check if there's a material above
    
     
     // Horizontal movement directions (left and right)
     let directions = [
         { row: 0, col: -1 }, // Left
         { row: 0, col: 1 }   // Right
     ];
 
     // If the cell above is empty, add upward movement as an option
     
 
     // Randomly choose a direction (horizontal or up if possible)
     const randomDirection = directions[Math.floor(Math.random() * directions.length)];
     const newRow = row + randomDirection.row;
     const newCol = col + randomDirection.col;
 
     // Check if the target cell is empty before moving the steam
     if(cell.delay>=40){
     if (grid[newRow] && grid[newRow][newCol] && grid[newRow][newCol].element === 'empty') {
         
         grid[newRow][newCol].element = 'fog';
         grid[newRow][newCol].age = cell.age;
         cell.element = 'empty';
         cell.delay=0;
     }
     }
     // Steam dissipates after 2 minutes (approximately 2400 frames)
     if (cell.age >= 700) {
         cell.element = 'empty';
     }
 }
 
                    // Handle fire physics
                    const directions = [{
                            row: -1,
                            col: 0
                        }, // Up
                        {
                            row: 1,
                            col: 0
                        }, // Down
                        {
                            row: 0,
                            col: -1
                        }, // Left
                        {
                            row: 0,
                            col: 1
                        }, // Right
                        {
                            row: -1,
                            col: -1
                        }, // Up-Left (Diagonal)
                        {
                            row: -1,
                            col: 1
                        }, // Up-Right (Diagonal)
                        {
                            row: 1,
                            col: -1
                        }, // Down-Left (Diagonal)
                        {
                            row: 1,
                            col: 1
                        } // Down-Right (Diagonal)
                    ];
              


                    if(cell.element==='smoke'){
                        for (const {
                                    row: rOffset,
                                    col: cOffset
                                }
                                of directions) {
                                const r = row + rOffset;
                                const c = col + cOffset;
 
                                // Check if the adjacent cell is valid and flammable
                                if (grid[r] && grid[r][c] && elements[grid[r][c].element].flammable) {
                                    if(Math.random() < 0.0001)
                                    grid[r][c].element = 'fire'; // Ignite flammable material
                                }
                            }
                    }
                    if(cell.element==='moltengold'){
                        for (const {
                                    row: rOffset,
                                    col: cOffset
                                }
                                of directions) {
                                const r = row + rOffset;
                                const c = col + cOffset;
 
                                // Check if the adjacent cell is valid and flammable
                                if (grid[r] && grid[r][c] && elements[grid[r][c].element].flammable) {
                                    grid[r][c].element = 'fire'; // Ignite flammable material
                                }
                            }
                    }

                    if(cell.element==='pistil'){
                        const adjacentCells = [{
                                row: 1,
                                col: 0
                            }, // Down
                            {
                                row: -1,
                                col: 0
                            }, // Up
                            {
                                row: 0,
                                col: -1
                            }, // Left
                            {
                                row: 0,
                                col: 1
                            } // Right
                        ];
                                  
         const possibleElements = Object.keys(elements).filter(el => elements[el].type === 'fp');
                 const randomElement = possibleElements[Math.floor(Math.random() * possibleElements.length)];
 
                        for (const {
                                    row: rOffset,
                                    col: cOffset
                                }
                                of adjacentCells) {
                                const r = row + rOffset;
                                const c = col + cOffset;
 
                                // Check if the adjacent cell is valid and flammable
                                if (grid[r] && grid[r][c] && grid[r][c].element === 'empty') {
                                    grid[r][c].element = randomElement;
                                    grid[r][c].fpmove = false;
                                    cell.element = 'pistil2';
                                    
                                }
                            }
                    }
                    if(cell.element==='fireworkf'){
                        for (const {
                                    row: rOffset,
                                    col: cOffset
                                }
                                of directions) {
                                const r = row + rOffset;
                                const c = col + cOffset;
 
                                // Check if the adjacent cell is valid and flammable
                                if (grid[r] && grid[r][c] && elements[grid[r][c].element].flammable) {
                                    grid[r][c].element = 'fire'; // Ignite flammable material
                                }
                            }
                    }
                  

              


                    if(cell.element==='shock'){
                        for (const {
                                    row: rOffset,
                                    col: cOffset
                                }
                                of directions) {
                                const r = row + rOffset;
                                const c = col + cOffset;
 
                                // Check if the adjacent cell is valid and flammable
                                if (grid[r] && grid[r][c] && grid[r][c].element !== 'c4' && elements[grid[r][c].element].flammable ) {
                                    grid[r][c].element = 'fire'; // Ignite flammable material
                                }
                            }
                    }

                 
                    
                    if(cell.element==='flash'){
                        for (const {
                                    row: rOffset,
                                    col: cOffset
                                }
                                of directions) {
                                const r = row + rOffset;
                                const c = col + cOffset;
 
                                // Check if the adjacent cell is valid and flammable
                                if (grid[r] && grid[r][c] && elements[grid[r][c].element].flammable ) {
                                    grid[r][c].element = 'fire'; // Ignite flammable material
                                }
                            }
                    }
                    if(cell.element==='nfire'){
                        for (const {
                                    row: rOffset,
                                    col: cOffset
                                }
                                of directions) {
                                const r = row + rOffset;
                                const c = col + cOffset;
 
                                // Check if the adjacent cell is valid and flammable
                                if (grid[r] && grid[r][c] && elements[grid[r][c].element].flammable ) {
                                    grid[r][c].element = 'fire'; // Ignite flammable material
                                }
                            }
                    }
                    if(cell.element === 'gameoflife'){
                        if(Math.random() < 0.5){
                            initializeCell(row, col, 'empty');
                        }
                    }
                         if(cell.element === 'gameoflife'){
               
                      
                  
                    
    
                  
            
            
                const adjacentCells = [{
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                       
                        
                    
                         
                            if(Math.random() < 0.62){
                            const randomdirection1 = Math.floor(Math.random() * adjacentCells.length);
                            const randomDirection2 = adjacentCells[randomdirection1];

                            const newRow = randomDirection2.row;
                            const newCol = randomDirection2.col;
                           if(newRow < rows - 1 && newRow > 0 && newCol > 0 && newCol < cols - 1){
                          
                               
                            grid[newRow][newCol].element = 'gameoflife';
                            
                            
                           
                        
                            }
                        }
                    }
                    if(cell.element==='tar'){
                        for (const {
                                    row: rOffset,
                                    col: cOffset
                                }
                                of directions) {
                                const r = row + rOffset;
                                const c = col + cOffset;
 
                                // Check if the adjacent cell is valid and flammable
                                if (grid[r] && grid[r][c] && elements[grid[r][c].element].flammable ) {
                                    grid[r][c].element = 'fire'; // Ignite flammable material
                                }
                            }
                    }
                    




                 

                    if (cell.element === 'fire') {
                     const adjacentCells = [{
                                row: row + 1,
                                col: col
                            }, // Down
                            {
                                row: row - 1,
                                col: col
                            }, // Up
                            {
                                row: row,
                                col: col - 1
                            }, // Left
                            {
                                row: row,
                                col: col + 1
                            } // Right
                        ];
                          // Check for adjacent fire cells
                        const fwAdjacent = adjacentCells.some(({
                                row: r,
                                col: c
                            }) =>
                            grid[r] && grid[r][c] && grid[r][c].element === 'water'
                        );
 
 
 
 
 
 
 
 
                        // Ignite oil if adjacent to fire, then skip movement logic
                        if (fwAdjacent) {
                            cell.element = 'empty';
                            cell.age = 0; // Reset age when transformed to fire
                            
                        }
                        if (cell.age === 10) { // Check every 10 frames
                            for (const {
                                    row: rOffset,
                                    col: cOffset
                                }
                                of directions) {
                                const r = row + rOffset;
                                const c = col + cOffset;
 
                                // Check if the adjacent cell is valid and flammable
                                if (grid[r] && grid[r][c] && elements[grid[r][c].element].flammable) {
                                    grid[r][c].element = 'fire'; // Ignite flammable material
                                }
                            }
                        }
                        cell.age++;
 
 
 
 
 
 
 
 
 
 
 
 
 
                        // Handle smoke and transformation logic as before...
                        if (row > 0 && grid[row - 1][col].element === 'empty') {
                            if (cell.age >= 10 && cell.age <= 13) {
                                grid[row - 1][col].element = 'smoke'; // Place smoke above
                            }
                        }
                        // Transform fire into smoke after 0.5 seconds
                        if (cell.age >= 30) {
                         if (Math.random() < 0.07) {
                            cell.element = 'smoke';
                            cell.age = 0; // Reset age for smoke
                            cell.firemove=true;
                         } else
                         if (Math.random() < 0.001) { 
                             cell.element='ash';
                             cell.age = 0; // Reset age for smoke
                             cell.firemove=true;
                         } else 
                         cell.element='empty';
                         cell.age = 0; // Reset age for smoke
                         cell.firemove=true;
                        }
                    }
 
                }
            }
        }
        
            
        let lastPlacementTime = 0; // Variable to store the last placement time
        let placementCooldown = 0; // Cooldown in milliseconds (adjust as needed)
        lastSnap = 0;
        snapcooldown = 1000;
        let teleport = false;

        function placeElement(x, y) {
            if(selectedElement === "lightning"){
                if(Math.random() < 0.5){
                playsfx("lightning1");
                } else{
                    playsfx("lightning2");
                }
               
            }
     const currentTime = Date.now(); // Get the current time
     // Check cooldown for the selected element
    if (selectedElement === 'snap') {
        if (currentTime - lastSnap < snapcooldown) {
            return; // Exit if diamond's cooldown hasn't passed
        }
    } else if (currentTime - lastPlacementTime < placementCooldown) {
        return; // Exit if general cooldown hasn't passed
    }
    
     const colStart = Math.floor((x - (brushSize * voxelSize) / 2) / voxelSize);
     const rowStart = Math.floor((y - (brushSize * voxelSize) / 2) / voxelSize);
 
    
 
     // If the selected element is black hole, check if the cell is empty
     
         // Save the current grid state before modification (Deep Copy)
        
 
     for (let i = 0; i < brushSize; i++) {
         for (let j = 0; j < brushSize; j++) {
            
             const row = rowStart + i;
             const col = colStart + j;
             
             // Check bounds for brush size
             if (row < 0 || row >= rows || col < 0 || col >= cols ) {
                 continue; // Skip if out of bounds
             }
       

        
      
             grid[row][col].lastelement = structuredClone(grid[row][col]);
             // If the selected element is grass, assign a random color
             if (selectedElement === 'grass') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].grassColor = getRandomColorBetween(elements.grass.color1, elements.grass.color2); // Store the random color
                 grid[row][col].ink='false';
             } else if (selectedElement === 'stone') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].stoneColor = getRandomColorBetween(elements.stone.color1, elements.stone.color2); // Store the random color
                 grid[row][col].ink='false';
              
             } else if (selectedElement === 'dryice') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].dryiceColor = getRandomColorBetween(elements.dryice.color1, elements.dryice.color2); // Store the random color
                 grid[row][col].ink='false';
             }else if (selectedElement === 'cloth') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].clothColor = getRandomColorBetween(elements.cloth.color1, elements.cloth.color2); // Store the random color
                 grid[row][col].ink='false';
             } else if (selectedElement === 'cheese') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].cheeseColor = getRandomColorBetween1(elements.cheese.color1, elements.cheese.color2); // Store the random color
                 grid[row][col].ink='false';
             } else if (selectedElement === 'basalt') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].basaltColor = getRandomColorBetween(elements.basalt.color1, elements.basalt.color2); // Store the random color
                 grid[row][col].ink='false';
             } else if(selectedElement === 'shockwave'){
                shockwave(row, col);
             }else if(selectedElement === 'hologram'){
                grid[row][col].hologram=true;
             } else if(selectedElement === 'fireshockwave'){
                shockwavefire(row, col);
             } else if(selectedElement === 'teleport'){
                
                if(teleport === true){
                    for(let r = 0;  r < rows; r++){
                        for(let c = 0;c < cols; c++){
                            if(grid[r][c].element === 'teleport1'){
                                grid[r][c].element = 'empty';
                            }
                        }
                    }
                    grid[row][col].element = 'teleport1';
                 grid[row][col].age = 0; // Reset age when placed
                  teleport = false;

                } else{
                    for(let r = 0;  r < rows; r++){
                        for(let c = 0;  c < cols; c++){
                            if(grid[r][c].element === 'teleport2'){
                                grid[r][c].element = 'empty';
                            }
                        }
                    }
                    grid[row][col].element = 'teleport2';
                    grid[row][col].age = 0; // Reset age when placed
                    teleport = true;
                }
             }else if (selectedElement === 'obsidian') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].obsidianColor = getRandomColorBetween(elements.obsidian.color1, elements.obsidian.color2); // Store the random color
                 grid[row][col].ink='false';
             } else if (selectedElement === 'wood') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].woodColor = getRandomColorBetween(elements.wood.color1, elements.wood.color2); // Store the random color
                 grid[row][col].ink='false';
             } else if (selectedElement === 'gold') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].goldColor = getRandomColorBetween(elements.gold.color1, elements.gold.color2); // Store the random color
                 grid[row][col].ink='false';
             } else if (selectedElement === 'straw') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].strawColor = getRandomColorBetween(elements.straw.color1, elements.straw.color2); // Store the random color
                 grid[row][col].ink='false';
             } else if (selectedElement === 'gs') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].gsColor = getRandomColorBetween(elements.gs.color1, elements.gs.color2); // Store the random color
                 grid[row][col].ink='false';
             } else   if (selectedElement === 'diamond') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].diamondColor = getRandomColorBetween(elements.diamond.color1, elements.diamond.color2); // Store the random color
                 grid[row][col].ink='false';
             } else   if (selectedElement === 'web') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].webColor = getRandomColorBetween(elements.web.color1, elements.web.color2); // Store the random color
                 grid[row][col].ink='false';
             }else   if (selectedElement === 'bamboo') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].bambooColor = getRandomColorBetween(elements.bamboo.color1, elements.bamboo.color2); // Store the random color
                 grid[row][col].ink='false';
             } else if(selectedElement === 'random'){
                      // List of possible elements to replace the virus
                 const possibleElements = Object.keys(elements).filter(el => el !== 'random' && el !== 'empty' && el !== 'antimatter');
                 const randomElement = possibleElements[Math.floor(Math.random() * possibleElements.length)];

                 // Replace virus with a random element
                 grid[row][col].element = randomElement;
                 grid[row][col].age = 0; // Reset age when placed

             }else if (selectedElement === 'paper') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].paperColor = getRandomColorBetween(elements.paper.color1, elements.paper.color2); // Store the random color
                 grid[row][col].ink='false';
             } else if (selectedElement === 'dirt') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].dirtColor = getRandomColorBetween(elements.dirt.color1, elements.dirt.color2); // Store the random color
                 grid[row][col].ink='false';
             }else if (selectedElement === 'sand') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].sandColor = getRandomColorBetween(elements.sand.color1, elements.sand.color2); // Store the random color
                 grid[row][col].ink='false';
             } else if (selectedElement === 'concrete') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].concreteColor = getRandomColorBetween(elements.concrete.color1, elements.concrete.color2); // Store the random color
                 grid[row][col].ink='false';
             } else if(selectedElement === 'text'){
                const text = document.getElementById("textselection").value;
                const size = document.getElementById("textsize").value;
                const element = document.getElementById("elementtext").value;

                
                drawTextOnGrid(`${text}`, row, col, `${element}`, size);
             } else if (selectedElement === 'sandstone') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].sandstoneColor = getRandomColorBetween(elements.sandstone.color1, elements.sandstone.color2); // Store the random color
                 grid[row][col].ink='false';
             }else if (selectedElement === 'bedrock') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].bedrockColor = getRandomColorBetween(elements.bedrock.color1, elements.bedrock.color2); // Store the random color
                 grid[row][col].ink='false';
             }else   if (selectedElement === 'moss') {
                 grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].mossColor = getRandomColorBetween(elements.moss.color1, elements.moss.color2); // Store the random color
                 grid[row][col].ink='false';
             }else   if (selectedElement === 'grab') {
                if(grid[row][col].element !== 'empty'){
                 grid[row][col].grab = true;
                 grid[row][col].push = false;
                 grid[row][col].elevate = false;
                }
                 
                 
             }else   if (selectedElement === 'push') {
                if(grid[row][col].element !== 'empty'){
               grid[row][col].push = true;
               grid[row][col].grab = false;
               grid[row][col].elevate = false;
            
                }
               
           } else if(selectedElement === 'line' || selectedElement === 'square' || selectedElement === 'circle' || selectedElement === 'triangle'){
                
           }else     if (selectedElement === 'elevate') {
               if(grid[row][col].element !== 'empty'){
               grid[row][col].elevate = true;
               grid[row][col].grab = false;
               grid[row][col].push = false;
               
               }
           } else     if (selectedElement === 'sonicboom') {
               if(grid[row][col].element !== 'empty'){
               grid[row][col].sound= true;
               
               }
           } else     if (selectedElement === 'select') {
             
           }else     if (selectedElement === 'image') {
          
            drawImageToGrid(selectedimage, row, col)
           

            } else  if (selectedElement === 'media') {
                const scale = parseFloat(document.getElementById("scaleSlider").value);
                playMediaToGrid(URL.createObjectURL(selectedMedia), row, col, scale);



}else  if (selectedElement === 'screen') {
    const scale = parseFloat(document.getElementById("scaleSlider").value);
    placeSelectedScreenToGrid(row, col, scale);



}else   if (selectedElement === 'move') {
             
            } else    if (selectedElement === 'move') {
                if(grid[row][col].powered === false){
             grid[row][col].powered = true;
                } else{
                    grid[row][col].powered = false;
                }}else if(selectedElement === 'wall'){

                grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].ink='false';
                 grid[row][col].unbreakable = true;
                 grid[row][col].unbreakableelement = selectedElement;
                
            } else if(selectedElement === 'coloredvoxel'){
                grid[row][col].customcolor = selectedColor;
                grid[row][col].element = selectedElement;
            } else if(selectedElement === 'pointer'){
                grid[row][col].customcolor = selectedColor;
                grid[row][col].element = selectedElement;
            } else if(selectedElement === 'paint'){
                grid[row][col].customcolor = selectedColor;
                grid[row][col].element = selectedElement;
            }else if(selectedElement === 'paintball'){
                grid[row][col].customcolor = selectedColor;
                grid[row][col].element = selectedElement;
            } else if(selectedElement === 'cloud'){
                grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].ink='false';
                 grid[row][col].size = Math.floor(Math.random() * (28 - 10 + 1)) + 10;
            }else if(selectedElement === 'raincloud'){
                grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].ink='false';
                 grid[row][col].size = Math.floor(Math.random() * (39 - 13 + 1)) + 13;
            }else if(selectedElement === 'stormcloud'){
                grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].ink='false';
                 grid[row][col].size =  Math.floor(Math.random() * (45 - 23 + 1)) + 23;
            }else if(selectedElement === 'snowcloud'){
             
                grid[row][col].element = selectedElement;
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].ink='false';
                 grid[row][col].size =  Math.floor(Math.random() * (28 - 13 + 1)) + 13;
            }
           
            else {
                grid[row][col].element = selectedElement;
               
                 grid[row][col].age = 0; // Reset age when placed
                 grid[row][col].ink='false';
             }
         }
     }
     if(selectedElement === 'snap'){
        lastSnap = currentTime; // Update the last placement time
     } else 
     lastPlacementTime = currentTime; // Update the last placement time
 }
 
 function isHoveringOverSelected(x, y) {
    return grid[y] && grid[y][x] && grid[y][x].selected;
}


canvas.addEventListener('mousedown', (e) => {
    

    if (selectedElement === 'select') {
        for (let row = rows - 1; row >= 0; row--) {
            for (let col = 0; col < cols; col++) {
                if (grid[row][col].selected === true) {
                    grid[row][col].selected = false;
                }
            }
        }
    }
});


// Undo function


 


        canvas.addEventListener('mousedown', () => {
           isDrawing = true;
           
        });
       
        canvas.addEventListener('mouseup', () => {
            if(selectedElement === "fire" || selectedElement === "water"  || selectedElement === "oil"){
                setTimeout(() => {
                    stopPlacingLoop();
                    soundplaying = false;
                }, 200);
            } else{
            stopPlacingLoop();
            soundplaying = false;
            }

            isDrawing = false;
            
        });
      
        let phantomElements2 = [];
        let phantomElements3 = [];

let centerX2 = 0;
let centerY2 = 0;

function createPhantomElements2() {
    let newPhantomElements2 = [];
    
    // Step 1: Collect selected elements and clear the grid
    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            if (grid[y][x].selected) {
                newPhantomElements2.push({
                    x2: x,  // Renamed with a '2' at the end
                    y2: y,  // Renamed with a '2' at the end
                    element2: JSON.parse(JSON.stringify(grid[y][x])) // Deep copy and renamed
                });
                grid[y][x] = { element: "empty" }; // Remove original element
            }
        }
    }

    if (newPhantomElements2.length > 0) {
        phantomElements2 = newPhantomElements2;  // Save phantom elements

        // Calculate the center of the selected elements (this center is fixed)
        centerX2 = Math.floor(phantomElements2.reduce((acc, el) => acc + el.x2, 0) / phantomElements2.length);
        centerY2 = Math.floor(phantomElements2.reduce((acc, el) => acc + el.y2, 0) / phantomElements2.length);

        isPlacing = true;  // Indicate that placement mode is active
    }
}


function rotateMass2(direction) {
    // Step 3: Rotate each phantom element around the fixed center
    phantomElements2.forEach(element2 => {
        const dx2 = element2.x2 - centerX2;
        const dy2 = element2.y2 - centerY2;

        if (direction === 'left') {
            element2.x2 = centerX2 - dy2;
            element2.y2 = centerY2 + dx2;
        } else if (direction === 'right') {
            // Rotate clockwise (90 degrees)
            element2.x2 = centerX2 + dy2;
            element2.y2 = centerY2 - dx2;
        }
    });

    // Step 4: Reapply phantom elements to the grid
    phantomElements2.forEach(element2 => {
        // Ensure the new positions are valid and within bounds
        if (element2.x2 >= 0 && element2.x2 < cols && element2.y2 >= 0 && element2.y2 < rows) {
            grid[element2.y2][element2.x2] = element2.element2;
        }
    });
}

window.addEventListener('keydown', function(event) {
    if(cmd === false){
    if (event.key === 'a') {
        createPhantomElements2(); // Create phantom elements (if not already created)
        rotateMass2('left'); // Rotate counterclockwise
    } else if (event.key === 'd') {
        createPhantomElements2(); // Create phantom elements (if not already created)
        rotateMass2('right'); // Rotate clockwise
    }
}
});




let soundplaying = false;

canvas.addEventListener("mousedown", (e) => {
    
    if(soundplaying === false){
        if(selectedElement === "stone" || selectedElement === "obsidian" || selectedElement === "basalt" || selectedElement === "concrete" || selectedElement === "tnt" || selectedElement === "uranium" || selectedElement === "smokeBomb" || selectedElement === "grenade" || selectedElement === "solidcloner" || selectedElement === "coal" || selectedElement === "diamond"){
                startPlacingLoop("stoneplace1");
                soundplaying = true;
            } else    if(selectedElement === "wood" || selectedElement === "sawdust"){
                startPlacingLoop("woodplace1");
                soundplaying = true;
            }else    if(selectedElement === "grass" || selectedElement === "moss" || selectedElement === "cactus" || selectedElement === "pollen" || selectedElement === "vine"){
                startPlacingLoop("grassplace1");
                soundplaying = true;
            }else    if(selectedElement === "fire" || selectedElement === "plasma"){

                startPlacingLoop("fire1");
                
                soundplaying = true;
            }else    if(selectedElement === "water" || selectedElement === "oil" || selectedElement === "syrup" || selectedElement === "liquidN" || selectedElement === "milk" || selectedElement === "mercury" || selectedElement === "acid" || selectedElement === "nitro"){

startPlacingLoop("waterplace1");

soundplaying = true;
}else    if(selectedElement === "lava" || selectedElement === "magma"){

startPlacingLoop("lavaplace1");

soundplaying = true;
}else   
 if(selectedElement === "sand" || selectedElement === "dirt" || selectedElement === "cloner" || selectedElement === "charcoal" || selectedElement === "gravel"){

startPlacingLoop("sandplace1");

soundplaying = true;
        } else    if(selectedElement === "mud"){

startPlacingLoop("mudplace1");

soundplaying = true;
}else    if(selectedElement === "ice"){

startPlacingLoop("iceplace1");

soundplaying = true;
}else    if(selectedElement === "snow"){

startPlacingLoop("snowplace1");

soundplaying = true;
}else    if(selectedElement === "sugar" || selectedElement === "salt" || selectedElement === "gunpowder"){

startPlacingLoop("sugarplace1");

soundplaying = true;
}else    if(selectedElement === "steam" || selectedElement === "smoke" || selectedElement === "ash" || selectedElement === "fog"){

startPlacingLoop("steamplace1");

soundplaying = true;
}else    if(selectedElement === "glass"){

startPlacingLoop("glassplace1");

soundplaying = true;
}else    if(selectedElement === "virus"){

startPlacingLoop("virusplace1");

soundplaying = true;
}else    if(selectedElement === "Leaf"){

startPlacingLoop("leafplace1");

soundplaying = true;
}else    if(selectedElement === "crystal" || selectedElement === "quartz"){

startPlacingLoop("crystalplace1");

soundplaying = true;
}else    if(selectedElement === "glitch"){

startPlacingLoop("glitchplace1");

soundplaying = true;
} else if(selectedElement === 'random'){
    const randomIndex = Math.floor(Math.random() * sfxsounds.length);
  
  // Get the random sound object
  const sound = sfxsounds[randomIndex];

  // Create a new audio element
  const newSound = new Audio(sound.src);
 
  
  // Set the volume (assuming sfx.volume is defined)
  newSound.volume = sfx.volume; // Make sure sfx.volume is defined somewhere in your code
  
  // Play the sound
  newSound.play().catch(error => {
    console.warn("Error playing sound:", error);
  });
 
}else    if(selectedElement === "fly"){

startPlacingLoop("flyplace1");

soundplaying = true;
}else    if(selectedElement === "steel" || selectedElement === "copper" || selectedElement === "rust" || selectedElement === "gallium" || selectedElement === "aluminium"){

startPlacingLoop("steelplace1");

soundplaying = true;
}else    if(selectedElement === "sponge"){

startPlacingLoop("spongeplace1");

soundplaying = true;
}else    if(selectedElement === "blackhole"){

startPlacingLoop("blackholeplace1");

soundplaying = true;
}else    if(selectedElement === "bone"){

startPlacingLoop("boneplace1");

soundplaying = true;
}else    if(selectedElement === "plastic"){

startPlacingLoop("plasticplace1");

soundplaying = true;
}else    if(selectedElement === "lasersource" || selectedElement === "supernova" ){

startPlacingLoop("laserplace1");

soundplaying = true;
}else    if(selectedElement === "brick"){

startPlacingLoop("brickplace1");

soundplaying = true;
}else    if(selectedElement === "clay"){

startPlacingLoop("clayplace1");

soundplaying = true;
}

    }
});

let previewVoxels = [];
function createPreviewVoxel(row, col, color) {
    const rect = canvas.getBoundingClientRect();

    const voxel = document.createElement('div');
    voxel.style.width = `${voxelSize}px`; // Corrected template literal
    voxel.style.height = `${voxelSize}px`; // Corrected template literal
    voxel.style.position = 'absolute';
    voxel.style.left = `${rect.left + col * voxelSize + 10}px`; // Corrected template literal
    voxel.style.top = `${rect.top + row * voxelSize}px`; // Corrected template literal
    voxel.style.opacity = 0.5;
    voxel.style.pointerEvents = 'none';

    // Use exact input color with no modification
    voxel.style.backgroundColor = color;
   
    document.body.appendChild(voxel);
    previewVoxels.push(voxel);
}



function deletePreviewVoxels() {
    for (const voxel of previewVoxels) {
        if (voxel.parentElement) voxel.remove();
    }
    previewVoxels = [];
}
function previewLine(p1, p2, element1, element2) {
    deletePreviewVoxels();

    let x0 = p1.col;
    let y0 = p1.row;
    let x1 = p2.col;
    let y1 = p2.row;

    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const sx = x0 < x1 ? 1 : -1;
    const sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;

    let defaultColor = '#888';
    const data1 = elements[element1];
    const data2 = elements[element2];

    function getElementColor(data, nx, ny) {
        if (!data) return defaultColor;
        if (Array.isArray(data.colors)) {
            const index = Math.floor(getCellRandom(nx, ny) * data.colors.length);
            return data.colors[index];
        }
        return data.color || data.initialColor || defaultColor;
    }

    function getColor(nx, ny) {
        const row = ny;
        const col = nx;
      
    const rand = getCellRandom(col, row);  // Get the random value based on row and col
    const elementName = rand < 0.5 ? element1 : element2;
    const elementData = elements[elementName];

    if (!elementData) return '#888';  // Return a fallback color if element is not found

    // Combine the rand, row, and col to create a new seed or pattern for color selection
    const combinedSeed = rand < 0.5 ? 1 : 0; // Alternating color pattern based on rand, row, and col

    // Check if color1 and color2 exist
    if (elementData.color1 && elementData.color2) {
        // Choose color1 or color2 based on combinedSeed (either 0 or 1)
        return combinedSeed === 0 ? elementData.color1 : elementData.color2;
    }

    // Fallback for when color1 and color2 are not defined, using an array of colors
    if (Array.isArray(elementData.colors)) {
        const index = Math.floor((rand + row + col) % elementData.colors.length);  // Cycle through colors based on combinedSeed
        return elementData.colors[index];
    }

    // Return a default color if no other options are available
    return elementData.color || elementData.initialColor || '#888';


    }

    while (true) {
        if (y0 >= 0 && y0 < rows && x0 >= 0 && x0 < cols) {
            for (let dyOffset = -Math.floor(lineThickness / 2); dyOffset <= Math.floor(lineThickness / 2); dyOffset++) {
                for (let dxOffset = -Math.floor(lineThickness / 2); dxOffset <= Math.floor(lineThickness / 2); dxOffset++) {
                    const nx = x0 + dxOffset;
                    const ny = y0 + dyOffset;
                    if (ny >= 0 && ny < rows && nx >= 0 && nx < cols) {
                        createPreviewVoxel(ny, nx, getColor(nx, ny));
                    }
                }
            }
        }

        if (x0 === x1 && y0 === y1) break;
        const e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x0 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y0 += sy;
        }
    }
}


let lineelement = null;
let point1 = null;
let point2 = null;
let line = false;
let lineelement2 = null;
// Global thickness variable (if you want it to be set globally)
let lineThickness = 1;
function previewSquare(p1, p2, element1, element2) {
    deletePreviewVoxels2();

    const startCol = Math.min(p1.col, p2.col);
    const endCol = Math.max(p1.col, p2.col);
    const startRow = Math.min(p1.row, p2.row);
    const endRow = Math.max(p1.row, p2.row);

    const colsCount = endCol - startCol + 1;
    const rowsCount = endRow - startRow + 1;

    const rect = canvas.getBoundingClientRect();
    const canvasLeft = rect.left;
    const canvasTop = rect.top;

    const defaultColor = '#888';
    const data1 = elements[element1];
    const data2 = elements[element2];

    function getElementColor(data, col, row) {
        if (!data) return defaultColor;
        if (Array.isArray(data.colors)) {
            const index = Math.floor(getCellRandom(col, row) * data.colors.length);
            return data.colors[index];
        }
        return data.color || data.initialColor || defaultColor;
    }

    function getColor(col, row) {
    const rand = getCellRandom(col, row);  // Get the random value based on row and col
    const elementName = rand < 0.5 ? element1 : element2;
    const elementData = elements[elementName];

    if (!elementData) return '#888';  // Return a fallback color if element is not found

    // Combine the rand, row, and col to create a new seed or pattern for color selection
    const combinedSeed = rand < 0.5 ? 1 : 0; // Alternating color pattern based on rand, row, and col

    // Check if color1 and color2 exist
    if (elementData.color1 && elementData.color2) {
        // Choose color1 or color2 based on combinedSeed (either 0 or 1)
        return combinedSeed === 0 ? elementData.color1 : elementData.color2;
    }

    // Fallback for when color1 and color2 are not defined, using an array of colors
    if (Array.isArray(elementData.colors)) {
        const index = Math.floor((rand + row + col) % elementData.colors.length);  // Cycle through colors based on combinedSeed
        return elementData.colors[index];
    }

    // Return a default color if no other options are available
    return elementData.color || elementData.initialColor || '#888';
}

    // Create grid container
    const grid = document.createElement('div');
    grid.className = 'preview-grid';
    grid.style.position = 'absolute';
    grid.style.left = `${canvasLeft + startCol * voxelSize + 10}px`;
    grid.style.top = `${canvasTop + startRow * voxelSize}px`;
    grid.style.width = `${colsCount * voxelSize}px`;
    grid.style.height = `${rowsCount * voxelSize}px`;
    grid.style.display = 'grid';
    grid.style.gridTemplateColumns = `repeat(${colsCount}, ${voxelSize}px)`;
    grid.style.gridTemplateRows = `repeat(${rowsCount}, ${voxelSize}px)`;
    grid.style.pointerEvents = 'none';
    grid.style.opacity = '0.5';

    for (let row = startRow; row <= endRow; row++) {
        for (let col = startCol; col <= endCol; col++) {
            const cell = document.createElement('div');
            cell.style.width = `${voxelSize}px`;
            cell.style.height = `${voxelSize}px`;
            cell.style.backgroundColor = getColor(col, row);
            grid.appendChild(cell);
        }
    }

    document.body.appendChild(grid);
    previewVoxels.push(grid);
}
function previewCircle(p1, p2, element1, element2) {
  // Clear existing preview voxels
  deletePreviewVoxels2();

  // Determine bounds
  const startRow = Math.min(p1.row, p2.row);
  const endRow = Math.max(p1.row, p2.row);
  const startCol = Math.min(p1.col, p2.col);
  const endCol = Math.max(p1.col, p2.col);

  // Center and radii
  const centerRow = startRow + (endRow - startRow) / 2;
  const centerCol = startCol + (endCol - startCol) / 2;
  const radiusX = Math.abs(endCol - startCol) / 2;
  const radiusY = Math.abs(endRow - startRow) / 2;

  const ovalStartRow = Math.floor(centerRow - radiusY);
  const ovalEndRow = Math.ceil(centerRow + radiusY);
  const ovalStartCol = Math.floor(centerCol - radiusX);
  const ovalEndCol = Math.ceil(centerCol + radiusX);

  const rect = canvas.getBoundingClientRect();
  const canvasLeft = rect.left + 10;
  const canvasTop = rect.top;
  function getColor(col, row) {
    const rand = getCellRandom(col, row);  // Get the random value based on row and col
    const elementName = rand < 0.5 ? element1 : element2;
    const elementData = elements[elementName];

    if (!elementData) return '#888';  // Return a fallback color if element is not found

    // Combine the rand, row, and col to create a new seed or pattern for color selection
    const combinedSeed = rand < 0.5 ? 1 : 0; // Alternating color pattern based on rand, row, and col

    // Check if color1 and color2 exist
    if (elementData.color1 && elementData.color2) {
        // Choose color1 or color2 based on combinedSeed (either 0 or 1)
        return combinedSeed === 0 ? elementData.color1 : elementData.color2;
    }

    // Fallback for when color1 and color2 are not defined, using an array of colors
    if (Array.isArray(elementData.colors)) {
        const index = Math.floor((rand + row + col) % elementData.colors.length);  // Cycle through colors based on combinedSeed
        return elementData.colors[index];
    }

    // Return a default color if no other options are available
    return elementData.color || elementData.initialColor || '#888';
}



  for (let row = ovalStartRow; row <= ovalEndRow; row++) {
    for (let col = ovalStartCol; col <= ovalEndCol; col++) {
      const distance = Math.pow((col - centerCol) / radiusX, 2) + Math.pow((row - centerRow) / radiusY, 2);
      if (distance <= 1) {
        const cell = document.createElement('div');
        cell.style.width = `${voxelSize}px`;
        cell.style.height = `${voxelSize}px`;
        cell.style.backgroundColor = getColor(col, row);
        cell.style.position = 'absolute';
        cell.style.left = `${canvasLeft + col * voxelSize}px`;
        cell.style.top = `${canvasTop + row * voxelSize}px`;
        cell.style.pointerEvents = 'none';
        cell.style.opacity = 0.5;

        document.body.appendChild(cell);
        previewVoxels.push(cell);
      }
    }
  }
}



function deletePreviewVoxels2() {
    // Remove all preview voxel elements from the DOM
    previewVoxels.forEach(voxel => voxel.remove());
    // Clear the array of tracked preview elements
    previewVoxels = [];
}
function mulberry32(seed) {
    return function() {
        seed |= 0;
        seed = (seed + 0x6D2B79F5) | 0;
        let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
        t = (t + Math.imul(t ^ t >>> 7, 61 | t)) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}
function stringToSeed(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = (hash << 5) - hash + str.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
    }
    return hash;
}


function getCellRandom(col, row) {
    const seed = (row * 73856093) ^ (col * 19349663); // big primes to spread bits
    const rand = mulberry32(seed);
    return rand(); // returns number between 0 and 1
}


function createLine(p1, p2, element, element2){
    deletePreviewVoxels();
    let x0 = p1.col;
    let y0 = p1.row;
    let x1 = p2.col;
    let y1 = p2.row;

    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const sx = x0 < x1 ? 1 : -1;
    const sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;

    while (true) {
        // Draw square around the current point with the given thickness (using global lineThickness)
        for (let dyOffset = -Math.floor(lineThickness / 2); dyOffset <= Math.floor(lineThickness / 2); dyOffset++) {
            for (let dxOffset = -Math.floor(lineThickness / 2); dxOffset <= Math.floor(lineThickness / 2); dxOffset++) {
                const nx = x0 + dxOffset;
                const ny = y0 + dyOffset;
                if (ny >= 0 && ny < rows && nx >= 0 && nx < cols) {
                    const row = ny;
                    const col = nx;
                    let chosenElement = element;

// If element2 exists, randomly choose between element and element2
if (element2 && elements[element2]) {
    chosenElement = getCellRandom(col, row) < 0.5 ? element : element2;
}

// Assign the chosen element
grid[row][col].element = chosenElement;

// Assign a random color if both color1 and color2 exist
if (elements[chosenElement].color1 && elements[chosenElement].color2) {
    grid[row][col].color = Math.random() < 0.5 ? elements[chosenElement].color1 : elements[chosenElement].color2;
}


                  
                }
            }
        }

        if (x0 === x1 && y0 === y1) break;
        const e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x0 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y0 += sy;
        }
    }
}
function createSquare(p1, p2, element, element2) {
    // Clear existing preview voxels
    deletePreviewVoxels2();
  
    let startCol = Math.min(p1.col, p2.col);
    let endCol = Math.max(p1.col, p2.col);
    const startRow = Math.min(p1.row, p2.row);
    const endRow = Math.max(p1.row, p2.row);

    // Iterate over the grid cells to place elements
    for (let row = startRow; row <= endRow; row++) {
        for (let col = startCol; col <= endCol; col++) {
            if (grid[row] && grid[row][col]) {
    let chosenElement = element;

    // If element2 exists, randomly choose between element and element2
    if (element2 && elements[element2]) {
        chosenElement = getCellRandom(col, row) < 0.5 ? element : element2;
    }

    // Assign the chosen element
    grid[row][col].element = chosenElement;

    // Assign a random color if both color1 and color2 exist
    if (elements[chosenElement].color1 && elements[chosenElement].color2) {
        grid[row][col].color = Math.random() < 0.5 ? elements[chosenElement].color1 : elements[chosenElement].color2;
    }
}

        }
    }
}
function fillTriangleVoxel(points, element, element2) {
    if (points.length !== 3) return;

    // Sort by row (y)
    points.sort((a, b) => a.row - b.row);
    const [v0, v1, v2] = points;

    function interpolate(y, y0, x0, y1, x1) {
        if (y1 === y0) return x0;
        return x0 + ((y - y0) * (x1 - x0)) / (y1 - y0);
    }

    function drawScanline(y, xStart, xEnd) {
        const startCol = Math.floor(Math.min(xStart, xEnd));
        const endCol = Math.ceil(Math.max(xStart, xEnd));

        for (let col = startCol; col <= endCol; col++) {
            if (grid[y] && grid[y][col]) {
                // Color logic
                let color;
                const pick = getCellRandom(col, y) < 0.5;
                const currentElement = element2 && pick ? element2 : element;

                if (elements[currentElement].color1 && elements[currentElement].color2) {
                    color = getCellRandom(col, y) < 0.5 ? elements[currentElement].color1 : elements[currentElement].color2;
                }

                grid[y][col].element = currentElement;
                if (color) grid[y][col].color = color;
            }
        }
    }

    const totalRows = v2.row - v0.row;
    if (totalRows === 0) return;

    for (let y = v0.row; y <= v2.row; y++) {
        let xA = interpolate(y, v0.row, v0.col, v2.row, v2.col);
        let xB;

        if (y < v1.row || v1.row === v0.row) {
            xB = interpolate(y, v0.row, v0.col, v1.row, v1.col);
        } else {
            xB = interpolate(y, v1.row, v1.col, v2.row, v2.col);
        }

        drawScanline(y, xA, xB);
    }
}


function createCircle(p1, p2, element, element2) {
  deletePreviewVoxels2();

  // Determine the min and max for rows (y-axis) and columns (x-axis)
  const startRow = Math.min(p1.row, p2.row);
  const endRow = Math.max(p1.row, p2.row);
  const startCol = Math.min(p1.col, p2.col);
  const endCol = Math.max(p1.col, p2.col);

  // Calculate center of the oval (center between p1 and p2)
  const centerRow = startRow + (endRow - startRow) / 2;
  const centerCol = startCol + (endCol - startCol) / 2;

  // Calculate the radii for the oval
  const radiusX = Math.abs(endCol - startCol) / 2; // Horizontal radius (X-axis)
  const radiusY = Math.abs(endRow - startRow) / 2; // Vertical radius (Y-axis)

  // Define bounding box for the oval
  const ovalStartRow = Math.floor(centerRow - radiusY);
  const ovalEndRow = Math.ceil(centerRow + radiusY);
  const ovalStartCol = Math.floor(centerCol - radiusX);
  const ovalEndCol = Math.ceil(centerCol + radiusX);

  // Iterate through the bounding box and check if the point lies within the oval
  for (let row = ovalStartRow; row <= ovalEndRow; row++) {
    for (let col = ovalStartCol; col <= ovalEndCol; col++) {
      // Check if the point (row, col) lies within the oval
      const distance = Math.pow((col - centerCol) / radiusX, 2) + Math.pow((row - centerRow) / radiusY, 2);
      if (distance <= 1 && grid[row] && grid[row][col]) {
        let chosenElement = element;

// If element2 exists, randomly choose between element and element2
if (element2 && elements[element2]) {
    chosenElement = getCellRandom(col, row) < 0.5 ? element : element2;
}

// Assign the chosen element
grid[row][col].element = chosenElement;

// Assign a random color if both color1 and color2 exist
if (elements[chosenElement].color1 && elements[chosenElement].color2) {
    grid[row][col].color = Math.random() < 0.5 ? elements[chosenElement].color1 : elements[chosenElement].color2;
}

      }
    }
  }
}

canvas.addEventListener("mousemove", (e) => {
    if (selectedElement === 'line' && point1) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const col = Math.floor(mouseX / voxelSize);
        const row = Math.floor(mouseY / voxelSize);

        const point2Preview = { row, col };
        previewLine(point1, point2Preview, lineelement, lineelement2);
    }
});
canvas.addEventListener("mousemove", (e) => {
    if (selectedElement === 'square' && point1) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const col = Math.floor(mouseX / voxelSize);
        const row = Math.floor(mouseY / voxelSize);

        const point2Preview = { row, col };
        previewSquare(point1, point2Preview, lineelement, lineelement2);
    }
});
function previewPolygon(points, elementName) {
  deletePreviewVoxels2();

  const rect = canvas.getBoundingClientRect();
  const canvasLeft = rect.left + 10;
  const canvasTop = rect.top;

  const defaultColor = '#888';
  const elementData = elements[elementName];
  const color = Array.isArray(elementData?.colors)
    ? elementData.colors[Math.floor(Math.random() * elementData.colors.length)]
    : elementData?.color || elementData?.initialColor || defaultColor;

  function createLineDiv(p1, p2) {
    const x1 = p1.col * voxelSize + canvasLeft + voxelSize / 2;
    const y1 = p1.row * voxelSize + canvasTop + voxelSize / 2;
    const x2 = p2.col * voxelSize + canvasLeft + voxelSize / 2;
    const y2 = p2.row * voxelSize + canvasTop + voxelSize / 2;

    const length = Math.hypot(x2 - x1, y2 - y1);
    const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;

    const line = document.createElement('div');
    line.className = 'preview-voxel';
    line.style.position = 'absolute';
    line.style.left = `${x1}px`;
    line.style.top = `${y1}px`;
    line.style.width = `${length}px`;
    line.style.height = `2px`;
    line.style.backgroundColor = color;
    line.style.opacity = '0.5';
    line.style.transform = `rotate(${angle}deg)`;
    line.style.transformOrigin = '0 0';
    line.style.pointerEvents = 'none';

    document.body.appendChild(line);
    previewVoxels.push(line);
  }

  if (points.length === 3) {
    createLineDiv(points[0], points[1]);
    createLineDiv(points[1], points[2]);
    createLineDiv(points[2], points[0]);
  } else if (points.length === 2) {
    createLineDiv(points[0], points[1]);
  }
}


function previewFilledTriangle(points, elementName) {
  deletePreviewVoxels2(); // Clear previous preview

  const rect = canvas.getBoundingClientRect();
  const canvasLeft = rect.left + 10;
  const canvasTop = rect.top;

  const defaultColor = '#888';
  const elementData = elements[elementName];
  const color = Array.isArray(elementData?.colors)
    ? elementData.colors[Math.floor(Math.random() * elementData.colors.length)]
    : elementData?.color || elementData?.initialColor || defaultColor;

  // Function to interpolate and get the x-coordinate of the intersection
  function interpolate(p1, p2, row) {
    const t = (row - p1.row) / (p2.row - p1.row);
    const col = p1.col + t * (p2.col - p1.col);
    return col;
  }

  // Sort points to ensure top-to-bottom order
  points.sort((a, b) => a.row - b.row);
  const [p1, p2, p3] = points;

  // Fill the triangle by scanning each row between p1 and p3
  for (let row = p1.row; row <= p3.row; row++) {
    let leftCol, rightCol;

    // Handle case where row is between p1, p2
    if (row <= p2.row) {
      leftCol = interpolate(p1, p2, row);
    } else {
      leftCol = interpolate(p2, p3, row);
    }

    // Handle case where row is between p2, p3
    if (row <= p2.row) {
      rightCol = interpolate(p1, p2, row);
    } else {
      rightCol = interpolate(p2, p3, row);
    }

    // Ensure leftCol < rightCol
    if (leftCol > rightCol) {
      [leftCol, rightCol] = [rightCol, leftCol];
    }

    // Create divs for each voxel in the filled region
    for (let col = Math.floor(leftCol); col <= Math.floor(rightCol); col++) {
      const x = col * voxelSize + canvasLeft;
      const y = row * voxelSize + canvasTop;

      const div = document.createElement('div');
      div.className = 'preview-voxel';
      div.style.position = 'absolute';
      div.style.left = `${x}px`;
      div.style.top = `${y}px`;
      div.style.width = `${voxelSize}px`;
      div.style.height = `${voxelSize}px`;
      div.style.backgroundColor = color;
      div.style.opacity = '0.5';
      div.style.pointerEvents = 'none';

      document.body.appendChild(div);
      previewVoxels.push(div);
    }
  }
}


canvas.addEventListener("mousemove", (e) => {
    if (selectedElement === 'circle' && point1) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const col = Math.floor(mouseX / voxelSize);
        const row = Math.floor(mouseY / voxelSize);

        const point2Preview = { row, col };
        previewCircle(point1, point2Preview, lineelement, lineelement2);
    }
});
canvas.addEventListener("mousedown", (e) => {
    if (selectedElement === 'line') {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const col = Math.floor(mouseX / voxelSize);
        const row = Math.floor(mouseY / voxelSize);

        if (row >= 0 && row < rows && col >= 0 && col < cols) {
            if (!line) {
                point1 = { row, col };
                line = true;
            } else {
                point2 = { row, col };
                if (point1 && point2) {
                    createLine(point1, point2, lineelement, lineelement2);
                    point1 = null;
                    point2 = null;
                }
                line = false;
            }
        }
    }
});

canvas.addEventListener("mousedown", (e) => {
    if (selectedElement === 'square') {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const col = Math.floor(mouseX / voxelSize);
        const row = Math.floor(mouseY / voxelSize);

        if (row >= 0 && row < rows && col >= 0 && col < cols) {
            if (!line) {
                point1 = { row, col };
                line = true;
            } else {
                point2 = { row, col };
                if (point1 && point2) {
                    createSquare(point1, point2, lineelement, lineelement2);
                    point1 = null;
                    point2 = null;
                }
                line = false;
            }
        }
    }
});

canvas.addEventListener("mousedown", (e) => {
    if (selectedElement === 'circle') {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const col = Math.floor(mouseX / voxelSize);
        const row = Math.floor(mouseY / voxelSize);

        if (row >= 0 && row < rows && col >= 0 && col < cols) {
            if (!line) {
                point1 = { row, col };
                line = true;
            } else {
                point2 = { row, col };
                if (point1 && point2) {
                    createCircle(point1, point2, lineelement, lineelement2);
                    point1 = null;
                    point2 = null;
                }
                line = false;
            }
        }
    }
});
let points = [];  // Store clicked points
function createPolygon(points, element1, element2) {
  deletePreviewVoxels2();

  function drawLine(p1, p2) {
    const dx = p2.col - p1.col;
    const dy = p2.row - p1.row;
    const steps = Math.max(Math.abs(dx), Math.abs(dy));
    for (let i = 0; i <= steps; i++) {
      const col = Math.round(p1.col + (dx * i) / steps - 1);
      const row = Math.round(p1.row + (dy * i) / steps);
      if (grid[row] && grid[row][col]) {
        if(element2){
    if(getCellRandom(col, row) < 0.5){
        grid[row][col].element = element1;
    } else{
        grid[row][col].element = element2;
    }
} else {
    grid[row][col].element = element1;
}
      }
    }
  }

  if (points.length === 3) {
    drawLine(points[0], points[1]);
    drawLine(points[1], points[2]);
    drawLine(points[2], points[0]);
  }
}
canvas.addEventListener("mousemove", (e) => {
  if (selectedElement === 'triangle' && points.length > 0) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    const col = Math.floor(mouseX / voxelSize);
    const row = Math.floor(mouseY / voxelSize);

    const previewPoints = [...points, { row, col }];
    previewTriangle(previewPoints, lineelement, lineelement2);
  }
});
function previewTriangle(points, element1, element2) {
    deletePreviewVoxels2(); // Clear previous previews

    const rect = canvas.getBoundingClientRect();
    const canvasLeft = rect.left;
    const canvasTop = rect.top;

    const defaultColor = '#888';
   

    function getColor(col, row) {
    const rand = getCellRandom(col, row);  // Get the random value based on row and col
    const elementName = rand < 0.5 ? element1 : element2;
    const elementData = elements[elementName];

    if (!elementData) return '#888';  // Return a fallback color if element is not found

    // Combine the rand, row, and col to create a new seed or pattern for color selection
    const combinedSeed = rand < 0.5 ? 1 : 0; // Alternating color pattern based on rand, row, and col

    // Check if color1 and color2 exist
    if (elementData.color1 && elementData.color2) {
        // Choose color1 or color2 based on combinedSeed (either 0 or 1)
        return combinedSeed === 0 ? elementData.color1 : elementData.color2;
    }

    // Fallback for when color1 and color2 are not defined, using an array of colors
    if (Array.isArray(elementData.colors)) {
        const index = Math.floor((rand + row + col) % elementData.colors.length);  // Cycle through colors based on combinedSeed
        return elementData.colors[index];
    }

    // Return a default color if no other options are available
    return elementData.color || elementData.initialColor || '#888';
}

    function addVoxel(col, row, color) {
        const div = document.createElement('div');
        div.className = 'preview-voxel';
        div.style.position = 'absolute';
        div.style.left = `${canvasLeft + col * voxelSize}px`;
        div.style.top = `${canvasTop + row * voxelSize}px`;
        div.style.width = `${voxelSize}px`;
        div.style.height = `${voxelSize}px`;
        div.style.backgroundColor = color;
        div.style.opacity = '0.5';
        div.style.pointerEvents = 'none';
        document.body.appendChild(div);
        previewVoxels.push(div);
    }

    function drawVoxelLine(p1, p2) {
        let x0 = p1.col;
        let y0 = p1.row;
        let x1 = p2.col;
        let y1 = p2.row;

        const dx = Math.abs(x1 - x0);
        const dy = -Math.abs(y1 - y0);
        const sx = x0 < x1 ? 1 : -1;
        const sy = y0 < y1 ? 1 : -1;
        let err = dx + dy;

        while (true) {
            addVoxel(x0, y0, getColor(x0, y0));
            if (x0 === x1 && y0 === y1) break;
            const e2 = 2 * err;
            if (e2 >= dy) { err += dy; x0 += sx; }
            if (e2 <= dx) { err += dx; y0 += sy; }
        }
    }

    function pointInTriangle(px, py, ax, ay, bx, by, cx, cy) {
        const area = 0.5 * (-by * cx + ay * (-bx + cx) + ax * (by - cy) + bx * cy);
        const s = 1 / (2 * area) * (ay * cx - ax * cy + (cy - ay) * px + (ax - cx) * py);
        const t = 1 / (2 * area) * (ax * by - ay * bx + (ay - by) * px + (bx - ax) * py);
        const u = 1 - s - t;
        return s >= 0 && t >= 0 && u >= 0;
    }

    if (points.length === 2) {
        drawVoxelLine(points[0], points[1]);
    }

    if (points.length === 3) {
        const [a, b, c] = points;
        const minCol = Math.min(a.col, b.col, c.col);
        const maxCol = Math.max(a.col, b.col, c.col);
        const minRow = Math.min(a.row, b.row, c.row);
        const maxRow = Math.max(a.row, b.row, c.row);

        for (let row = minRow; row <= maxRow; row++) {
            for (let col = minCol; col <= maxCol; col++) {
                const centerX = col + 0.5;
                const centerY = row + 0.5;
                if (pointInTriangle(centerX, centerY, a.col, a.row, b.col, b.row, c.col, c.row)) {
                    addVoxel(col, row, getColor(col, row));
                }
            }
        }
    }
}


canvas.addEventListener("mousedown", (e) => {
    if (selectedElement === 'triangle') {
        const rect = canvas.getBoundingClientRect();
        const col = Math.floor((e.clientX - rect.left) / voxelSize);
        const row = Math.floor((e.clientY - rect.top) / voxelSize);

        points.push({ row, col });

        if (points.length === 3) {
            createPolygon(points, lineelement, lineelement2);
            fillTriangleVoxel(points, lineelement, lineelement2);
            points = []; // Reset
        }
    }
});

let point3 = null;

let phantomElements = [];
let isPlacing = false;
canvas.addEventListener("mousedown", (e) => {
    if(selectedElement === 'move'){
    let newPhantomElements = [];

    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            if (grid[y][x].selected) {
                newPhantomElements.push({
                    x,
                    y,
                    element: JSON.parse(JSON.stringify(grid[y][x])) // Deep copy
                });
                grid[y][x] = { element: "empty" }; // Remove original element
            }
        }
    
    }

    if (newPhantomElements.length > 0) {
        phantomElements = newPhantomElements;
        isPlacing = true;
    }
}
});


const colorPicker = document.getElementById("colorPicker");
let selectedColor = "#ff0000"; // Default color

// Listen for color changes
colorPicker.addEventListener("input", (event) => {
    selectedColor = event.target.value;
});
const linecontainer = document.getElementById("linecontainer");
const screenc = document.getElementById("screencapture");

function updateUI() {
    textbutton.style.display = selectedElement === 'text' ? 'flex' : 'none';
    linecontainer.style.display = selectedElement === 'line' || selectedElement === 'square' || selectedElement === 'circle' || selectedElement === 'triangle'  ? 'block' : 'none';
    imagebutton.style.display = selectedElement === 'image' || selectedElement === 'media' || selectedElement === 'screen' ? 'flex' : 'none';
    screenc.style.display = selectedElement === 'screen' ? 'flex' : 'none';

    colorPicker.style.display = (
        selectedElement === 'coloredvoxel' ||
        selectedElement === 'paint' ||
        selectedElement === 'paintball' ||
        selectedElement === 'pointer'
    ) ? 'block' : 'none';
}



canvas.addEventListener("mousemove", (e) => {
    if (!isPlacing || phantomElements.length === 0) return;
    
    let mouseX = Math.floor(e.offsetX / voxelSize);
    let mouseY = Math.floor(e.offsetY / voxelSize);

    drawGrid(); // Clear the canvas first

    phantomElements.forEach((phantom) => {
        let offsetX = phantom.x - phantomElements[0].x;
        let offsetY = phantom.y - phantomElements[0].y;

        let newX = mouseX + offsetX;
        let newY = mouseY + offsetY;

        if (newX < 0 || newX >= cols || newY < 0 || newY >= rows) return;

        // Extract the original element color
        let color = "#FFFFFF"; // Default
        if (phantomElement.element.color) {
            color = phantom.element.color;
        } else if (phantom.element.colors && phantom.element.colors.length > 0) {
            color = phantom.element.colors[0]; // Use first color
        }

        // Convert color to semi-transparent
        if (!color.includes("rgba")) {
            color = color.replace("rgb", "rgba").replace(")", ", 0.5)");
        }

        ctx.fillStyle = color;
        ctx.fillRect(newX * voxelSize, newY * voxelSize, voxelSize, voxelSize);
    });
});


let isPlacing2 = false; // Renamed state variable for placing
let pasteX = 0; // Position where the paste will occur
let pasteY = 0; // Position where the paste will occur


// Step 1: Collect selected elements and clear the grid
document.addEventListener("keydown", (e) => {
    if(cmd === false){
    if (e.key === "v" || e.key === "V") {
      
            // Collect the selected elements when V is pressed
            phantomElements2 = [];
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    if (grid[y][x].selected) {
                        phantomElements2.push({
                            x2: x,  // Renamed with a '2' at the end
                            y2: y,  // Renamed with a '2' at the end
                            element2: JSON.parse(JSON.stringify(grid[y][x])) // Deep copy and renamed
                        });
                       
                    }
                }
            }
            

          
      
            // Paste the elements when "V" is pressed again while in placing mode
            if (phantomElements2.length === 0) return;

            phantomElements2.forEach((phantom2) => {
                let newX2 = pasteX + (phantom2.x2 - phantomElements2[0].x2);
                let newY2 = pasteY + (phantom2.y2 - phantomElements2[0].y2);

                // Ensure placement is within bounds
                if (newX2 >= 0 && newX2 < cols && newY2 >= 0 && newY2 < rows) {
                    grid[newY2][newX2] = JSON.parse(JSON.stringify(phantom2.element2)); // Place the phantom element
                    grid[newY2][newX2].selected = false;
                }
            });

            // After placing, stop the placement
            phantomElements2 = [];
            isPlacing2 = false;
        }

        drawGrid(); // Refresh the canvas
    }
    
});

// Update the paste position on mousemove (for example)
canvas.addEventListener("mousemove", (e) => {
    pasteX = Math.floor(e.offsetX / voxelSize); // X position for pasting
    pasteY = Math.floor(e.offsetY / voxelSize); // Y position for pasting
});

canvas.addEventListener("mouseup", (e) => {
    if (!isPlacing || phantomElements.length === 0) return;

    let mouseX = Math.floor(e.offsetX / voxelSize);
    let mouseY = Math.floor(e.offsetY / voxelSize);

    // Get the center position where you want to place the phantom elements
    let centerX = mouseX;
    let centerY = mouseY;

    phantomElements.forEach((phantom, index) => {
        // Adjust the offset so that the phantom elements are centered around the mouse
        let offsetX = phantom.x - phantomElements[0].x;
        let offsetY = phantom.y - phantomElements[0].y;

        // Calculate new positions relative to the center
        let newX = centerX + offsetX;
        let newY = centerY + offsetY;

        // Ensure the new position is within the grid bounds
        if (newX >= 0 && newX < cols && newY >= 0 && newY < rows) {
            grid[newY][newX] = JSON.parse(JSON.stringify(phantom.element)); // Restore full data
        }
    });

    phantomElements = [];
    isPlacing = false;
    drawGrid(); // Refresh canvas
});

   

        let selectionBox = null;
    let startX = null;
   
    let startY = null;
    canvas.addEventListener('mousedown', (e) => {
        
    if (selectedElement === 'select') {

        const rect = canvas.getBoundingClientRect(); // Get the canvas's position relative to the page

        startX = e.clientX - rect.left; // Adjust for canvas position
        startY = e.clientY - rect.top; // Adjust for canvas position

        if (!selectionBox) {
            selectionBox = document.createElement('div');
            selectionBox.classList.add('selection-box');
            document.body.appendChild(selectionBox);
        }

        selectionBox.style.left = `${e.clientX}px`;
        selectionBox.style.top = `${e.clientY}px`;
        selectionBox.style.width = '0px';
        selectionBox.style.height = '0px';
        selectionBox.style.display = 'block';

        // Mouse move event to resize the selection box
        const onMouseMove = (e) => {
            const width = e.clientX - (startX + rect.left);
            const height = e.clientY - (startY + rect.top);

            selectionBox.style.width = `${Math.abs(width)}px`;
            selectionBox.style.height = `${Math.abs(height)}px`;
            selectionBox.style.left = `${width < 0 ? e.clientX : startX + rect.left}px`;
            selectionBox.style.top = `${height < 0 ? e.clientY : startY + rect.top}px`;
        };

        // Mouse up event to select grid cells
        const onMouseUp = (e) => {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);

            const endX = e.clientX - rect.left; // Adjust for canvas position
            const endY = e.clientY - rect.top; // Adjust for canvas position

            const startCol = Math.floor(Math.min(startX, endX) / voxelSize);
            const endCol = Math.floor(Math.max(startX, endX) / voxelSize);
            const startRow = Math.floor(Math.min(startY, endY) / voxelSize);
            const endRow = Math.floor(Math.max(startY, endY) / voxelSize);

            // Mark the selected grid cells
            for (let r = startRow; r <= endRow; r++) {
                for (let c = startCol; c <= endCol; c++) {
                    if (grid[r] && grid[r][c] && grid[r][c].element !== 'empty') {
                        if (grid[r][c]) {
                            grid[r][c].selected = true; // Mark selected cells correctly
                            grid[r][c].stop = true;
                        }
                    }
                }
            }

            // Hide the selection box
            selectionBox.style.display = 'none';
            selectionBox = null;

            drawGrid(); // Re-draw the grid to reflect the selection
        };

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
    }

});
canvas.addEventListener('mousedown', (e) => {
               
               if (isDrawing) {
                 
                       const x = e.offsetX;
                   const y = e.offsetY;
           
                   placeElement(x, y);
                       
                     
                  
               }
               
           });
        canvas.addEventListener('mousemove', (e) => {
    if (isDrawing) {
      
            const x = e.offsetX;
        const y = e.offsetY;

        placeElement(x, y);
            
          
       
    }
    
    // Get the mouse position
    const col = Math.floor((e.offsetX / voxelSize)-1);
    const row = Math.floor(e.offsetY / voxelSize);
    
    // Check if the position is within the bounds of the grid
    if (row >= 0 && row < rows && col >= 0 && col < cols) {
        const hoveredElement = grid[row][col].element; // Get the element type
        const elementName = hoveredElement.charAt(0).toUpperCase() + hoveredElement.slice(1); // Capitalize the first letter

        // Display the element name in the hoverInfo div
        document.getElementById('hoverInfo').innerText = `Element: ${elementName}`;
        } else {
        // Clear the hover info if outside bounds
        document.getElementById('hoverInfo').innerText = '';
    }
});

 

        document.getElementById('brushSize').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value, 10);
        });
 
 
 
 
 
 
 
 
     
      

 
 
 
 
 
 
       
       
        function updatebutton() {
       document.getElementById("color").style.backgroundColor = selectedColor;
       document.getElementById("color2").style.backgroundColor = selectedColor;
          document.getElementById("color3").style.backgroundColor = selectedColor;
        }
        let lastFrameTime = 0;
        let frameDelay = 48;
        
        
        
let isPaused = false; // Variable to track if the simulation is paused
let catshown = true; // Variable to track if the simulation is paused

let averageFrameTime = frameDelay; // Initial estimate for frame time

// Smoothing factor for moving average (lower values smooth more)
const smoothingFactor = 0.0005;

// Pause/Play button logic
document.getElementById('pauseButton').addEventListener('click', () => {
    isPaused = !isPaused; // Toggle the paused state
    const button = document.getElementById('pauseButton');
    if (isPaused) {
        button.classList.remove('pause');
        button.classList.add('play');
    } else {
        button.classList.remove('play');
        button.classList.add('pause');
    }
});
// Pause/Play button logic


function animate(currentTime) {
   
    if (!isPaused) {
        const frameTime = currentTime - lastFrameTime;


        // Smoothly adjust the average frame time using exponential moving average
        averageFrameTime += smoothingFactor * (frameTime - averageFrameTime);


        // Dynamically adjust frame delay to target the average
        frameDelay = Math.max(averageFrameTime, 16); // Ensure a minimum delay (16ms ~ 60 FPS)


        if (frameTime >= frameDelay) {
            lastFrameTime = currentTime;
            updateGrid(); // Update the state of the grid
        }
    }
    if(selectedElement === 'line' || selectedElement === 'square' || selectedElement === 'circle' || selectedElement === 'triangle'){
         lineelement = document.getElementById("elementline").value;
         lineelement2 = document.getElementById("elementline2").value;
    }
    drawCursorPolygon();
    drawGrid(); // Always draw the grid to keep the elements visible
    requestAnimationFrame(animate); // Continue the animation loop
    ambiance();
    drawStars(ctx);
    updateUI();
    updatebutton();
    if(night){
    music.addEventListener("ended", playnight);
    }
    
    if(dreamspace){
       
       music.addEventListener("ended", playDreamspace);
     

        
    drawdreamStars(ctx);
    }
   


   

}


// Start the animation loop
requestAnimationFrame(animate);






        initializeGrid();

    </script>
 </body>

 </html>
